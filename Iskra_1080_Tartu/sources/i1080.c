// Реверс-инженеринг ПЗУ компьютера Искра 1080 Тарту
// В процессе
// (c) 06-09-2020 Aleksey Morozov

#include "cmm.h"
#include "i1080.h"
#include "i1080_internal.h"

extern uint8_t vPrintDisabled __address(0x020E);
extern uint16_t word_26E __address(0x26E);
extern uint16_t vBasicProgrammBegin __address(0x0272);
extern uint16_t vBasicProgrammEnd __address(0x0236);
extern uint8_t byte_241 __address(0x241);
extern uint16_t vRst30ReturnAddress __address(0x275);

void Rst8a(...) __address(0xD006);
void BasSyntaxError(...) __address(0xD13F);
void GetSymbolOrNumberEx(...) __address(0xD598);
void Loc_D3FC(...) __address(0xD3FC);
void Rst30a(...) __address(0xD00C);
void CpmEntry(...) __address(0x9C00);
void CallE332(...) __address(0xE332);

void Init(...);
void CallRamRst38Handler(...);
void VideoDrawChar64X0(...);
void VideoDrawChar64X1(...);
void VideoDrawChar64End(...);
void VideoDrawCharEnd(...);
void TapePrintDone(...);
void loc_EC87(...);
void VideoPrintRomString(...);
void TapeWriteArray(...);
void TapeAsciiPrintInternal(...);
void MonitorPrintHexDump(...);
void MonitorDirectiveLInternal(...);
void MonitorDirectiveSet(...);
void VideoRedrawTextScreen(...);
void VideoNextLineClear(...);
void MemcpyHlBcDe(...);
void InitMonitor(...);
void MonitorLoop(...);
void DisassemblerEnd(...);
void VideoInverseInternal(...);
void VideoSetModeInternal(...);
void VideoSetFontHeightInternal(...);
void VideoSetCursorInternal(...);
void VideoMoveCursorRight2(...);
void KeyboardGetNoWaitEnd(...);
void BiosWriteReadInternal(...);
void VideoDrawChar64X0L(...);
void VideoDrawChar64X1L(...);
void VideoDrawChar64X2L(...);
void VideoDrawChar64X3L(...);
void TapeBeginDialog(...);
void TapeReadPilot(...);
void TapeReadByte(...);
void TapePrintFound(...);
void TapeAsciiInputInternal(...);
void TapeReadWord(...);
void TapeIntractiveWriteHeader(...);
void TapeWritePilot(...);
void TapeDelay(...);
void TapeWriteByte(...);
void TapeWriteWord(...);
void TapeAsciiFlush(...);
void PrintNewLine(...);
void RealInput2(...);
void MonitorParseChar(...);
void MonitorParseNumber(...);
void PrintHexWord(...);
void PrintSpace(...);
void PrintHexByte(...);
void MonitorPrintHexDumpLoop(...);
void PrintString(...);
void SkipSpaces(...);
void CharCodeToNumber(...);
void MonitorParseSkip(...);
void MonitorDirectiveIOInternal(...);
void VideoInverse(...);
void VideoNormal(...);
void PrintHexNibble(...);
void MonitorDirectiveVPrint(...);
void VideoClearScreen0(...);
void Init2(...);
void Init3(...);
void UartSetMode(...);
void KeyboardIsCtrPressed(...);
void KeyboardIsShiftPressed(...);
void IsSomethingConnected(...);
void IsFloppyConnected(...);
void VideoSetCursorY(...);
void MonitorInput(...);
void Test(...);
void Disassembler(...);
void VideoPrintSpaces(...);
void DisassemblerPrint(...);
void DisassemblerPrintFromArray(...);
void DisassemblerArgumentD(...);
void VideoPrintSpaces11(...);
void PrintHexByteFromHl(...);
void DisassemblerArgumentA(...);
void DisassemblerPrintInternal(...);
void KeyboardReplaceFKeys(...);
void VideoMoveCursorUp(...);
void VideoMoveCursorDown(...);
void VideoMoveCursorLeft(...);
void VideoMoveCursorRight(...);
void KeyboardSetRussianLayout(...);
void KeyboardSetEnglishLayout(...);
void VideoNextLine(...);
void MonitorInputBackspace(...);
void MultipleHlBy64(...);
void VideoDrawChar(...);
void VideoScrollUp(...);
void WaitIfKeyPressed(...);
void KeyboardGet(...);
void VideoClearScreenInternal(...);
void MemsetHlBDe(...);
void VideoMoveCursorLeftTop(...);
void VideoScrollUp0(...);
void Call0000(...);
void Enable0000Rom(...);
void Enable0000Ram(...);
void KeyboardGetNoWait(...);
void KeyboardGetInternal(...);
void DelayHl(...);
void KeyboardGetNoWaitIsShift(...);
void KeyboardIs71Pressed(...);
void CompareBcHl(...);
void KeyboardIsKeyPressed(...);
void TestEmptyRom(...);
void TestCheckFill(...);
void TapeWriteHalfBit1(...);
void TapeWritePeriod(...);
void TapeWriteBit1(...);
void TapeWriteBit0(...);
void TapeReadBit(...);
void KeyboardIsF1Pressed(...);
void TapeReadHalfBitF1(...);
void TapeReadChanges(...);
void TapeReadHalfBit(...);
void VideoDrawChar64X2(...);
void VideoDrawChar64X3(...);
void TapeLoadError(...);
void TapeVerifyLoadRetry(...);
void TapeLoadAsciiOverflow(...);
void TapeVerifyError(...);
void MonitorDirectiveEx(...);
void MonitorDirectiveI(...);
void MonitorDirectiveO(...);
void MonitorDirectiveW(...);
void MonitorDirectiveR(...);
void MonitorDirectiveG(...);
void MonitorDirectiveM(...);
void MonitorDirectiveV(...);
void MonitorDirectiveT(...);
void InitCold(...);
void InitSomething(...);
void InitFloppy(...);
void DisassemblerPrintVariant1(...);
void DisassemblerMov(...);
void DisassemblerVariant2(...);
void VideoGetCharCodeUnderCursor(...);
void MonitorInputError(...);
void VideoPrintEscCursor(...);
void VideoPrintNoEsc(...);
void VideoClearRight(...);
void Beep(...);
void VideoSetCursorXInternal(...);
void KeyboardGetNoWaitInternal(...);
void TestFailed(...);
void UartSetModeSpeed0(...);
void UartSetModeSpeed1(...);
void UartSetModeSpeed2(...);
void TapeReadEndBitOverflow(...);
void TapeLoadBasic(...);
void TapeLoadAscii(...);
void TapeLoadBinary(...);
void TapeVerifyBasic(...);
void Rst10(...);
void TestRom(...);
void MonitorError(...);
void Enable0000Internal(...);
void KeyboardIsKeyPressedInternal(...);
void UartSetModeInternal(...);
void UartModeInternal10(...);
void TapeReadEndBit(...);
void TapeAsciiInput(...);
void KeyboardSetLayout(...);

//----------------------------------------------------------------------------------------------------------------------
// Эта часть кода может подключаться к адресам 0 - 0FFh через порт 0A8h. В этом случае она доступна выполнение и чтение.
// Эта часть кода доступна на чтение по адресам 0C000h - 0C7FFh кодом из ПЗУ 0C800h - 0FFFFh
//----------------------------------------------------------------------------------------------------------------------

asm(" org 0");

// Запуск компьютера

void Rst0(...) {
    DisableInterrupts();
    return Init();
}

uint8_t data1[] = {0xFF, 0xFF, 0x23, 0xE3};

void Rst8(...) {
    a = *hl;
    Swap(*sp, hl);
    return Rst8a();
}

void Rst8B(...) {
    if (flag_nz) return BasSyntaxError();
    hl++;
    return Rst10();
}

void Rst10(...) {
    a = *hl;
    if (a >= ':') return;
    return GetSymbolOrNumberEx();
}

void Rst18(...) {
    push(a);
    (a = vPrintDisabled) |= a;
    return Loc_D3FC();
}

void Rst20(...) {
    (a = h) -= d;
    if (flag_nz) return;
    (a = l) -= e;
}

uint8_t data2[] = {0xFF, 0xFF};

void Rst28(...) {
    a = byte_241;
    if (flag_nz(a |= a)) return CallE332();
}

void Rst30AtC000(...) {
    swap(*sp, hl);
rst30b:
    vRst30ReturnAddress = hl;
    pop(hl);
    return Rst30a();
}

// Обработчик прерывания когда подключено ПЗУ в 0 - 0FFh

void Rst38(...) {
    return CallRamRst38Handler();
}

uint8_t vUnused1[] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

void UnusedFunction1(...) {
    a = *bc;
}

void UnusedFunction2(...) {
    a = *de;
}

void UnusedFunction3(...) {
    a = *hl;
}

// Внутренняя функция. Используется функцией VideoScrollUp0.
// Прокрутить на одну строку вверх графический черно-белый экран без очистки нижней строки

const int VIDEO_COPY_UP_BLOCK = 8;
const int VIDEO_COPY_UP_COLUMN = 0x100;
const int FONT_HEIGHT = 10;

void VideoCopy0Up(...) {
    // Сохранить SP
    vTempSP = ((hl = 0) += sp);
    // Поместить адрес записи в SP. +SCROLL_NEXT_COLUMN это компенсация уменьшения далее.
    sp = SCREEN_0_ADDRESS + VIDEO_COPY_UP_COLUMN;
    // Перенос данных на SCROLL_BY строк выше. -1 это пропущенный hl-- далее.
    de = -FONT_HEIGHT - 1;
    // Цикл от 0x??00 до 0x??18
    do {
        // Перемещение на первую строку. -SCROLL_BLOCK это компенсация увеличения далее.
        sp = ((hl = SCREEN_SIZE - VIDEO_COPY_UP_BLOCK) += sp);
        // Цикл от 0xFF?? до 0xD0??
        a = 0xD0;
        do {
            // Перемещение на следущую колонку и возврат на туже строку
            hl = -VIDEO_COPY_UP_COLUMN + VIDEO_COPY_UP_BLOCK;
            hl += sp;
            sp = hl;
            hl += de;

            // Копирование 8 строк из hl - 7 .. hl в sp - 8 .. sp - 1
            b = *hl;
            hl--;
            c = *hl;
            hl--;
            push(bc);

            b = *hl;
            hl--;
            c = *hl;
            hl--;
            push(bc);

            b = *hl;
            hl--;
            c = *hl;
            hl--;
            push(bc);

            b = *hl;
            hl--;
            c = *hl;
            push(bc);
            // Тут SP равно: FFF8, FEF8, FDF8 .. D0F8, FFF0...
        } while (a != h);
        // Тут SP равно: D0F8, D0F0, D0E8 .. D010
    } while ((a = l) >= 0x0C);
    // Восстановление SP
    sp = hl = vTempSP;
    return TestRom();
}

// Самодиагностика при включении. Пустая внутренняя функция. Эта функция вызывается функцией Test.

void TestRom(...) {
}

//----------------------------------------------------------------------------------------------------------------------
// Эта часть кода доступна на чтение по адресам 0C800h - 0CFFFh кодом из ПЗУ 0C800h - 0CFFFh
//----------------------------------------------------------------------------------------------------------------------

asm(" org 0xC100");

uint8_t BasicC100[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08, 0x00, 0x14, 0x14, 0x14,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x14, 0x3e, 0x14, 0x3e, 0x14, 0x14, 0x00, 0x22, 0x1c, 0x22, 0x22, 0x22, 0x1c,
    0x22, 0x00, 0x30, 0x32, 0x04, 0x08, 0x10, 0x26, 0x06, 0x00, 0x10, 0x28, 0x28, 0x10, 0x2a, 0x24, 0x1a, 0x00, 0x08,
    0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, 0x08, 0x04, 0x02, 0x02,
    0x02, 0x04, 0x08, 0x00, 0x08, 0x2a, 0x1c, 0x08, 0x1c, 0x2a, 0x08, 0x00, 0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x1c, 0x22, 0x26, 0x2a, 0x32,
    0x22, 0x1c, 0x00, 0x08, 0x18, 0x28, 0x08, 0x08, 0x08, 0x3c, 0x00, 0x1c, 0x22, 0x02, 0x0c, 0x10, 0x20, 0x3e, 0x00,
    0x3e, 0x02, 0x04, 0x0c, 0x02, 0x22, 0x1c, 0x00, 0x04, 0x0c, 0x14, 0x24, 0x3e, 0x04, 0x04, 0x00, 0x3e, 0x20, 0x3c,
    0x02, 0x02, 0x22, 0x1c, 0x00, 0x0c, 0x10, 0x20, 0x3c, 0x22, 0x22, 0x1c, 0x00, 0x3e, 0x02, 0x04, 0x08, 0x10, 0x10,
    0x10, 0x00, 0x1c, 0x22, 0x22, 0x1c, 0x22, 0x22, 0x1c, 0x00, 0x1c, 0x22, 0x22, 0x1e, 0x02, 0x04, 0x38, 0x00, 0x00,
    0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x08, 0x10, 0x00, 0x04, 0x08, 0x10, 0x20,
    0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10,
    0x00, 0x1c, 0x22, 0x04, 0x08, 0x08, 0x00, 0x08, 0x00, 0x1c, 0x22, 0x2a, 0x2e, 0x2c, 0x20, 0x1e, 0x00, 0x08, 0x14,
    0x22, 0x22, 0x3e, 0x22, 0x22, 0x00, 0x3c, 0x22, 0x22, 0x3c, 0x22, 0x22, 0x3c, 0x00, 0x1c, 0x22, 0x20, 0x20, 0x20,
    0x22, 0x1c, 0x00, 0x3c, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3c, 0x00, 0x3e, 0x20, 0x20, 0x3c, 0x20, 0x20, 0x3e, 0x00,
    0x3e, 0x20, 0x20, 0x3c, 0x20, 0x20, 0x20, 0x00, 0x1e, 0x20, 0x20, 0x20, 0x26, 0x22, 0x1e, 0x00, 0x22, 0x22, 0x22,
    0x3e, 0x22, 0x22, 0x22, 0x00, 0x1c, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1c, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x22,
    0x1c, 0x00, 0x22, 0x24, 0x28, 0x30, 0x28, 0x24, 0x22, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3e, 0x00, 0x22,
    0x36, 0x2a, 0x2a, 0x22, 0x22, 0x22, 0x00, 0x22, 0x22, 0x32, 0x2a, 0x26, 0x22, 0x22, 0x00, 0x1c, 0x22, 0x22, 0x22,
    0x22, 0x22, 0x1c, 0x00, 0x3c, 0x22, 0x22, 0x3c, 0x20, 0x20, 0x20, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x2a, 0x24, 0x1a,
    0x00, 0x3c, 0x22, 0x22, 0x3c, 0x28, 0x24, 0x22, 0x00, 0x1c, 0x22, 0x20, 0x1c, 0x02, 0x22, 0x1c, 0x00, 0x3e, 0x08,
    0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1c, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x14, 0x08, 0x00, 0x22, 0x22, 0x22, 0x2a, 0x2a, 0x36, 0x22, 0x00, 0x22, 0x22, 0x14, 0x08, 0x14, 0x22, 0x22, 0x00,
    0x22, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x00, 0x3e, 0x02, 0x04, 0x08, 0x10, 0x20, 0x3e, 0x00, 0x3e, 0x30, 0x30,
    0x30, 0x30, 0x30, 0x3e, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x3e, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x3e, 0x00, 0x00, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x10,
    0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x02, 0x1e, 0x22, 0x1e, 0x00, 0x20, 0x20, 0x3c, 0x22,
    0x22, 0x22, 0x3c, 0x00, 0x00, 0x00, 0x1e, 0x20, 0x20, 0x20, 0x1e, 0x00, 0x02, 0x02, 0x1e, 0x22, 0x22, 0x22, 0x1e,
    0x00, 0x00, 0x00, 0x1c, 0x22, 0x3e, 0x20, 0x1e, 0x00, 0x0c, 0x12, 0x10, 0x3c, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
    0x1a, 0x26, 0x22, 0x1e, 0x02, 0x3c, 0x20, 0x20, 0x3c, 0x22, 0x22, 0x22, 0x22, 0x00, 0x08, 0x00, 0x18, 0x08, 0x08,
    0x08, 0x1c, 0x00, 0x04, 0x00, 0x0c, 0x04, 0x04, 0x04, 0x24, 0x18, 0x20, 0x20, 0x22, 0x24, 0x38, 0x24, 0x22, 0x00,
    0x18, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1c, 0x00, 0x00, 0x00, 0x36, 0x2a, 0x2a, 0x2a, 0x2a, 0x00, 0x00, 0x00, 0x2c,
    0x32, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x1c, 0x00, 0x00, 0x00, 0x3c, 0x22, 0x22, 0x3c,
    0x20, 0x20, 0x00, 0x00, 0x1e, 0x22, 0x22, 0x1e, 0x02, 0x02, 0x00, 0x00, 0x2e, 0x30, 0x20, 0x20, 0x20, 0x00, 0x00,
    0x00, 0x1e, 0x20, 0x1c, 0x02, 0x3c, 0x00, 0x10, 0x10, 0x3c, 0x10, 0x10, 0x12, 0x0c, 0x00, 0x00, 0x00, 0x22, 0x22,
    0x22, 0x26, 0x1a, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00, 0x22, 0x22, 0x2a, 0x2a, 0x36,
    0x00, 0x00, 0x00, 0x22, 0x14, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x1e, 0x02, 0x1c, 0x00, 0x00,
    0x3e, 0x04, 0x08, 0x10, 0x3e, 0x00, 0x0e, 0x18, 0x18, 0x30, 0x18, 0x18, 0x0e, 0x00, 0x08, 0x08, 0x08, 0x00, 0x08,
    0x08, 0x08, 0x00, 0x38, 0x0c, 0x0c, 0x06, 0x0c, 0x0c, 0x38, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x36, 0x36, 0x36, 0x00, 0x00, 0x22, 0x1c, 0x00, 0x14, 0x14, 0x17, 0x10, 0x17, 0x14, 0x14, 0x14, 0x00, 0x00, 0xff,
    0x00, 0xff, 0x00, 0x00, 0x00, 0x14, 0x14, 0xff, 0x00, 0xff, 0x14, 0x14, 0x14, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0xf8, 0x08, 0x08, 0x08, 0x00, 0x00, 0xff, 0x00, 0xff, 0x14, 0x14, 0x14, 0x00,
    0x00, 0x1f, 0x10, 0x17, 0x14, 0x14, 0x14, 0x14, 0x14, 0xf4, 0x04, 0xfc, 0x00, 0x00, 0x00, 0x14, 0x14, 0x17, 0x10,
    0x1f, 0x00, 0x00, 0x00, 0x14, 0x14, 0xf4, 0x04, 0xf4, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
    0x14, 0x00, 0x00, 0xfc, 0x04, 0xf4, 0x14, 0x14, 0x14, 0x08, 0x08, 0xf8, 0x08, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08,
    0x0f, 0x08, 0x0f, 0x08, 0x08, 0x08, 0x14, 0x14, 0x14, 0x14, 0xfc, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0xf8,
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0xff, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xff, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00,
    0x00, 0xff, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0xff, 0x08, 0x08, 0x08, 0x1c, 0x00, 0x1c, 0x22, 0x22, 0x22,
    0x1c, 0x00, 0x22, 0x08, 0x14, 0x22, 0x3e, 0x22, 0x22, 0x00, 0x22, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x1c, 0x00, 0x22,
    0x00, 0x22, 0x22, 0x22, 0x22, 0x1c, 0x00, 0x00, 0x1c, 0x00, 0x1c, 0x22, 0x22, 0x1c, 0x00, 0x14, 0x00, 0x1c, 0x02,
    0x1e, 0x22, 0x1e, 0x00, 0x00, 0x14, 0x00, 0x1c, 0x22, 0x22, 0x1c, 0x00, 0x00, 0x14, 0x00, 0x22, 0x22, 0x26, 0x1a,
    0x00, 0x14, 0x14, 0xff, 0x00, 0xff, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x14, 0x14, 0x14, 0x00, 0x00,
    0xf8, 0x08, 0xf8, 0x08, 0x08, 0x08, 0x14, 0x00, 0x3e, 0x20, 0x3c, 0x20, 0x3e, 0x00, 0x14, 0x14, 0x14, 0x14, 0xfc,
    0x00, 0x00, 0x00, 0x08, 0x08, 0xf8, 0x08, 0xf8, 0x00, 0x00, 0x00, 0x08, 0x08, 0x0f, 0x08, 0x0f, 0x08, 0x08, 0x08,
    0x14, 0x14, 0x14, 0x14, 0xff, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xff, 0x00, 0xff, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0xff, 0x14, 0x14, 0x14, 0x08, 0x08, 0x08, 0x08, 0xf8, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x08, 0x08, 0x08, 0x14, 0x14, 0x14, 0x14, 0x1f, 0x00, 0x00, 0x00, 0x08,
    0x08, 0x08, 0x0f, 0x08, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x08, 0x0f, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x1f, 0x14, 0x14, 0x14, 0x08, 0x08, 0x08, 0xff, 0x08, 0xff, 0x08, 0x08, 0x08, 0x14, 0x22, 0x22, 0x3e, 0x22, 0x22,
    0x00, 0x3e, 0x20, 0x20, 0x3c, 0x22, 0x22, 0x3c, 0x00, 0x3c, 0x22, 0x22, 0x3c, 0x22, 0x22, 0x3c, 0x00, 0x3e, 0x22,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x0c, 0x14, 0x14, 0x14, 0x14, 0x3e, 0x22, 0x00, 0x3e, 0x20, 0x20, 0x3c, 0x20,
    0x20, 0x3e, 0x00, 0x2a, 0x2a, 0x2a, 0x1c, 0x2a, 0x2a, 0x2a, 0x00, 0x1c, 0x22, 0x02, 0x0c, 0x02, 0x22, 0x1c, 0x00,
    0x22, 0x22, 0x26, 0x2a, 0x32, 0x22, 0x22, 0x00, 0x14, 0x08, 0x22, 0x26, 0x2a, 0x32, 0x22, 0x00, 0x22, 0x24, 0x28,
    0x30, 0x28, 0x24, 0x22, 0x00, 0x06, 0x0a, 0x12, 0x12, 0x12, 0x12, 0x22, 0x00, 0x22, 0x36, 0x2a, 0x22, 0x22, 0x22,
    0x22, 0x00, 0x22, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x22, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1c, 0x00, 0x3e,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x00, 0x3c, 0x22, 0x22, 0x3c, 0x20, 0x20, 0x20, 0x00, 0x1c, 0x22, 0x20, 0x20,
    0x20, 0x22, 0x1c, 0x00, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x22, 0x22, 0x22, 0x1e, 0x02, 0x22, 0x1c,
    0x00, 0x08, 0x1c, 0x2a, 0x2a, 0x2a, 0x1c, 0x08, 0x00, 0x22, 0x22, 0x14, 0x08, 0x14, 0x22, 0x22, 0x00, 0x24, 0x24,
    0x24, 0x24, 0x24, 0x3e, 0x02, 0x00, 0x22, 0x22, 0x22, 0x1e, 0x02, 0x02, 0x02, 0x00, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a,
    0x2a, 0x3e, 0x00, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x3e, 0x02, 0x00, 0x30, 0x10, 0x10, 0x1c, 0x12, 0x12, 0x1c, 0x00,
    0x22, 0x22, 0x32, 0x2a, 0x2a, 0x2a, 0x32, 0x00, 0x20, 0x20, 0x38, 0x24, 0x22, 0x24, 0x38, 0x00, 0x1c, 0x22, 0x02,
    0x1e, 0x02, 0x22, 0x1c, 0x00, 0x2e, 0x2a, 0x2a, 0x3a, 0x2a, 0x2a, 0x2e, 0x00, 0x1e, 0x22, 0x22, 0x1e, 0x0a, 0x12,
    0x22, 0x00, 0x00, 0x00, 0x1c, 0x02, 0x1e, 0x22, 0x1e, 0x00, 0x00, 0x00, 0x3e, 0x20, 0x3c, 0x22, 0x3c, 0x00, 0x00,
    0x00, 0x3c, 0x22, 0x3c, 0x22, 0x3c, 0x00, 0x00, 0x00, 0x3e, 0x22, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x0c, 0x14,
    0x14, 0x14, 0x3e, 0x22, 0x00, 0x00, 0x1c, 0x22, 0x3e, 0x20, 0x1e, 0x00, 0x00, 0x00, 0x2a, 0x2a, 0x1c, 0x2a, 0x2a,
    0x00, 0x00, 0x00, 0x1c, 0x22, 0x04, 0x02, 0x22, 0x1c, 0x00, 0x00, 0x22, 0x26, 0x2a, 0x32, 0x22, 0x00, 0x00, 0x14,
    0x08, 0x22, 0x26, 0x2a, 0x32, 0x00, 0x00, 0x00, 0x22, 0x24, 0x38, 0x24, 0x22, 0x00, 0x00, 0x00, 0x0e, 0x0a, 0x0a,
    0x12, 0x22, 0x00, 0x00, 0x00, 0x22, 0x36, 0x2a, 0x22, 0x22, 0x00, 0x00, 0x00, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x00,
    0x00, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x1c, 0x00, 0x00, 0x00, 0x3e, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x3c,
    0x22, 0x22, 0x3c, 0x20, 0x20, 0x00, 0x00, 0x1e, 0x20, 0x20, 0x20, 0x1e, 0x00, 0x00, 0x00, 0x3e, 0x08, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x00, 0x22, 0x22, 0x1e, 0x02, 0x02, 0x1c, 0x00, 0x00, 0x08, 0x3e, 0x2a, 0x3e, 0x08, 0x08, 0x00,
    0x00, 0x22, 0x14, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x24, 0x24, 0x24, 0x24, 0x3e, 0x02, 0x00, 0x00, 0x22, 0x22,
    0x1e, 0x02, 0x02, 0x00, 0x00, 0x00, 0x2a, 0x2a, 0x2a, 0x2a, 0x3e, 0x00, 0x00, 0x00, 0x2a, 0x2a, 0x2a, 0x2a, 0x3e,
    0x02, 0x00, 0x00, 0x30, 0x10, 0x1c, 0x12, 0x1c, 0x00, 0x00, 0x00, 0x22, 0x22, 0x3a, 0x2a, 0x3a, 0x00, 0x00, 0x00,
    0x20, 0x20, 0x38, 0x24, 0x38, 0x00, 0x00, 0x00, 0x3c, 0x02, 0x1e, 0x02, 0x3c, 0x00, 0x00, 0x00, 0x2e, 0x2a, 0x3a,
    0x2a, 0x2e, 0x00, 0x00, 0x00, 0x1e, 0x22, 0x1e, 0x12, 0x22, 0x00, 0x14, 0x14, 0x14, 0x14, 0xff, 0x14, 0x14, 0x14,
    0x14, 0x00, 0x1c, 0x22, 0x3e, 0x20, 0x1e, 0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x08,
    0x00, 0x3e, 0x00, 0x08, 0x00, 0x0c, 0x12, 0x12, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x12, 0x04, 0x08, 0x1e, 0x00,
    0x00, 0x00, 0x1e, 0x04, 0x0c, 0x02, 0x1c, 0x00, 0x00, 0x00, 0x08, 0x0c, 0x0a, 0x0a, 0x08, 0x18, 0x38, 0x10, 0x08,
    0x1c, 0x2a, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x2a, 0x1c, 0x08, 0x00, 0x00, 0x04, 0x02,
    0x3f, 0x02, 0x04, 0x00, 0x00, 0x00, 0x08, 0x10, 0x3f, 0x10, 0x08, 0x00, 0x3c, 0x7e, 0xff, 0xff, 0xff, 0xff, 0x7e,
    0x3c, 0x00, 0x0c, 0x1e, 0x3f, 0x3f, 0x1e, 0x0c, 0x00, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0x33, 0x33,
    0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xc3, 0x24, 0xc8, 0xc3, 0xdd, 0xcb, 0xc3, 0x30, 0xca, 0xc3, 0xa5, 0xca, 0xc3,
    0x05, 0xcd, 0xc3, 0x11, 0xcd, 0xc3, 0x1d, 0xcd, 0xc3, 0x29, 0xcd, 0xc3, 0x35, 0xcd, 0xc3, 0x3c, 0xcd, 0xc3, 0x43,
    0xcd, 0xc3, 0x4a, 0xcd, 0xe5, 0xd5, 0xc5, 0x21, 0x00, 0x80, 0xaf, 0x77, 0x23, 0x77, 0x23, 0x77, 0x23, 0x22, 0xe6,
    0x8f, 0x3a, 0xe2, 0x8f, 0x2f, 0x5f, 0x2a, 0xe0, 0x8f, 0xcd, 0x3f, 0xca, 0xcd, 0x14, 0xca, 0x32, 0xea, 0x8f, 0x4f,
    0x3a, 0xe4, 0x8f, 0xe6, 0x03, 0x32, 0xe4, 0x8f, 0xb9, 0xca, 0x6f, 0xc8, 0xcd, 0x73, 0xc8, 0xcd, 0x9d, 0xc8, 0xcd,
    0x17, 0xc9, 0xcd, 0x3b, 0xc9, 0xcd, 0x71, 0xc9, 0x7d, 0xb4, 0xca, 0x6f, 0xc8, 0xcd, 0x05, 0xca, 0xd2, 0x55, 0xc8,
    0xc3, 0x5e, 0xc8, 0xc1, 0xd1, 0xe1, 0xc9, 0xb7, 0x78, 0x1f, 0x47, 0xd2, 0x84, 0xc8, 0x25, 0x15, 0x06, 0x80, 0x7c,
    0xfe, 0xcf, 0xca, 0x93, 0xc8, 0xcd, 0x05, 0xca, 0xda, 0x93, 0xc8, 0xcd, 0x24, 0xca, 0xca, 0x7a, 0xc8, 0xc3, 0x73,
    0xc8, 0xb7, 0x78, 0x17, 0x47, 0xd0, 0x14, 0x24, 0x06, 0x01, 0xc9, 0xe5, 0xd5, 0xc5, 0x3a, 0xe4, 0x8f, 0x4f, 0x1f,
    0x78, 0xd2, 0xad, 0xc8, 0xb6, 0xc3, 0xaf, 0xc8, 0x2f, 0xa6, 0x77, 0x79, 0x1f, 0x1f, 0x1a, 0x4f, 0x78, 0xd2, 0xbd,
    0xc8, 0xb1, 0xc3, 0xbf, 0xc8, 0x2f, 0xa1, 0x12, 0x7c, 0x32, 0xe8, 0x8f, 0xb7, 0x78, 0x32, 0xe9, 0x8f, 0x17, 0x47,
    0xd2, 0xde, 0xc8, 0x06, 0x80, 0x78, 0x32, 0xe9, 0x8f, 0x7c, 0xfe, 0xff, 0xca, 0x13, 0xc9, 0x14, 0x24, 0x06, 0x01,
    0xcd, 0x05, 0xca, 0xda, 0x13, 0xc9, 0x7e, 0xb7, 0xca, 0xed, 0xc8, 0x3c, 0xc2, 0xa0, 0xc8, 0x1a, 0xb7, 0xca, 0xf6,
    0xc8, 0x3c, 0xc2, 0xa0, 0xc8, 0x3a, 0xe4, 0x8f, 0x4f, 0x1f, 0x3e, 0xff, 0xda, 0x01, 0xc9, 0x3c, 0x77, 0x79, 0x1f,
    0x1f, 0x3e, 0xff, 0xda, 0x0b, 0xc9, 0x3c, 0x12, 0x7c, 0x32, 0xe8, 0x8f, 0xc3, 0xce, 0xc8, 0xc1, 0xd1, 0xe1, 0xc9,
    0xe5, 0xd5, 0xc5, 0x7d, 0xfe, 0xff, 0xca, 0x37, 0xc9, 0x1c, 0x2c, 0xcd, 0x05, 0xca, 0xd2, 0x31, 0xc9, 0xcd, 0x80,
    0xc9, 0xdc, 0xb8, 0xc9, 0xc3, 0x37, 0xc9, 0xcd, 0x73, 0xc8, 0xcd, 0xb8, 0xc9, 0xc1, 0xd1, 0xe1, 0xc9, 0xe5, 0xd5,
    0xc5, 0x7d, 0xfe, 0x00, 0xca, 0x5b, 0xc9, 0x1d, 0x2d, 0xcd, 0x05, 0xca, 0xd2, 0x55, 0xc9, 0xcd, 0x80, 0xc9, 0xdc,
    0xb8, 0xc9, 0xc3, 0x5b, 0xc9, 0xcd, 0x73, 0xc8, 0xcd, 0xb8, 0xc9, 0xc1, 0xd1, 0xe1, 0xc9, 0xe5, 0xd5, 0xeb, 0x2a,
    0xe6, 0x8f, 0x72, 0x23, 0x73, 0x23, 0x70, 0x23, 0x22, 0xe6, 0x8f, 0xd1, 0xe1, 0xc9, 0x2a, 0xe6, 0x8f, 0x2b, 0x46,
    0x2b, 0x5e, 0x2b, 0x56, 0x22, 0xe6, 0x8f, 0xc3, 0x82, 0xca, 0x3a, 0xe8, 0x8f, 0xbc, 0xc2, 0x8c, 0xc9, 0x3a, 0xe9,
    0x8f, 0xb8, 0xc8, 0xb7, 0x78, 0x17, 0x47, 0xd2, 0x9b, 0xc9, 0x7c, 0xfe, 0xff, 0xc8, 0x14, 0x24, 0x06, 0x01, 0xcd,
    0x05, 0xca, 0xd2, 0xb6, 0xc9, 0xcd, 0x24, 0xca, 0xc2, 0x80, 0xc9, 0x3a, 0xe8, 0x8f, 0xbc, 0xc2, 0x97, 0xc9, 0x3a,
    0xe9, 0x8f, 0xb8, 0xc8, 0xc3, 0x8c, 0xc9, 0x37, 0xc9, 0xe5, 0xd5, 0xc5, 0x0e, 0x00, 0xcd, 0x5f, 0xc9, 0x3a, 0xe8,
    0x8f, 0xbc, 0xc2, 0xce, 0xc9, 0x3a, 0xe9, 0x8f, 0xb8, 0xca, 0x01, 0xca, 0xb7, 0x78, 0x17, 0x47, 0xd2, 0xdf, 0xc9,
    0x06, 0x01, 0x7c, 0xfe, 0xff, 0xca, 0x01, 0xca, 0x14, 0x24, 0xc5, 0xcd, 0x05, 0xca, 0xc1, 0xda, 0xef, 0xc9, 0x79,
    0xb7, 0xca, 0xf4, 0xc9, 0xc3, 0xbb, 0xc9, 0x0e, 0x01, 0xc3, 0xc0, 0xc9, 0xcd, 0x24, 0xca, 0xc2, 0xc0, 0xc9, 0x3a,
    0xe8, 0x8f, 0xbc, 0xc2, 0xd5, 0xc9, 0xc1, 0xd1, 0xe1, 0xc9, 0xcd, 0x14, 0xca, 0x4f, 0x3a, 0xea, 0x8f, 0xb9, 0xc2,
    0x12, 0xca, 0xb7, 0xc9, 0x37, 0xc9, 0x1a, 0xa0, 0xca, 0x1b, 0xca, 0x3e, 0x01, 0x17, 0x4f, 0x7e, 0xa0, 0x79, 0xc8,
    0xf6, 0x01, 0xc9, 0x7e, 0xb7, 0xca, 0x2b, 0xca, 0x3c, 0xc0, 0x1a, 0xb7, 0xc8, 0x3c, 0xc9, 0x3a, 0xe2, 0x8f, 0x2f,
    0x5f, 0x2a, 0xe0, 0x8f, 0xcd, 0x3f, 0xca, 0xcd, 0x89, 0xca, 0xc9, 0x01, 0x80, 0x01, 0x7c, 0xb7, 0xf2, 0x4b, 0xca,
    0x09, 0xc3, 0x42, 0xca, 0x7d, 0xe6, 0x07, 0x57, 0xb7, 0x7c, 0x1f, 0x67, 0x7d, 0x1f, 0x6f, 0xb7, 0x7c, 0x1f, 0x67,
    0x7d, 0x1f, 0x6f, 0xb7, 0x7c, 0x1f, 0x67, 0x7d, 0x1f, 0x6f, 0x01, 0xd0, 0xff, 0x09, 0x7c, 0xb7, 0xf2, 0x67, 0xca,
    0x7d, 0xc6, 0x30, 0x2f, 0x4a, 0x57, 0x3e, 0x07, 0x91, 0x4f, 0x3e, 0x01, 0xca, 0x81, 0xca, 0x17, 0x0d, 0xc2, 0x7c,
    0xca, 0x47, 0xeb, 0x7c, 0xd6, 0x40, 0x57, 0x5d, 0xc9, 0x78, 0x2f, 0x4f, 0xa6, 0x77, 0x1a, 0xa1, 0x12, 0x3a, 0xe4,
    0x8f, 0x1f, 0xd2, 0x9d, 0xca, 0xf5, 0x78, 0xb6, 0x77, 0xf1, 0x1f, 0xd2, 0xa4, 0xca, 0x1a, 0xb0, 0x12, 0xc9, 0x2a,
    0xec, 0x8f, 0xeb, 0x2a, 0xe8, 0x8f, 0xcd, 0x94, 0xcb, 0x19, 0xcd, 0x9c, 0xcb, 0x22, 0xf0, 0x8f, 0xeb, 0x22, 0xf4,
    0x8f, 0x2a, 0xee, 0x8f, 0xeb, 0x2a, 0xea, 0x8f, 0xcd, 0x94, 0xcb, 0x19, 0xcd, 0x9c, 0xcb, 0x22, 0xf2, 0x8f, 0xeb,
    0x22, 0xf6, 0x8f, 0x2a, 0xf0, 0x8f, 0x7b, 0x95, 0x7a, 0x9c, 0xd2, 0x36, 0xcb, 0x3a, 0xf5, 0x8f, 0xb7, 0xc4, 0xae,
    0xcb, 0x2a, 0xea, 0x8f, 0x22, 0xfe, 0x8f, 0x21, 0x00, 0x00, 0x22, 0xfa, 0x8f, 0x2a, 0xe8, 0x8f, 0x22, 0xfc, 0x8f,
    0x22, 0xe0, 0x8f, 0x3a, 0xfe, 0x8f, 0x32, 0xe2, 0x8f, 0xcd, 0x30, 0xca, 0x2a, 0xfa, 0x8f, 0xeb, 0x2a, 0xf2, 0x8f,
    0x19, 0x22, 0xfa, 0x8f, 0xeb, 0x2a, 0xf0, 0x8f, 0x7b, 0x95, 0x7a, 0x9c, 0xda, 0x26, 0xcb, 0xcd, 0x94, 0xcb, 0x19,
    0x22, 0xfa, 0x8f, 0x2a, 0xfe, 0x8f, 0xeb, 0x2a, 0xf6, 0x8f, 0x19, 0x22, 0xfe, 0x8f, 0x2a, 0xfc, 0x8f, 0xeb, 0x2a,
    0xec, 0x8f, 0xcd, 0xa8, 0xcb, 0xc8, 0xeb, 0x23, 0xc3, 0xef, 0xca, 0x3a, 0xf7, 0x8f, 0xb7, 0xc4, 0xae, 0xcb, 0x2a,
    0xe8, 0x8f, 0x22, 0xfc, 0x8f, 0x26, 0x00, 0x6c, 0x22, 0xf8, 0x8f, 0x2a, 0xea, 0x8f, 0x22, 0xfe, 0x8f, 0x7d, 0x32,
    0xe2, 0x8f, 0x2a, 0xfc, 0x8f, 0x22, 0xe0, 0x8f, 0xcd, 0x30, 0xca, 0x2a, 0xf8, 0x8f, 0xeb, 0x2a, 0xf0, 0x8f, 0x19,
    0x22, 0xf8, 0x8f, 0xeb, 0x2a, 0xf2, 0x8f, 0x7b, 0x95, 0x7a, 0x9c, 0xda, 0x84, 0xcb, 0xcd, 0x94, 0xcb, 0x19, 0x22,
    0xf8, 0x8f, 0x2a, 0xfc, 0x8f, 0xeb, 0x2a, 0xf4, 0x8f, 0x19, 0x22, 0xfc, 0x8f, 0x2a, 0xfe, 0x8f, 0xeb, 0x2a, 0xee,
    0x8f, 0xcd, 0xa8, 0xcb, 0xc8, 0xeb, 0x23, 0xc3, 0x4c, 0xcb, 0x7c, 0x2f, 0x67, 0x7d, 0x2f, 0x6f, 0x23, 0xc9, 0x7c,
    0xb7, 0x11, 0x01, 0x00, 0xf0, 0xcd, 0x94, 0xcb, 0x1b, 0x1b, 0xc9, 0x7b, 0xbd, 0xc0, 0x7a, 0xbc, 0xc9, 0x2a, 0xe8,
    0x8f, 0xeb, 0x2a, 0xec, 0x8f, 0x22, 0xe8, 0x8f, 0xeb, 0x22, 0xec, 0x8f, 0x2a, 0xea, 0x8f, 0xeb, 0x2a, 0xee, 0x8f,
    0x22, 0xea, 0x8f, 0xeb, 0x22, 0xee, 0x8f, 0x2a, 0xf4, 0x8f, 0xcd, 0x94, 0xcb, 0x22, 0xf4, 0x8f, 0x2a, 0xf6, 0x8f,
    0xcd, 0x94, 0xcb, 0x22, 0xf6, 0x8f, 0xc9, 0xe5, 0xd5, 0xc5, 0x2a, 0xe0, 0x8f, 0x22, 0xee, 0x8f, 0x2a, 0xe2, 0x8f,
    0x22, 0xf0, 0x8f, 0x21, 0x00, 0x00, 0x22, 0xea, 0x8f, 0x2a, 0xe6, 0x8f, 0x22, 0xec, 0x8f, 0xcd, 0x94, 0xcb, 0x29,
    0x01, 0x03, 0x00, 0x09, 0x22, 0xe8, 0x8f, 0x2a, 0xec, 0x8f, 0xeb, 0x2a, 0xea, 0x8f, 0xcd, 0xe2, 0xcc, 0xd2, 0x56,
    0xcc, 0xcd, 0x5d, 0xcc, 0x2a, 0xe8, 0x8f, 0x7c, 0xb7, 0xfa, 0x3e, 0xcc, 0x2a, 0xec, 0x8f, 0xcd, 0x94, 0xcb, 0xeb,
    0x2a, 0xea, 0x8f, 0x19, 0x29, 0x29, 0x01, 0x0a, 0x00, 0x09, 0xeb, 0x2a, 0xe8, 0x8f, 0x19, 0x22, 0xe8, 0x8f, 0x2a,
    0xec, 0x8f, 0x2b, 0x22, 0xec, 0x8f, 0xc3, 0x4c, 0xcc, 0xeb, 0x2a, 0xea, 0x8f, 0x29, 0x29, 0x19, 0x11, 0x06, 0x00,
    0x19, 0x22, 0xe8, 0x8f, 0x2a, 0xea, 0x8f, 0x23, 0x22, 0xea, 0x8f, 0xc3, 0x03, 0xcc, 0xcc, 0x5d, 0xcc, 0xc1, 0xd1,
    0xe1, 0xc9, 0x2a, 0xee, 0x8f, 0xeb, 0x2a, 0xf0, 0x8f, 0x4d, 0x44, 0x2a, 0xea, 0x8f, 0xe5, 0x19, 0x22, 0xe0, 0x8f,
    0x2a, 0xec, 0x8f, 0xe5, 0x09, 0x22, 0xe2, 0x8f, 0xcd, 0xfb, 0xcc, 0xe1, 0x19, 0x22, 0xe0, 0x8f, 0xe1, 0x09, 0x22,
    0xe2, 0x8f, 0xcd, 0xfb, 0xcc, 0x2a, 0xea, 0x8f, 0xcd, 0x94, 0xcb, 0xe5, 0x09, 0x22, 0xe2, 0x8f, 0xcd, 0xfb, 0xcc,
    0x2a, 0xea, 0x8f, 0x19, 0x22, 0xe0, 0x8f, 0x2a, 0xec, 0x8f, 0xcd, 0x94, 0xcb, 0x09, 0x22, 0xe2, 0x8f, 0xcd, 0xfb,
    0xcc, 0xe1, 0xe5, 0x19, 0x22, 0xe0, 0x8f, 0xcd, 0xfb, 0xcc, 0x2a, 0xec, 0x8f, 0xcd, 0x94, 0xcb, 0x19, 0x22, 0xe0,
    0x8f, 0xe1, 0x09, 0x22, 0xe2, 0x8f, 0xcd, 0xfb, 0xcc, 0x2a, 0xea, 0x8f, 0x09, 0x22, 0xe2, 0x8f, 0xcd, 0xfb, 0xcc,
    0x2a, 0xea, 0x8f, 0xcd, 0x94, 0xcb, 0x19, 0x22, 0xe0, 0x8f, 0x2a, 0xec, 0x8f, 0x09, 0x22, 0xe2, 0x8f, 0xcd, 0xfb,
    0xcc, 0xc9, 0x7c, 0xb7, 0xf2, 0xee, 0xcc, 0x7a, 0xb7, 0xfa, 0xf5, 0xcc, 0x37, 0xc9, 0x7a, 0xb7, 0xf2, 0xf5, 0xcc,
    0xaf, 0xc9, 0x7c, 0x92, 0xc0, 0x7d, 0x93, 0xc9, 0xc5, 0xd5, 0xe5, 0xcd, 0x30, 0xca, 0xe1, 0xd1, 0xc1, 0xc9, 0x3a,
    0x04, 0x02, 0xe6, 0x0f, 0x32, 0xc0, 0x8f, 0x2f, 0xd3, 0x90, 0xc9, 0x3a, 0x06, 0x02, 0xe6, 0x0f, 0x32, 0xc1, 0x8f,
    0x2f, 0xd3, 0x91, 0xc9, 0x3a, 0x08, 0x02, 0xe6, 0x0f, 0x32, 0xc2, 0x8f, 0x2f, 0xd3, 0x92, 0xc9, 0x3a, 0x0a, 0x02,
    0xe6, 0x0f, 0x32, 0xc3, 0x8f, 0x2f, 0xd3, 0x93, 0xc9, 0x3a, 0xc0, 0x8f, 0x32, 0xe0, 0x8f, 0xc9, 0x3a, 0xc1, 0x8f,
    0x32, 0xe0, 0x8f, 0xc9, 0x3a, 0xc2, 0x8f, 0x32, 0xe0, 0x8f, 0xc9, 0x3a, 0xc3, 0x8f, 0x32, 0xe0, 0x8f, 0xc9};

// Внутреняя функция. Вызывается функцией VideoPrintChar.
// Вывод символа на экран в режиме 64 символа в строке.

void VideoDrawChar64(...) {
    // Запоминаем, было ли подключено ПЗУ
    vTempVideoRom = (a ^= a);
    vTempVideoRom = a = vTempVideoRom;

    // Подключаем ОЗУ
    out(PORT_ROM_0000, a = PORT_ROM_0000__RAM);

    a = e;  // Непонятно
    swap(de, hl);
    l = a;  // Непонятно

    // Вычисление адреса текстового столбца в видеопамяти
    a = vTempVideoCursorX;
    CyclicRotateRight(a, 2);
    a &= 0x1F;
    h = a;
    (a += h) += h;
    Invert(a);
    h = a;

    // Вызов одной из функций наложения символа на изображение в видеопамяти
    a = vTempVideoCursorX;
    CyclicRotateRight(a);
    if (flag_nc) {
        CyclicRotateRight(a);
        if (flag_c) return VideoDrawChar64X2();  // С битовым сдвигом >> 2
        return VideoDrawChar64X0();              // С битовым сдвигом << 2
    }
    CyclicRotateRight(a);
    if (flag_c) return VideoDrawChar64X3();  // Без сдвига
    return VideoDrawChar64X1();              // С битовым сдвигом >> 4
}

// Вывод символа на экран в режиме 64 символа в строке
// Функция для символов в координатах (X % 4) == 0
// Вызывается функцией VideoDrawChar64

extern uint8_t cZeroZero[];

void VideoDrawChar64X0(...) {
    VideoDrawChar64X0L(c = 8);
    if (flag_z((a = vTempVideoFontHeight10) |= a)) {
        de = &cZeroZero;
    }
    VideoDrawChar64X0L(c = 2);
    return VideoDrawChar64End();
}

// Вызывается функцией VideoDrawChar64X0

void VideoDrawChar64X0L(...) {
    do {
        b = CarryRotateLeft(a = *de, 2);
        b = (((a = vTempVideoInverse) ^= b) &= 0xFC);
        *hl = (((a = *hl) &= 3) |= b);
        de++;
        hl--;
    } while (flag_nz(c--));
}

// Вывод символа на экран в режиме 64 символа в строке
// Функция для символов в координатах (X % 4) == 1
// Вызывается функцией VideoDrawChar64

void VideoDrawChar64X1(...) {
    VideoDrawChar64X1L(a = 8);
    if (flag_z((a = vTempVideoFontHeight10) |= a)) {
        de = &cZeroZero;
    }
    VideoDrawChar64X1L(a = 2);
    return VideoDrawChar64End();
}

// Вызывается функцией VideoDrawChar64X1

void VideoDrawChar64X1L(...) {
    do {
        push_pop(a) {
            c = a = vTempVideoInverse;
            c = (CyclicRotateRight(a = *de, 4) ^= c);
            b = (a &= 3);
            c = ((a = c) &= 0xF0);
            *hl = (((a = *hl) &= 0xFC) |= b);
            h--;
            *hl = (((a = *hl) &= 0x0F) |= c);
            h++;
            de++;
            hl--;
        }
    } while (flag_nz(a--));
}

// Вывод символа на экран в режиме 64 символа в строке
// Функция для символов в координатах (X % 4) == 2
// Вызывается функцией VideoDrawChar64

void VideoDrawChar64X2(...) {
    h--;
    VideoDrawChar64X2L(a = 8);
    if (flag_z((a = vTempVideoFontHeight10) |= a)) {
        de = &cZeroZero;
    }
    VideoDrawChar64X2L(a = 2);
    return VideoDrawChar64End();
}

// Вызывается функцией VideoDrawChar64X2

void VideoDrawChar64X2L(...) {
    do {
        push_pop(a) {
            c = a = vTempVideoInverse;
            c = (CyclicRotateRight(a = *de, 2) ^= c);
            b = (a &= 0xF);
            c = ((a = c) &= 0xC0);
            *hl = (((a = *hl) &= 0xF0) |= b);
            h--;
            *hl = (((a = *hl) &= 0x3F) |= c);
            h++;
            de++;
            hl--;
        }
    } while (flag_nz(a--));
}

// Вывод символа на экран в режиме 64 символа в строке
// Функция для символов в координатах (X % 4) == 3
// Вызывается функцией VideoDrawChar64

void VideoDrawChar64X3(...) {
    h--;
    h--;
    VideoDrawChar64X3L(c = 8);
    if (flag_z((a = vTempVideoFontHeight10) |= a)) {
        de = &cZeroZero;
    }
    VideoDrawChar64X3L(c = 2);
    return VideoDrawChar64End();
}

// Вызывается функцией VideoDrawChar64X3

void VideoDrawChar64X3L(...) {
    do {
        b = a = *de;
        b = (((a = vTempVideoInverse) ^= b) &= 0x3F);
        *hl = (((a = *hl) &= 0xC0) |= b);
        de++;
        hl--;
    } while (flag_nz(c--));
}

// Завершение вывода символа на экран в режиме 64 символа в строке
// Вызывается функциями VideoDrawChar64X0, 1, 2, 3

void VideoDrawChar64End(...) {
    if (flag_z((a = vTempVideoRom) |= a)) return VideoDrawCharEnd();
    out(PORT_ROM_0000, a ^= a);  // Подключаем ПЗУ, тут a == PORT_ROM_0000__ROM
    return VideoDrawCharEnd();
}

// Используется для рисования межстрочного интервала.
uint8_t cZeroZero[2];

asm(" org 0xCFF0");  // TODO: Заменить на массив

// Функция копирования из ПЗУ1 0C000h - 0CFFFh в ОЗУ
// Вход: bc - откуда, de - конечный адрес откуда, hl - куда

void CopyRom(...) {
    for (;;) {
        if ((a = c) == e) {
            if ((a = b) == d) return;
        }
        *hl = a = *bc;
        bc++;
        hl++;
    }
}

uint8_t vCFFF = 0xFF;

//----------------------------------------------------------------------------------------------------------------------
// Эта часть кода доступна на чтение по адресам 0D000h - 0FFFFh кодом из ПЗУ 0D000h - 0FFFFh
//----------------------------------------------------------------------------------------------------------------------

asm(" org 0xD000");

void BasicEntry() __address(0xD000);

uint8_t BasicData[] = {
    0xc3, 0xc4, 0xea, 0xc3, 0x03, 0xeb, 0xbe, 0x23, 0xe3, 0xc3, 0x0d, 0x00, 0x4e, 0x23, 0x46, 0x23, 0xc5, 0xc3, 0x74,
    0x02, 0x3c, 0xe3, 0xfa, 0xe3, 0x50, 0xe3, 0x9a, 0xe7, 0x8b, 0xdd, 0x86, 0xe0, 0xb9, 0xdd, 0xbc, 0xe5, 0x92, 0xe6,
    0xee, 0xe1, 0x01, 0xe6, 0xc4, 0xe6, 0xca, 0xe6, 0x27, 0xe7, 0x3c, 0xe7, 0x88, 0xe7, 0xf8, 0xdf, 0x30, 0xde, 0xbe,
    0xe0, 0x07, 0xe0, 0x15, 0xe0, 0x25, 0xe0, 0x55, 0xe0, 0x5f, 0xe0, 0x8a, 0xe9, 0x79, 0xb4, 0xe4, 0x79, 0xed, 0xe0,
    0x7b, 0x2a, 0xe2, 0x7b, 0x8a, 0xe2, 0x7f, 0xc5, 0xe5, 0x50, 0x89, 0xdb, 0x46, 0x88, 0xdb, 0xf3, 0xe7, 0xfd, 0xd7,
    0x44, 0xd4, 0xa1, 0xd7, 0x55, 0xd9, 0x27, 0xdc, 0x7f, 0xd9, 0xcc, 0xe7, 0xc9, 0xd7, 0xfc, 0xd4, 0x88, 0xd8, 0xcc,
    0xd6, 0xb9, 0xd7, 0xe5, 0xd7, 0x23, 0xda, 0xe0, 0xd6, 0x92, 0xe0, 0x69, 0xd8, 0x2f, 0xe8, 0x6e, 0xe8, 0x90, 0xe7,
    0xa9, 0xd8, 0xc1, 0xdd, 0x08, 0xd7, 0xfb, 0xd7, 0x78, 0xd7, 0xd0, 0xe9, 0xba, 0xe9, 0x35, 0xea, 0x8f, 0xea, 0x4a,
    0xd2, 0x98, 0xf7, 0x93, 0xf7, 0x2a, 0xd6, 0x69, 0xd6, 0x6c, 0xd6, 0xd5, 0xe8, 0xad, 0xe8, 0x73, 0xea, 0x56, 0xea,
    0xff, 0xe8, 0x34, 0xe8, 0x36, 0xe9, 0xf3, 0xe7, 0xc5, 0xc4, 0xd6, 0xc4, 0xe3, 0xc4, 0xf8, 0xc4, 0x04, 0xc5, 0x12,
    0xc5, 0x1b, 0xc5, 0x29, 0xc5, 0x3d, 0xc5, 0x4b, 0xc5, 0x59, 0xc5, 0x6a, 0xc5, 0x79, 0xc5, 0x87, 0xc5, 0x9b, 0xc5,
    0xab, 0xc5, 0xbf, 0xc5, 0xce, 0xc5, 0x20, 0x69, 0x6e, 0x20, 0x00, 0x0d, 0x4f, 0x4b, 0x0d, 0x00, 0x0d, 0x42, 0x72,
    0x65, 0x61, 0x6b, 0x07, 0x00, 0x21, 0x04, 0x00, 0x39, 0x7e, 0x23, 0xfe, 0x81, 0xc0, 0x4e, 0x23, 0x46, 0x23, 0xe5,
    0x69, 0x60, 0x7a, 0xb3, 0xeb, 0xca, 0x01, 0xd1, 0xeb, 0xe7, 0x01, 0x0d, 0x00, 0xe1, 0xc8, 0x09, 0xc3, 0xed, 0xd0,
    0xcd, 0x2a, 0xd1, 0xc5, 0xe3, 0xc1, 0xe7, 0x7e, 0x02, 0xc8, 0x0b, 0x2b, 0xc3, 0x10, 0xd1, 0xe3, 0x4e, 0x23, 0xe3,
    0xe5, 0x2a, 0x3a, 0x02, 0x06, 0x00, 0x09, 0x09, 0xcd, 0x2a, 0xd1, 0xe1, 0xc9, 0xd5, 0xeb, 0x21, 0xda, 0xff, 0x39,
    0xe7, 0xeb, 0xd1, 0xd0, 0x1e, 0x0c, 0xc3, 0x47, 0xd1, 0x2a, 0x28, 0x02, 0x22, 0x30, 0x02, 0x1e, 0x02, 0x01, 0x1e,
    0x14, 0x01, 0x1e, 0x00, 0xcd, 0x6f, 0xd2, 0xaf, 0x32, 0x0e, 0x02, 0xcd, 0xf3, 0xd8, 0x21, 0xb3, 0xd0, 0x57, 0x3e,
    0x07, 0xdf, 0x19, 0x7e, 0x23, 0x66, 0x6f, 0xf5, 0xd5, 0x11, 0xc8, 0x01, 0xd3, 0xfa, 0x7e, 0x12, 0x23, 0x13, 0xb7,
    0xc2, 0x64, 0xd1, 0xd3, 0xba, 0xd1, 0xf1, 0x21, 0xc8, 0x01, 0xcd, 0xa4, 0xde, 0x2a, 0x30, 0x02, 0x7c, 0xa5, 0x3c,
    0xc4, 0xc5, 0xe4, 0xaf, 0x32, 0x0e, 0x02, 0x21, 0xff, 0xff, 0x22, 0x30, 0x02, 0x21, 0xdc, 0xd0, 0xcd, 0xa4, 0xde,
    0xcd, 0xd4, 0xd3, 0xd7, 0x3c, 0x3d, 0xca, 0x8f, 0xd1, 0xf5, 0xcd, 0x44, 0xd7, 0xd5, 0x2b, 0x2b, 0x7e, 0x23, 0xfe,
    0x20, 0xca, 0x9d, 0xd1, 0x23, 0xcd, 0xa0, 0xd2, 0x47, 0xd1, 0xf1, 0xd2, 0x75, 0xd5, 0xd5, 0xc5, 0xd7, 0xf5, 0xcd,
    0x32, 0xd2, 0xc5, 0xd2, 0xcd, 0xd1, 0xeb, 0x2a, 0x36, 0x02, 0x1a, 0x02, 0x03, 0x13, 0xe7, 0xd2, 0xbf, 0xd1, 0x60,
    0x69, 0x23, 0x22, 0x36, 0x02, 0xd1, 0xf1, 0xca, 0xf9, 0xd1, 0x2a, 0x36, 0x02, 0xe3, 0xc1, 0x09, 0xe5, 0xcd, 0x0a,
    0xd1, 0xe1, 0x22, 0x36, 0x02, 0xeb, 0x74, 0x23, 0x23, 0xd1, 0x73, 0x23, 0x72, 0x23, 0x11, 0x01, 0x01, 0x1a, 0x77,
    0x23, 0x13, 0xfe, 0xf0, 0xca, 0x27, 0xd2, 0xb7, 0xc2, 0xec, 0xd1, 0xcd, 0x56, 0xd2, 0x23, 0x54, 0x5d, 0x7e, 0x23,
    0xb6, 0xca, 0x8f, 0xd1, 0x23, 0x23, 0x23, 0xaf, 0xbe, 0xf5, 0x7e, 0xfe, 0xf0, 0xca, 0x1f, 0xd2, 0xaf, 0xf1, 0x23,
    0xc2, 0x09, 0xd2, 0xeb, 0x73, 0x23, 0x72, 0xeb, 0xc3, 0xfd, 0xd1, 0xf1, 0xaf, 0x23, 0x23, 0x23, 0xc3, 0x09, 0xd2,
    0x1a, 0x77, 0x13, 0x23, 0x1a, 0x77, 0x23, 0x13, 0xc3, 0xec, 0xd1, 0x2a, 0x72, 0x02, 0x44, 0x4d, 0x7e, 0x23, 0xb6,
    0x2b, 0xc8, 0xc5, 0xf7, 0xf7, 0xe1, 0xe7, 0xe1, 0xc1, 0x3f, 0xc8, 0x3f, 0xd0, 0xc3, 0x35, 0xd2, 0xc0, 0x2a, 0x72,
    0x02, 0xaf, 0x77, 0x23, 0x77, 0x23, 0x22, 0x36, 0x02, 0x2a, 0x72, 0x02, 0x2b, 0x22, 0x2c, 0x02, 0x2a, 0x6e, 0x02,
    0x22, 0x24, 0x02, 0xcd, 0xcc, 0xd6, 0x2a, 0x36, 0x02, 0x22, 0x38, 0x02, 0x22, 0x3a, 0x02, 0xc1, 0x2a, 0x70, 0x02,
    0xf9, 0x21, 0x14, 0x02, 0x22, 0x12, 0x02, 0x21, 0x00, 0x00, 0xe5, 0x22, 0x34, 0x02, 0x2a, 0x2c, 0x02, 0xaf, 0x32,
    0x2a, 0x02, 0xc5, 0xc9, 0x3a, 0x58, 0x02, 0xfe, 0x22, 0x3e, 0x00, 0x32, 0x58, 0x02, 0xca, 0xd4, 0xd3, 0x3e, 0x3f,
    0xdf, 0x3e, 0x20, 0xdf, 0xc3, 0xd4, 0xd3, 0xaf, 0x32, 0x11, 0x02, 0x0e, 0x05, 0x11, 0x01, 0x01, 0x7e, 0xfe, 0x20,
    0xca, 0x08, 0xd3, 0x47, 0xfe, 0x22, 0xca, 0x5b, 0xd3, 0xb7, 0xca, 0xc1, 0xd3, 0x3a, 0x11, 0x02, 0xb7, 0x47, 0x7e,
    0xc2, 0x08, 0xd3, 0xfe, 0x3f, 0x3e, 0x95, 0xca, 0x08, 0xd3, 0x7e, 0xfe, 0x30, 0xda, 0xd4, 0xd2, 0xfe, 0x3c, 0xda,
    0x08, 0xd3, 0xd5, 0x11, 0xe0, 0xc5, 0xe5, 0x3e, 0xd7, 0x13, 0xd3, 0xfa, 0x1a, 0xd3, 0xba, 0xe6, 0x7f, 0xca, 0x05,
    0xd3, 0xbe, 0xca, 0xf7, 0xd2, 0xee, 0x20, 0xbe, 0xca, 0xf5, 0xd2, 0xee, 0x20, 0xc3, 0x72, 0xd3, 0xee, 0x20, 0xd3,
    0xfa, 0x1a, 0xd3, 0xba, 0xb7, 0xf2, 0xda, 0xd2, 0xf1, 0x78, 0xf6, 0x80, 0xf2, 0xe1, 0x7e, 0xd1, 0xf5, 0x3a, 0x11,
    0x02, 0xfe, 0x5e, 0xc2, 0x15, 0xd3, 0xf1, 0xc3, 0x22, 0xd3, 0xf1, 0xfe, 0x61, 0xda, 0x22, 0xd3, 0xfe, 0x7b, 0xd2,
    0x22, 0xd3, 0xe6, 0xdf, 0x23, 0x12, 0x13, 0x0c, 0xfe, 0x88, 0xca, 0x9b, 0xd3, 0xfe, 0xb0, 0xca, 0x83, 0xd3, 0xfe,
    0x8c, 0xca, 0x9b, 0xd3, 0xfe, 0x82, 0xca, 0x62, 0xd3, 0xfe, 0x83, 0xca, 0x62, 0xd3, 0xd6, 0x3a, 0xca, 0x49, 0xd3,
    0xfe, 0x5e, 0xc2, 0x4c, 0xd3, 0x32, 0x11, 0x02, 0xd6, 0x47, 0xc2, 0xa9, 0xd2, 0x47, 0x7e, 0xb7, 0xca, 0xc1, 0xd3,
    0xb8, 0xca, 0x08, 0xd3, 0x23, 0x12, 0x0c, 0x13, 0xc3, 0x52, 0xd3, 0xf5, 0xe5, 0xd7, 0xe1, 0xda, 0x9a, 0xd3, 0x3e,
    0x20, 0x12, 0x13, 0x0c, 0xf1, 0xc3, 0x3f, 0xd3, 0xe1, 0xe5, 0x04, 0xeb, 0xd3, 0xfa, 0xb6, 0xd3, 0xba, 0x23, 0xf2,
    0x76, 0xd3, 0xeb, 0xc3, 0xdc, 0xd2, 0xf5, 0xe5, 0xd7, 0xe1, 0xda, 0x8e, 0xd3, 0xf1, 0xc3, 0x3f, 0xd3, 0xeb, 0x3e,
    0x20, 0x77, 0x23, 0x3e, 0x88, 0x77, 0x23, 0xeb, 0x0c, 0x0c, 0xf1, 0xc5, 0xd5, 0xcd, 0x44, 0xd7, 0xe3, 0x3e, 0xf0,
    0x77, 0x23, 0x73, 0x23, 0x72, 0x23, 0xeb, 0xe1, 0xc1, 0x2b, 0x0c, 0x0c, 0xd7, 0x0c, 0x7e, 0xfe, 0x2c, 0xca, 0xba,
    0xd3, 0xc3, 0xa9, 0xd2, 0x12, 0x13, 0x23, 0x0c, 0xc3, 0x9b, 0xd3, 0x21, 0x00, 0x01, 0x12, 0x13, 0x12, 0x13, 0x12,
    0xc9, 0x05, 0x2b, 0xdf, 0xc2, 0xd9, 0xd3, 0xdf, 0xcd, 0xf3, 0xd8, 0x21, 0x01, 0x01, 0x06, 0x01, 0xcd, 0x1b, 0xd4,
    0xfe, 0x08, 0xca, 0xca, 0xd3, 0xfe, 0x0d, 0xca, 0xee, 0xd8, 0xfe, 0x18, 0xca, 0xd0, 0xd3, 0x4f, 0x78, 0xfe, 0xfa,
    0x3e, 0x07, 0xd2, 0xf8, 0xd3, 0x79, 0x71, 0x23, 0x04, 0xdf, 0xc3, 0xd9, 0xd3, 0xc2, 0xd5, 0xde, 0xf1, 0xf5, 0xfe,
    0x20, 0xda, 0x14, 0xd4, 0x3a, 0x0d, 0x02, 0xfe, 0x40, 0xc2, 0x10, 0xd4, 0x3e, 0x00, 0x3c, 0x32, 0x0d, 0x02, 0xf1,
    0xf5, 0xcd, 0xf0, 0xc7, 0xf1, 0xc9, 0xcd, 0xf3, 0xc7, 0xfe, 0x1f, 0xc0, 0x3e, 0x7f, 0x32, 0x0d, 0xc8, 0x32, 0x16,
    0xc8, 0x3e, 0xc3, 0x32, 0xed, 0xc7, 0x21, 0x03, 0xd0, 0x22, 0xee, 0xc7, 0x3e, 0x80, 0xd3, 0xa8, 0x3e, 0x07, 0xcd,
    0xf0, 0xc7, 0x21, 0x3c, 0xf4, 0x22, 0x01, 0x00, 0xe9, 0xaf, 0x32, 0x6b, 0x02, 0x32, 0x09, 0xc8, 0xcd, 0x65, 0xd7,
    0xc0, 0xc1, 0xcd, 0x32, 0xd2, 0xc5, 0xe1, 0xf7, 0xc1, 0x78, 0xb1, 0xc2, 0x62, 0xd4, 0x3e, 0x1a, 0xdf, 0xc3, 0x7f,
    0xd1, 0xcd, 0xd6, 0xd6, 0xc5, 0xcd, 0xf3, 0xd8, 0xf7, 0xe3, 0xcd, 0xcd, 0xe4, 0x3e, 0x20, 0xe1, 0xfe, 0x04, 0xca,
    0x98, 0xd4, 0xdf, 0x7e, 0xb7, 0x23, 0xc2, 0xa1, 0xd4, 0x32, 0x6b, 0x02, 0xc3, 0x54, 0xd4, 0x3e, 0x20, 0xdf, 0xe5,
    0xd5, 0xc5, 0x5e, 0x23, 0x56, 0xeb, 0xcd, 0xcd, 0xe4, 0xc1, 0xd1, 0xe1, 0x23, 0x23, 0xc3, 0x77, 0xd4, 0x3e, 0x5e,
    0xdf, 0x3e, 0x44, 0xdf, 0xc3, 0x77, 0xd4, 0xfa, 0xb5, 0xd4, 0xfe, 0x22, 0xc2, 0x71, 0xd4, 0x3a, 0x6b, 0x02, 0x2f,
    0x32, 0x6b, 0x02, 0x3e, 0x22, 0xc3, 0x71, 0xd4, 0x3a, 0x6b, 0x02, 0xb7, 0x2b, 0x7e, 0x23, 0xc2, 0x71, 0xd4, 0xfe,
    0xf0, 0xca, 0x83, 0xd4, 0xd6, 0x7f, 0x4f, 0xe5, 0x11, 0xe1, 0xc5, 0xd5, 0xd3, 0xfa, 0x1a, 0xd3, 0xba, 0x13, 0xb7,
    0xf2, 0xcc, 0xd4, 0x0d, 0xe1, 0xc2, 0xcb, 0xd4, 0xd3, 0xfa, 0x7e, 0xd3, 0xba, 0xb7, 0xf2, 0xf7, 0xd4, 0xfe, 0xf0,
    0xca, 0x83, 0xd4, 0xe6, 0x7f, 0xc3, 0x70, 0xd4, 0xcd, 0xc5, 0xe4, 0x23, 0x23, 0x7e, 0xc3, 0x71, 0xd4, 0xdf, 0x23,
    0xc3, 0xdb, 0xd4, 0x3e, 0x64, 0x32, 0x2a, 0x02, 0xcd, 0x1d, 0xd8, 0xe3, 0xcd, 0xe9, 0xd0, 0xd1, 0xc2, 0x0e, 0xd5,
    0x09, 0xf9, 0xeb, 0xcd, 0x19, 0xd1, 0x08, 0xe5, 0xcd, 0xfb, 0xd7, 0xe3, 0xe5, 0x2a, 0x30, 0x02, 0xe3, 0xcd, 0x6f,
    0xda, 0xcf, 0xad, 0xcd, 0x6c, 0xda, 0xe5, 0xcd, 0x75, 0xe3, 0xe1, 0xc5, 0xd5, 0x01, 0x00, 0x81, 0x51, 0x5a, 0x7e,
    0xfe, 0xb2, 0x3e, 0x01, 0xc2, 0x43, 0xd5, 0xd7, 0xcd, 0x6c, 0xda, 0xe5, 0xcd, 0x75, 0xe3, 0xe1, 0xef, 0xc5, 0xd5,
    0xf5, 0x33, 0xe5, 0x2a, 0x2c, 0x02, 0xe3, 0x06, 0x81, 0xc5, 0x33, 0xcd, 0x94, 0xfb, 0xfe, 0xff, 0xc4, 0xdb, 0xd6,
    0x22, 0x2c, 0x02, 0x7e, 0xfe, 0x3a, 0xca, 0x75, 0xd5, 0xb7, 0xc2, 0x3f, 0xd1, 0x23, 0x7e, 0x23, 0xb6, 0x23, 0xca,
    0xe7, 0xd6, 0x5e, 0x23, 0x56, 0xeb, 0x22, 0x30, 0x02, 0xeb, 0xd7, 0x11, 0x50, 0xd5, 0xd5, 0xc8, 0xd6, 0x80, 0xda,
    0x1d, 0xd8, 0xfe, 0x2c, 0xd2, 0x3f, 0xd1, 0x07, 0x4f, 0x06, 0x00, 0xeb, 0x21, 0x5b, 0xd0, 0x09, 0x4e, 0x23, 0x46,
    0xc5, 0xeb, 0x23, 0x7e, 0xfe, 0x3a, 0xd0, 0xfe, 0x20, 0xca, 0x93, 0xd5, 0xfe, 0x30, 0x3f, 0x3c, 0x3d, 0xc9, 0x78,
    0xb1, 0xc2, 0xab, 0xd5, 0x01, 0x0a, 0x00, 0x2a, 0x72, 0x02, 0xe5, 0x23, 0x23, 0x5e, 0x23, 0x56, 0xeb, 0x22, 0x6c,
    0x02, 0xeb, 0xc3, 0xbc, 0xd5, 0xe1, 0xe5, 0x23, 0x23, 0x5e, 0x3a, 0x6c, 0x02, 0x77, 0x23, 0x56, 0x3a, 0x6d, 0x02,
    0x77, 0x23, 0x2a, 0x72, 0x02, 0x23, 0x23, 0x23, 0x23, 0x7e, 0xfe, 0xf0, 0xca, 0xef, 0xd5, 0xfe, 0xf1, 0xca, 0xe9,
    0xd5, 0xb7, 0xca, 0x5e, 0xd6, 0xca, 0x17, 0xd6, 0x23, 0xc3, 0xd3, 0xd5, 0x23, 0x23, 0x23, 0xc3, 0xd3, 0xd5, 0x23,
    0x7e, 0xbb, 0xca, 0xfa, 0xd5, 0x23, 0x23, 0xc3, 0xd3, 0xd5, 0x23, 0x7e, 0xba, 0xca, 0x04, 0xd6, 0x23, 0xc3, 0xd3,
    0xd5, 0x2b, 0x2b, 0x3e, 0xf1, 0x77, 0x23, 0x3a, 0x6c, 0x02, 0x77, 0x23, 0x3a, 0x6d, 0x02, 0x77, 0x23, 0xc3, 0xd3,
    0xd5, 0x2a, 0x6c, 0x02, 0x09, 0x22, 0x6c, 0x02, 0xe1, 0x5e, 0x23, 0x7e, 0xb7, 0xc8, 0x57, 0xeb, 0xe5, 0xc3, 0xbc,
    0xd5, 0xcd, 0x44, 0xd7, 0x42, 0x4b, 0xe5, 0xcd, 0xa3, 0xd5, 0x2a, 0x72, 0x02, 0x23, 0x23, 0x23, 0x23, 0x7e, 0xfe,
    0xf1, 0xca, 0x4c, 0xd6, 0xfe, 0xf0, 0xca, 0x37, 0xd6, 0xb7, 0xca, 0x52, 0xd6, 0xc3, 0x39, 0xd6, 0x3e, 0xf0, 0x77,
    0xc3, 0x37, 0xd6, 0x23, 0x23, 0x7e, 0xb7, 0xeb, 0xe1, 0xc8, 0xe5, 0xeb, 0xc3, 0x37, 0xd6, 0x23, 0x23, 0x7e, 0xb7,
    0xca, 0x17, 0xd6, 0x2b, 0xc3, 0xcf, 0xd5, 0xc3, 0x7f, 0xd1, 0xe5, 0x2a, 0x72, 0x02, 0x2b, 0x23, 0x5e, 0x23, 0x56,
    0x7a, 0xb3, 0xca, 0xb1, 0xd6, 0x23, 0x23, 0x23, 0x7e, 0xfe, 0xa2, 0xca, 0x8f, 0xd6, 0xfe, 0xf0, 0xca, 0xac, 0xd6,
    0xb7, 0xca, 0x71, 0xd6, 0xc3, 0x7c, 0xd6, 0xeb, 0x5e, 0x23, 0x56, 0x7a, 0xb3, 0xca, 0xb1, 0xd6, 0x23, 0x4e, 0x23,
    0x46, 0x23, 0xc5, 0xd5, 0xcd, 0xff, 0xff, 0xd1, 0xe1, 0xc1, 0xda, 0xbc, 0xd6, 0xc5, 0xc3, 0x8f, 0xd6, 0x23, 0x23,
    0xc3, 0x7c, 0xd6, 0xe1, 0xc9, 0x23, 0x7e, 0x2b, 0xb7, 0xc8, 0x23, 0xc3, 0xb3, 0xd6, 0x11, 0xd7, 0xd0, 0x1a, 0x13,
    0xdf, 0xb7, 0xc2, 0xbf, 0xd6, 0xcd, 0xcd, 0xe4, 0xc3, 0x69, 0xd6, 0xeb, 0x2a, 0x72, 0x02, 0x2b, 0x22, 0x3c, 0x02,
    0xeb, 0xc9, 0xcd, 0x94, 0xfb, 0x3c, 0xc8, 0xcd, 0x94, 0xfb, 0xfe, 0x03, 0xc0, 0xf6, 0xc0, 0x22, 0x2c, 0x02, 0xc1,
    0xf5, 0x2a, 0x30, 0x02, 0x7d, 0xa4, 0x3c, 0xca, 0xfa, 0xd6, 0x22, 0x32, 0x02, 0x2a, 0x2c, 0x02, 0x22, 0x34, 0x02,
    0xaf, 0x32, 0x0e, 0x02, 0xf1, 0x21, 0xe1, 0xd0, 0xc2, 0x73, 0xd1, 0xc3, 0x7f, 0xd1, 0xc0, 0x1e, 0x20, 0x2a, 0x34,
    0x02, 0x7c, 0xb5, 0xca, 0x47, 0xd1, 0xeb, 0x2a, 0x32, 0x02, 0x22, 0x30, 0x02, 0xeb, 0xc9, 0x7e, 0xfe, 0x41, 0xd8,
    0xfe, 0x5b, 0x3f, 0xc9, 0xd7, 0xcd, 0x6c, 0xda, 0xef, 0xfa, 0x3f, 0xd7, 0x3a, 0x41, 0x02, 0xfe, 0x91, 0xda, 0xcf,
    0xe3, 0x01, 0x80, 0x90, 0x11, 0x00, 0x00, 0xcd, 0xa4, 0xe3, 0x51, 0xc8, 0x1e, 0x08, 0xc3, 0x47, 0xd1, 0x2b, 0x11,
    0x00, 0x00, 0xd7, 0xd0, 0xe5, 0xf5, 0x21, 0x98, 0x19, 0xe7, 0xda, 0x3f, 0xd1, 0x62, 0x6b, 0x19, 0x29, 0x19, 0x29,
    0xf1, 0xd6, 0x30, 0x5f, 0x16, 0x00, 0x19, 0xeb, 0xe1, 0xc3, 0x48, 0xd7, 0x23, 0x5e, 0x23, 0x56, 0xc9, 0x7e, 0xfe,
    0xf0, 0xc2, 0x75, 0xd7, 0xcd, 0x65, 0xd7, 0x37, 0xc9, 0xfe, 0x00, 0xc9, 0xca, 0x5a, 0xd2, 0xcd, 0x25, 0xd7, 0x2b,
    0xd7, 0xc0, 0xe5, 0x2a, 0x6e, 0x02, 0x7d, 0x93, 0x5f, 0x7c, 0x9a, 0x57, 0xda, 0x3f, 0xd1, 0x2a, 0x36, 0x02, 0x01,
    0x28, 0x00, 0x09, 0xe7, 0xd2, 0x34, 0xd1, 0xeb, 0x22, 0x70, 0x02, 0xe1, 0xc3, 0x5a, 0xd2, 0xca, 0x56, 0xd2, 0xe5,
    0x21, 0x03, 0x01, 0x7e, 0x23, 0x6e, 0xb5, 0xe1, 0xca, 0x56, 0xd2, 0xcd, 0x5a, 0xd2, 0x01, 0x50, 0xd5, 0xc3, 0xc8,
    0xd7, 0xcd, 0x19, 0xd1, 0x03, 0xc1, 0xe5, 0xe5, 0x2a, 0x30, 0x02, 0xe3, 0x16, 0x8c, 0xd5, 0x33, 0xc5, 0xcd, 0x65,
    0xd7, 0xcd, 0xfd, 0xd7, 0xe5, 0x2a, 0x30, 0x02, 0xe7, 0xe1, 0x23, 0xdc, 0x35, 0xd2, 0xd4, 0x32, 0xd2, 0x60, 0x69,
    0x2b, 0xd8, 0x1e, 0x0e, 0xc3, 0x47, 0xd1, 0xc0, 0x16, 0xff, 0xcd, 0xe9, 0xd0, 0xf9, 0xfe, 0x8c, 0x1e, 0x04, 0xc2,
    0x47, 0xd1, 0xe1, 0x22, 0x30, 0x02, 0x21, 0x50, 0xd5, 0xe3, 0x01, 0x3a, 0x0e, 0x00, 0x06, 0x00, 0x79, 0x48, 0x47,
    0x7e, 0xfe, 0xf0, 0xca, 0x17, 0xd8, 0xb7, 0xc8, 0xb8, 0xc8, 0x23, 0xfe, 0x22, 0xca, 0x01, 0xd8, 0xc3, 0x04, 0xd8,
    0x23, 0x23, 0x23, 0xc3, 0x04, 0xd8, 0xcd, 0x2c, 0xdc, 0xcf, 0xbb, 0x3a, 0x10, 0x02, 0xf5, 0xd5, 0xcd, 0x7b, 0xda,
    0xe3, 0x22, 0x2c, 0x02, 0xd1, 0xf1, 0xd5, 0x1f, 0xcd, 0x71, 0xda, 0xca, 0x62, 0xd8, 0xe5, 0x2a, 0x3e, 0x02, 0xe5,
    0x23, 0x23, 0xf7, 0xd1, 0x2a, 0x70, 0x02, 0xe7, 0xd1, 0xd2, 0x52, 0xd8, 0x2a, 0x36, 0x02, 0xe7, 0x6b, 0x62, 0xdc,
    0x40, 0xde, 0x1a, 0xf5, 0xaf, 0x12, 0xcd, 0xd6, 0xdf, 0xf1, 0x77, 0xeb, 0xe1, 0xcd, 0x84, 0xe3, 0xe1, 0xc9, 0xe5,
    0xcd, 0x81, 0xe3, 0xd1, 0xe1, 0xc9, 0xcd, 0xaf, 0xe0, 0x7e, 0x47, 0xfe, 0x8c, 0xca, 0x76, 0xd8, 0xcf, 0x88, 0x2b,
    0x4b, 0x0d, 0x78, 0xca, 0x7b, 0xd5, 0x23, 0xcd, 0x65, 0xd7, 0x23, 0x7e, 0xfe, 0x2c, 0xc0, 0xc3, 0x77, 0xd8, 0xcd,
    0x7b, 0xda, 0x7e, 0xfe, 0x88, 0xca, 0x94, 0xd8, 0xcf, 0xb0, 0x2b, 0xef, 0xca, 0xfd, 0xd7, 0x23, 0x7e, 0xfe, 0x20,
    0xca, 0x98, 0xd8, 0xfe, 0x88, 0xca, 0xea, 0xd8, 0xc3, 0x7a, 0xd5, 0x2b, 0xd7, 0xca, 0xf3, 0xd8, 0xc8, 0xfe, 0xac,
    0xca, 0x12, 0xd9, 0xfe, 0xae, 0xca, 0x12, 0xd9, 0xe5, 0xfe, 0x2c, 0xca, 0xfe, 0xd8, 0xfe, 0x3b, 0xca, 0x32, 0xd9,
    0xc1, 0xcd, 0x7b, 0xda, 0x2b, 0xe5, 0x3a, 0x10, 0x02, 0xb7, 0xc2, 0xe3, 0xd8, 0xcd, 0xd8, 0xe4, 0xcd, 0x60, 0xde,
    0x2a, 0x3e, 0x02, 0x3a, 0x0d, 0x02, 0x86, 0xcd, 0xa7, 0xde, 0x3e, 0x20, 0xdf, 0xaf, 0xc4, 0xa7, 0xde, 0xe1, 0xc3,
    0xa8, 0xd8, 0x23, 0xc3, 0xc9, 0xd7, 0x36, 0x00, 0x21, 0x00, 0x01, 0x3e, 0x0d, 0xdf, 0x3a, 0x0c, 0x02, 0xaf, 0x32,
    0x0d, 0x02, 0xc9, 0x3a, 0x0d, 0x02, 0xfe, 0x40, 0xd4, 0xf3, 0xd8, 0xd2, 0x32, 0xd9, 0xd6, 0x10, 0xd2, 0x09, 0xd9,
    0x2f, 0xc3, 0x29, 0xd9, 0xf5, 0xcd, 0xae, 0xe0, 0xcf, 0x29, 0x2b, 0xf1, 0xfe, 0xae, 0xe5, 0x7b, 0xca, 0x2a, 0xd9,
    0x3a, 0x0d, 0x02, 0x2f, 0x83, 0xd2, 0x32, 0xd9, 0x3c, 0x47, 0x3e, 0x20, 0xdf, 0x05, 0xc2, 0x2d, 0xd9, 0xe1, 0xd7,
    0xc3, 0xac, 0xd8, 0x07, 0x3f, 0x20, 0x52, 0x65, 0x65, 0x6e, 0x74, 0x65, 0x72, 0x0d, 0x00, 0x3a, 0x2b, 0x02, 0xb7,
    0xc2, 0x39, 0xd1, 0xc1, 0x21, 0x37, 0xd9, 0xcd, 0xa4, 0xde, 0x2a, 0x2c, 0x02, 0xc9, 0xfe, 0x22, 0x32, 0x58, 0x02,
    0x3e, 0x00, 0x32, 0x0e, 0x02, 0xc2, 0x6c, 0xd9, 0xcd, 0x61, 0xde, 0xcf, 0x3b, 0xe5, 0xcd, 0xa7, 0xde, 0xe1, 0xe5,
    0xcd, 0x13, 0xde, 0xcd, 0x8a, 0xd2, 0x23, 0x7e, 0xb7, 0x2b, 0xc1, 0xca, 0xe6, 0xd6, 0xc5, 0xc3, 0x84, 0xd9, 0xe5,
    0x2a, 0x3c, 0x02, 0xf6, 0xaf, 0x32, 0x2b, 0x02, 0xe3, 0x01, 0xcf, 0x2c, 0xcd, 0x2c, 0xdc, 0xe3, 0xd5, 0x7e, 0xfe,
    0x2c, 0xca, 0xa4, 0xd9, 0x3a, 0x2b, 0x02, 0xb7, 0xc2, 0x01, 0xda, 0x3e, 0x3f, 0xdf, 0xcd, 0x8a, 0xd2, 0x3a, 0x10,
    0x02, 0xb7, 0xca, 0xc4, 0xd9, 0xd7, 0x57, 0x47, 0xfe, 0x22, 0xca, 0xb8, 0xd9, 0x16, 0x3a, 0x06, 0x2c, 0x2b, 0xcd,
    0x64, 0xde, 0xeb, 0x21, 0xcd, 0xd9, 0xe3, 0xd5, 0xc3, 0x38, 0xd8, 0xd7, 0xcd, 0x2e, 0xe4, 0xe3, 0xcd, 0x81, 0xe3,
    0xe1, 0x2b, 0xd7, 0xca, 0xd7, 0xd9, 0xfe, 0x2c, 0xc2, 0x43, 0xd9, 0xe3, 0x2b, 0xd7, 0xc2, 0x8a, 0xd9, 0xd1, 0x3a,
    0x2b, 0x02, 0xb7, 0xeb, 0xc2, 0xd1, 0xd6, 0xb6, 0x21, 0xf0, 0xd9, 0xd5, 0xc4, 0xa4, 0xde, 0xe1, 0xc9, 0x07, 0x20,
    0x45, 0x78, 0x74, 0x72, 0x61, 0x20, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x64, 0x0d, 0x00, 0xcd, 0xfb, 0xd7, 0xb7,
    0xc2, 0x1a, 0xda, 0x23, 0xf7, 0x79, 0xb0, 0x1e, 0x06, 0xca, 0x47, 0xd1, 0xc1, 0x5e, 0x23, 0x56, 0xeb, 0x22, 0x28,
    0x02, 0xeb, 0xd7, 0xfe, 0x98, 0xc2, 0x01, 0xda, 0xc3, 0xa4, 0xd9, 0x11, 0x00, 0x00, 0xc4, 0x2c, 0xdc, 0x22, 0x2c,
    0x02, 0xcd, 0xe9, 0xd0, 0xc2, 0x45, 0xd1, 0xf9, 0xd5, 0x7e, 0x23, 0xf5, 0xd5, 0xcd, 0x67, 0xe3, 0xe3, 0xe5, 0xcd,
    0xe3, 0xe0, 0xe1, 0xcd, 0x81, 0xe3, 0xe1, 0xcd, 0x78, 0xe3, 0xe5, 0xcd, 0xa4, 0xe3, 0xe1, 0xc1, 0x90, 0xcd, 0x78,
    0xe3, 0xca, 0x5e, 0xda, 0xeb, 0x22, 0x30, 0x02, 0x69, 0x60, 0xc3, 0x4c, 0xd5, 0xf9, 0x2a, 0x2c, 0x02, 0x7e, 0xfe,
    0x2c, 0xc2, 0x50, 0xd5, 0xd7, 0xcd, 0x26, 0xda, 0xcd, 0x7b, 0xda, 0xf6, 0x37, 0x3a, 0x10, 0x02, 0x8f, 0xe8, 0x1e,
    0x18, 0xc3, 0x47, 0xd1, 0x2b, 0x16, 0x00, 0xd5, 0xcd, 0x19, 0xd1, 0x01, 0xcd, 0xeb, 0xda, 0x22, 0x2e, 0x02, 0x2a,
    0x2e, 0x02, 0xc1, 0x78, 0xfe, 0x78, 0xd4, 0x6f, 0xda, 0x7e, 0x16, 0x00, 0xd6, 0xba, 0xda, 0xb0, 0xda, 0xfe, 0x03,
    0xd2, 0xb0, 0xda, 0xfe, 0x01, 0x17, 0xaa, 0xba, 0x57, 0xda, 0x3f, 0xd1, 0x22, 0x26, 0x02, 0xd7, 0xc3, 0x96, 0xda,
    0x7a, 0xb7, 0xc2, 0xb0, 0xdb, 0x7e, 0x22, 0x26, 0x02, 0xd6, 0xb3, 0xd8, 0xfe, 0x07, 0xd0, 0x5f, 0x3a, 0x10, 0x02,
    0x3d, 0xb3, 0x7b, 0xca, 0x88, 0xdf, 0x07, 0x83, 0x5f, 0x21, 0x46, 0xd0, 0x19, 0x78, 0x56, 0xba, 0xd0, 0x23, 0xcd,
    0x6f, 0xda, 0xc5, 0x01, 0x89, 0xda, 0xc5, 0x43, 0x4a, 0xcd, 0x5a, 0xe3, 0x58, 0x51, 0xf7, 0x2a, 0x26, 0x02, 0xc3,
    0x7e, 0xda, 0xaf, 0x32, 0x10, 0x02, 0xd7, 0xda, 0x2e, 0xe4, 0xcd, 0x1c, 0xd7, 0xd2, 0x35, 0xdb, 0xfe, 0xb3, 0xca,
    0xeb, 0xda, 0xfe, 0x2e, 0xca, 0x2e, 0xe4, 0xfe, 0xb4, 0xca, 0x24, 0xdb, 0xfe, 0x22, 0xca, 0x61, 0xde, 0xfe, 0xb1,
    0xca, 0x0b, 0xdc, 0xfe, 0xaf, 0xca, 0xde, 0xdd, 0xd6, 0xbd, 0xd2, 0x46, 0xdb, 0xcf, 0x28, 0xcd, 0x7b, 0xda, 0xcf,
    0x29, 0xc9, 0x16, 0x7d, 0xcd, 0x7e, 0xda, 0x2a, 0x2e, 0x02, 0xe5, 0xcd, 0x52, 0xe3, 0xcd, 0x6f, 0xda, 0xe1, 0xc9,
    0xcd, 0x2c, 0xdc, 0xe5, 0xeb, 0x22, 0x3e, 0x02, 0x3a, 0x10, 0x02, 0xb7, 0xcc, 0x67, 0xe3, 0xe1, 0xc9, 0x06, 0x00,
    0x07, 0x4f, 0xc5, 0xd7, 0x79, 0xfe, 0x30, 0xca, 0x70, 0xdb, 0xfe, 0x29, 0xda, 0x77, 0xdb, 0xcf, 0x28, 0xcd, 0x7b,
    0xda, 0xcf, 0x2c, 0xcd, 0x70, 0xda, 0xeb, 0x2a, 0x3e, 0x02, 0xe3, 0xe5, 0xeb, 0xcd, 0xaf, 0xe0, 0xeb, 0xe3, 0xc3,
    0x7f, 0xdb, 0xc1, 0x01, 0x30, 0xdb, 0xc3, 0x8a, 0xe9, 0xcd, 0x1c, 0xdb, 0xe3, 0x11, 0x30, 0xdb, 0xd5, 0x01, 0x14,
    0xd0, 0x09, 0x4e, 0x23, 0x66, 0x69, 0xe9, 0xf6, 0xaf, 0xf5, 0xcd, 0x6f, 0xda, 0xcd, 0x2c, 0xd7, 0xf1, 0xeb, 0xc1,
    0xe3, 0xeb, 0xcd, 0x6a, 0xe3, 0xf5, 0xcd, 0x2c, 0xd7, 0xf1, 0xc1, 0x79, 0x21, 0xac, 0xdd, 0xc2, 0xab, 0xdb, 0xa3,
    0x4f, 0x78, 0xa2, 0xe9, 0xb3, 0x4f, 0x78, 0xb2, 0xe9, 0x21, 0xc2, 0xdb, 0x3a, 0x10, 0x02, 0x1f, 0x7a, 0x17, 0x5f,
    0x16, 0x64, 0x78, 0xba, 0xd0, 0xc3, 0xd8, 0xda, 0xc4, 0xdb, 0x79, 0xb7, 0x1f, 0xc1, 0xd1, 0xf5, 0xcd, 0x71, 0xda,
    0x21, 0x01, 0xdc, 0xe5, 0xca, 0xa4, 0xe3, 0xaf, 0x32, 0x10, 0x02, 0xd5, 0xcd, 0xd2, 0xdf, 0xd1, 0xf7, 0xf7, 0xcd,
    0xd6, 0xdf, 0xcd, 0x78, 0xe3, 0xe1, 0xe3, 0x55, 0xe1, 0x7b, 0xb2, 0xc8, 0x7a, 0xb7, 0x2f, 0xc8, 0xaf, 0xbb, 0x3c,
    0xd0, 0x15, 0x1d, 0x0a, 0xbe, 0x23, 0x03, 0xca, 0xe9, 0xdb, 0x3f, 0xc3, 0x38, 0xe3, 0x3c, 0x8f, 0xc1, 0xa0, 0xc6,
    0xff, 0x9f, 0xc3, 0x3d, 0xe3, 0x16, 0x5a, 0xcd, 0x7e, 0xda, 0xcd, 0x6f, 0xda, 0xcd, 0x2c, 0xd7, 0x7b, 0x2f, 0x4f,
    0x7a, 0x2f, 0xcd, 0xac, 0xdd, 0xc1, 0xc3, 0x89, 0xda, 0x2b, 0xd7, 0xc8, 0xcf, 0x2c, 0x01, 0x22, 0xdc, 0xc5, 0xf6,
    0xaf, 0x32, 0x0f, 0x02, 0x46, 0xcd, 0x1c, 0xd7, 0xda, 0x3f, 0xd1, 0xaf, 0x4f, 0x32, 0x10, 0x02, 0xd7, 0xda, 0x46,
    0xdc, 0xcd, 0x1c, 0xd7, 0xda, 0x51, 0xdc, 0x4f, 0xd7, 0xda, 0x47, 0xdc, 0xcd, 0x1c, 0xd7, 0xd2, 0x47, 0xdc, 0xd6,
    0x24, 0xc2, 0x5e, 0xdc, 0x3c, 0x32, 0x10, 0x02, 0x0f, 0x81, 0x4f, 0xd7, 0x3a, 0x2a, 0x02, 0x86, 0xfe, 0x28, 0xca,
    0xb0, 0xdc, 0xaf, 0x32, 0x2a, 0x02, 0xe5, 0x2a, 0x38, 0x02, 0xeb, 0x2a, 0x36, 0x02, 0xe7, 0xca, 0x8a, 0xdc, 0x79,
    0x96, 0x23, 0xc2, 0x7f, 0xdc, 0x78, 0x96, 0x23, 0xca, 0xad, 0xdc, 0x23, 0x23, 0x23, 0x23, 0xc3, 0x73, 0xdc, 0xc5,
    0x01, 0x06, 0x00, 0x2a, 0x3a, 0x02, 0xe5, 0x09, 0xc1, 0xe5, 0xcd, 0x0a, 0xd1, 0xe1, 0x22, 0x3a, 0x02, 0x60, 0x69,
    0x22, 0x38, 0x02, 0x2b, 0x36, 0x00, 0xe7, 0xc2, 0xa1, 0xdc, 0xd1, 0x73, 0x23, 0x72, 0x23, 0xeb, 0xe1, 0xc9, 0xe5,
    0x2a, 0x0f, 0x02, 0xe3, 0x16, 0x00, 0xd5, 0xc5, 0xcd, 0x24, 0xd7, 0xc1, 0xf1, 0xeb, 0xe3, 0xe5, 0xeb, 0x3c, 0x57,
    0x7e, 0xfe, 0x2c, 0xca, 0xb7, 0xdc, 0xcf, 0x29, 0x22, 0x2e, 0x02, 0xe1, 0x22, 0x0f, 0x02, 0xd5, 0x2a, 0x38, 0x02,
    0x3e, 0x19, 0xeb, 0x2a, 0x3a, 0x02, 0xeb, 0xe7, 0xca, 0x05, 0xdd, 0x7e, 0xb9, 0x23, 0xc2, 0xea, 0xdc, 0x7e, 0xb8,
    0x23, 0x5e, 0x23, 0x56, 0x23, 0xc2, 0xd8, 0xdc, 0x3a, 0x0f, 0x02, 0xb7, 0x1e, 0x12, 0xc2, 0x47, 0xd1, 0xf1, 0xbe,
    0xca, 0x63, 0xdd, 0x1e, 0x10, 0xc3, 0x47, 0xd1, 0x11, 0x04, 0x00, 0x71, 0x23, 0x70, 0x23, 0xf1, 0x32, 0x7a, 0x02,
    0xc3, 0x77, 0x02, 0x22, 0x26, 0x02, 0x23, 0x23, 0x41, 0x70, 0x23, 0x3a, 0x0f, 0x02, 0xb7, 0x78, 0x01, 0x0b, 0x00,
    0xca, 0x28, 0xdd, 0xc1, 0x03, 0x71, 0x23, 0x70, 0x23, 0xf5, 0xe5, 0xcd, 0x13, 0xe4, 0xeb, 0xe1, 0xc1, 0x05, 0xc2,
    0x1b, 0xdd, 0x42, 0x4b, 0xeb, 0x19, 0xda, 0x00, 0xdd, 0xcd, 0x2a, 0xd1, 0x22, 0x3a, 0x02, 0x2b, 0x36, 0x00, 0xe7,
    0xc2, 0x45, 0xdd, 0x03, 0x67, 0x3a, 0x0f, 0x02, 0xb7, 0x3a, 0x7a, 0x02, 0x6f, 0x29, 0x09, 0xeb, 0x2a, 0x26, 0x02,
    0x73, 0x23, 0x72, 0x23, 0xc2, 0x85, 0xdd, 0x23, 0x01, 0x00, 0x00, 0x16, 0xe1, 0x5e, 0x23, 0x56, 0x23, 0xe3, 0xf5,
    0xe7, 0xd2, 0x00, 0xdd, 0xe5, 0xcd, 0x13, 0xe4, 0xd1, 0x19, 0xf1, 0x3d, 0x44, 0x4d, 0xc2, 0x68, 0xdd, 0x29, 0x29,
    0xc1, 0x09, 0xeb, 0x2a, 0x2e, 0x02, 0x2b, 0xd7, 0xc9, 0x2a, 0x3a, 0x02, 0xeb, 0x21, 0x00, 0x00, 0x39, 0x3a, 0x10,
    0x02, 0xb7, 0xca, 0xa7, 0xdd, 0xcd, 0xd2, 0xdf, 0xcd, 0xe3, 0xde, 0x2a, 0x70, 0x02, 0xeb, 0x2a, 0x24, 0x02, 0x7d,
    0x93, 0x4f, 0x7c, 0x9a, 0x41, 0x50, 0x1e, 0x00, 0x21, 0x10, 0x02, 0x73, 0x06, 0x90, 0xc3, 0x42, 0xe3, 0x3a, 0x0d,
    0x02, 0x47, 0xaf, 0xc3, 0xad, 0xdd, 0xcd, 0x21, 0xde, 0x01, 0xfb, 0xd7, 0xc5, 0xd5, 0xcd, 0x13, 0xde, 0xcf, 0x28,
    0xcd, 0x2c, 0xdc, 0xcd, 0x6f, 0xda, 0xcf, 0x29, 0xcf, 0xbb, 0x44, 0x4d, 0xe3, 0xc3, 0x0a, 0xde, 0xcd, 0x21, 0xde,
    0xd5, 0xcd, 0x1c, 0xdb, 0xcd, 0x6f, 0xda, 0xe3, 0xf7, 0xd1, 0xf7, 0xe1, 0xf7, 0xf7, 0x2b, 0x2b, 0x2b, 0x2b, 0xe5,
    0xe7, 0xd5, 0x1e, 0x22, 0xca, 0x47, 0xd1, 0xcd, 0x81, 0xe3, 0xe1, 0xcd, 0x6c, 0xda, 0x2b, 0xd7, 0xc2, 0x3f, 0xd1,
    0xe1, 0xd1, 0xc1, 0x71, 0x23, 0x70, 0x23, 0x73, 0x23, 0x72, 0xe1, 0xc9, 0xe5, 0x2a, 0x30, 0x02, 0x23, 0x7c, 0xb5,
    0xe1, 0xc0, 0x1e, 0x16, 0xc3, 0x47, 0xd1, 0xcf, 0xaf, 0x3e, 0x80, 0x32, 0x2a, 0x02, 0xb6, 0x47, 0xcd, 0x31, 0xdc,
    0xc3, 0x6f, 0xda, 0xcd, 0x6f, 0xda, 0xcd, 0xd8, 0xe4, 0xcd, 0x60, 0xde, 0xcd, 0xd2, 0xdf, 0x01, 0x21, 0xe0, 0xc5,
    0x7e, 0x23, 0x23, 0xe5, 0xcd, 0xbb, 0xde, 0xe1, 0xf7, 0xc1, 0xcd, 0x57, 0xde, 0xe5, 0x6f, 0xcd, 0xc5, 0xdf, 0xd1,
    0xc9, 0xcd, 0xbb, 0xde, 0x21, 0x20, 0x02, 0xe5, 0x77, 0x23, 0xc3, 0x0d, 0xde, 0x2b, 0x06, 0x22, 0x50, 0xe5, 0x0e,
    0xff, 0x23, 0x7e, 0x0c, 0xb7, 0xca, 0x76, 0xde, 0xba, 0xca, 0x76, 0xde, 0xb8, 0xc2, 0x67, 0xde, 0xfe, 0x22, 0xcc,
    0x93, 0xd5, 0xe3, 0x23, 0xeb, 0x79, 0xcd, 0x57, 0xde, 0xe7, 0xd4, 0x40, 0xde, 0x11, 0x20, 0x02, 0x2a, 0x12, 0x02,
    0x22, 0x3e, 0x02, 0x3e, 0x01, 0x32, 0x10, 0x02, 0xcd, 0x84, 0xe3, 0xe7, 0x1e, 0x1e, 0xca, 0x47, 0xd1, 0x22, 0x12,
    0x02, 0xe1, 0x7e, 0xc9, 0x23, 0xcd, 0x60, 0xde, 0xcd, 0xd2, 0xdf, 0xcd, 0x78, 0xe3, 0x1c, 0x1d, 0xc8, 0x0a, 0xdf,
    0xfe, 0x0d, 0xcc, 0xf6, 0xd8, 0x03, 0xc3, 0xae, 0xde, 0xb7, 0x0e, 0xf1, 0xf5, 0x2a, 0x70, 0x02, 0xeb, 0x2a, 0x24,
    0x02, 0x2f, 0x4f, 0x06, 0xff, 0x09, 0x23, 0xe7, 0xda, 0xd7, 0xde, 0x22, 0x24, 0x02, 0x23, 0xeb, 0xf1, 0xc9, 0xf1,
    0x1e, 0x1a, 0xca, 0x47, 0xd1, 0xbf, 0xf5, 0x01, 0xbd, 0xde, 0xc5, 0x2a, 0x6e, 0x02, 0x22, 0x24, 0x02, 0x21, 0x00,
    0x00, 0xe5, 0x2a, 0x70, 0x02, 0xe5, 0x21, 0x14, 0x02, 0xeb, 0x2a, 0x12, 0x02, 0xeb, 0xe7, 0x01, 0xf4, 0xde, 0xc2,
    0x40, 0xdf, 0x2a, 0x36, 0x02, 0xeb, 0x2a, 0x38, 0x02, 0xeb, 0xe7, 0xca, 0x17, 0xdf, 0x7e, 0x23, 0x23, 0xb7, 0xcd,
    0x43, 0xdf, 0xc3, 0x03, 0xdf, 0xc1, 0xeb, 0x2a, 0x3a, 0x02, 0xeb, 0xe7, 0xca, 0x63, 0xdf, 0xcd, 0x78, 0xe3, 0x7b,
    0xe5, 0x09, 0xb7, 0xf2, 0x16, 0xdf, 0x22, 0x26, 0x02, 0xe1, 0x4e, 0x06, 0x00, 0x09, 0x09, 0x23, 0xeb, 0x2a, 0x26,
    0x02, 0xeb, 0xe7, 0xca, 0x17, 0xdf, 0x01, 0x34, 0xdf, 0xc5, 0xf6, 0x80, 0xf7, 0xf7, 0xd1, 0xc1, 0xf0, 0x79, 0xb7,
    0xc8, 0x44, 0x4d, 0x2a, 0x24, 0x02, 0xe7, 0x60, 0x69, 0xd8, 0xe1, 0xe3, 0xe7, 0xe3, 0xe5, 0x60, 0x69, 0xd0, 0xc1,
    0xf1, 0xf1, 0xe5, 0xd5, 0xc5, 0xc9, 0xd1, 0xe1, 0x7d, 0xb4, 0xc8, 0x2b, 0x46, 0x2b, 0x4e, 0xe5, 0x2b, 0x2b, 0x6e,
    0x26, 0x00, 0x09, 0x50, 0x59, 0x2b, 0x44, 0x4d, 0x2a, 0x24, 0x02, 0xcd, 0x0d, 0xd1, 0xe1, 0x71, 0x23, 0x70, 0x69,
    0x60, 0x2b, 0xc3, 0xe6, 0xde, 0xc5, 0xe5, 0x2a, 0x3e, 0x02, 0xe3, 0xcd, 0xeb, 0xda, 0xe3, 0xcd, 0x70, 0xda, 0x7e,
    0xe5, 0x2a, 0x3e, 0x02, 0xe5, 0x86, 0x1e, 0x1c, 0xda, 0x47, 0xd1, 0xcd, 0x54, 0xde, 0xd1, 0xcd, 0xd6, 0xdf, 0xe3,
    0xcd, 0xd5, 0xdf, 0xe5, 0x2a, 0x22, 0x02, 0xeb, 0xcd, 0xbf, 0xdf, 0xcd, 0xbf, 0xdf, 0x21, 0x8c, 0xda, 0xe3, 0xe5,
    0xc3, 0x86, 0xde, 0xe1, 0xe3, 0xf7, 0xf7, 0xc1, 0xe1, 0x2c, 0x2d, 0xc8, 0x0a, 0x12, 0x03, 0x13, 0xc3, 0xc6, 0xdf,
    0xcd, 0x70, 0xda, 0x2a, 0x3e, 0x02, 0xeb, 0x2a, 0x12, 0x02, 0x2b, 0x46, 0x2b, 0x4e, 0x2b, 0x2b, 0xe7, 0xeb, 0xc0,
    0x22, 0x12, 0x02, 0xd5, 0x50, 0x59, 0x1b, 0x4e, 0x2a, 0x24, 0x02, 0xe7, 0xc2, 0xf6, 0xdf, 0x47, 0x09, 0x22, 0x24,
    0x02, 0xe1, 0xc9, 0x01, 0xbc, 0xdd, 0xc5, 0xcd, 0xcf, 0xdf, 0xaf, 0x57, 0x32, 0x10, 0x02, 0x7e, 0xb7, 0xc9, 0xcd,
    0xfc, 0xdf, 0xca, 0x3f, 0xd7, 0x23, 0x23, 0xf7, 0xe1, 0x7e, 0xc3, 0xbc, 0xdd, 0x3e, 0x01, 0xcd, 0x54, 0xde, 0xcd,
    0xb2, 0xe0, 0x2a, 0x22, 0x02, 0x73, 0xc1, 0xc3, 0x86, 0xde, 0xcd, 0x98, 0xe0, 0xaf, 0xe3, 0x4f, 0xe5, 0x7e, 0xb8,
    0xda, 0x33, 0xe0, 0x78, 0x11, 0x0e, 0x00, 0xc5, 0xcd, 0xbb, 0xde, 0xc1, 0xe1, 0xe5, 0x23, 0x23, 0x46, 0x23, 0x66,
    0x68, 0x06, 0x00, 0x09, 0x44, 0x4d, 0xcd, 0x57, 0xde, 0x6f, 0xcd, 0xc5, 0xdf, 0xd1, 0xcd, 0xd6, 0xdf, 0xc3, 0x86,
    0xde, 0xcd, 0x98, 0xe0, 0xd1, 0xd5, 0x1a, 0x90, 0xc3, 0x29, 0xe0, 0xeb, 0x7e, 0xcd, 0x9b, 0xe0, 0xc5, 0x1e, 0xff,
    0xfe, 0x29, 0xca, 0x71, 0xe0, 0xcf, 0x2c, 0xcd, 0xaf, 0xe0, 0xcf, 0x29, 0xf1, 0xe3, 0x01, 0x2b, 0xe0, 0xc5, 0x3d,
    0xbe, 0x06, 0x00, 0xd0, 0x4f, 0x7e, 0x91, 0xbb, 0x47, 0xd8, 0x43, 0xc9, 0xcd, 0xb2, 0xe0, 0x32, 0x7f, 0x02, 0xcd,
    0x7e, 0x02, 0xc3, 0xbc, 0xdd, 0xcd, 0xa5, 0xe0, 0xc3, 0x81, 0x02, 0xeb, 0xcf, 0x29, 0xc1, 0xd1, 0xc5, 0x43, 0x04,
    0x05, 0xca, 0x3f, 0xd7, 0xc9, 0xcd, 0xaf, 0xe0, 0x32, 0x82, 0x02, 0xcf, 0x2c, 0x06, 0xd7, 0xcd, 0x6c, 0xda, 0xcd,
    0x28, 0xd7, 0x7a, 0xb7, 0xc2, 0x3f, 0xd7, 0x2b, 0xd7, 0x7b, 0xc9, 0xcd, 0xfc, 0xdf, 0xca, 0x58, 0xe1, 0x5f, 0x23,
    0x23, 0xf7, 0x60, 0x69, 0x19, 0x46, 0x72, 0xe3, 0xc5, 0x7e, 0xcd, 0x2e, 0xe4, 0xc1, 0xe1, 0x70, 0xc9, 0xd5, 0xcf,
    0x2c, 0xcd, 0xaf, 0xe0, 0xd1, 0x12, 0xc9, 0x21, 0xa1, 0xe5, 0xcd, 0x78, 0xe3, 0xc3, 0xf2, 0xe0, 0xcd, 0x78, 0xe3,
    0x21, 0xc1, 0xd1, 0xcd, 0x52, 0xe3, 0x78, 0xb7, 0xc8, 0x3a, 0x41, 0x02, 0xb7, 0xca, 0x6a, 0xe3, 0x90, 0xd2, 0x0c,
    0xe1, 0x2f, 0x3c, 0xeb, 0xcd, 0x5a, 0xe3, 0xeb, 0xcd, 0x6a, 0xe3, 0xc1, 0xd1, 0xfe, 0x19, 0xd0, 0xf5, 0xcd, 0x8f,
    0xe3, 0x67, 0xf1, 0xcd, 0xb9, 0xe1, 0xb4, 0x21, 0x3e, 0x02, 0xf2, 0x32, 0xe1, 0xcd, 0x99, 0xe1, 0xd2, 0x78, 0xe1,
    0x23, 0x34, 0xca, 0x94, 0xe1, 0x2e, 0x01, 0xcd, 0xcf, 0xe1, 0xc3, 0x78, 0xe1, 0xaf, 0x90, 0x47, 0x7e, 0x9b, 0x5f,
    0x23, 0x7e, 0x9a, 0x57, 0x23, 0x7e, 0x99, 0x4f, 0xdc, 0xa5, 0xe1, 0x68, 0x63, 0xaf, 0x47, 0x79, 0xb7, 0xc2, 0x65,
    0xe1, 0x4a, 0x54, 0x65, 0x6f, 0x78, 0xd6, 0x08, 0xfe, 0xe0, 0xc2, 0x46, 0xe1, 0xaf, 0x32, 0x41, 0x02, 0xc9, 0x05,
    0x29, 0x7a, 0x17, 0x57, 0x79, 0x8f, 0x4f, 0xf2, 0x5d, 0xe1, 0x78, 0x5c, 0x45, 0xb7, 0xca, 0x78, 0xe1, 0x21, 0x41,
    0x02, 0x86, 0x77, 0xd2, 0x58, 0xe1, 0xc8, 0x78, 0x21, 0x41, 0x02, 0xb7, 0xfc, 0x8a, 0xe1, 0x46, 0x23, 0x7e, 0xe6,
    0x80, 0xa9, 0x4f, 0xc3, 0x6a, 0xe3, 0x1c, 0xc0, 0x14, 0xc0, 0x0c, 0xc0, 0x0e, 0x80, 0x34, 0xc0, 0x1e, 0x0a, 0xc3,
    0x47, 0xd1, 0x7e, 0x83, 0x5f, 0x23, 0x7e, 0x8a, 0x57, 0x23, 0x7e, 0x89, 0x4f, 0xc9, 0x21, 0x42, 0x02, 0x7e, 0x2f,
    0x77, 0xaf, 0x6f, 0x90, 0x47, 0x7d, 0x9b, 0x5f, 0x7d, 0x9a, 0x57, 0x7d, 0x99, 0x4f, 0xc9, 0x06, 0x00, 0xd6, 0x08,
    0xda, 0xc8, 0xe1, 0x43, 0x5a, 0x51, 0x0e, 0x00, 0xc3, 0xbb, 0xe1, 0xc6, 0x09, 0x6f, 0xaf, 0x2d, 0xc8, 0x79, 0x1f,
    0x4f, 0x7a, 0x1f, 0x57, 0x7b, 0x1f, 0x5f, 0x78, 0x1f, 0x47, 0xc3, 0xcb, 0xe1, 0x00, 0x00, 0x00, 0x81, 0x03, 0xaa,
    0x56, 0x19, 0x80, 0xf1, 0x22, 0x76, 0x80, 0x45, 0xaa, 0x38, 0x82, 0xef, 0xea, 0x3f, 0xd7, 0x21, 0x41, 0x02, 0x7e,
    0x01, 0x35, 0x80, 0x11, 0xf3, 0x04, 0x90, 0xf5, 0x70, 0xd5, 0xc5, 0xcd, 0xf2, 0xe0, 0xc1, 0xd1, 0x04, 0xcd, 0x8c,
    0xe2, 0x21, 0xdd, 0xe1, 0xcd, 0xe9, 0xe0, 0x21, 0xe1, 0xe1, 0xcd, 0x62, 0xe6, 0x01, 0x80, 0x80, 0x11, 0x00, 0x00,
    0xcd, 0xf2, 0xe0, 0xf1, 0xcd, 0xae, 0xe4, 0x01, 0x31, 0x80, 0x11, 0x18, 0x72, 0x21, 0xc1, 0xd1, 0xef, 0xc8, 0x2e,
    0x00, 0xcd, 0xf2, 0xe2, 0x79, 0x32, 0x85, 0x02, 0xeb, 0x22, 0x50, 0x02, 0x01, 0x00, 0x00, 0x50, 0x58, 0x21, 0x43,
    0xe1, 0xe5, 0x21, 0x4c, 0xe2, 0xe5, 0xe5, 0x21, 0x3e, 0x02, 0x7e, 0x23, 0xb7, 0xca, 0x79, 0xe2, 0xe5, 0xeb, 0x1e,
    0x08, 0x1f, 0x57, 0x79, 0xd2, 0x66, 0xe2, 0xd5, 0xeb, 0x2a, 0x50, 0x02, 0x19, 0xd1, 0xc3, 0x84, 0x02, 0x1f, 0x4f,
    0x7c, 0x1f, 0x67, 0x7d, 0x1f, 0x6f, 0x78, 0x1f, 0x47, 0x1d, 0x7a, 0xc2, 0x56, 0xe2, 0xeb, 0xe1, 0xc9, 0x43, 0x5a,
    0x51, 0x4f, 0xc9, 0xcd, 0x5a, 0xe3, 0x01, 0x20, 0x84, 0x11, 0x00, 0x00, 0xcd, 0x6a, 0xe3, 0xc1, 0xd1, 0xef, 0xca,
    0x42, 0xd1, 0x2e, 0xff, 0xcd, 0xf2, 0xe2, 0x34, 0x34, 0x2b, 0x7e, 0x32, 0x92, 0x02, 0x2b, 0x7e, 0x32, 0x8e, 0x02,
    0x2b, 0x7e, 0x32, 0x8a, 0x02, 0x41, 0xeb, 0xaf, 0x4f, 0x57, 0x5f, 0x32, 0x95, 0x02, 0xe5, 0xc5, 0x7d, 0xc3, 0x89,
    0x02, 0xde, 0x00, 0x3f, 0xd2, 0xc2, 0xe2, 0x32, 0x95, 0x02, 0xf1, 0xf1, 0x37, 0xd2, 0xc1, 0xe1, 0x79, 0x3c, 0x3d,
    0x1f, 0xfa, 0x79, 0xe1, 0x17, 0x7b, 0x17, 0x5f, 0x7a, 0x17, 0x57, 0x79, 0x17, 0x4f, 0x29, 0x78, 0x17, 0x47, 0x3a,
    0x95, 0x02, 0x17, 0x32, 0x95, 0x02, 0x79, 0xb2, 0xb3, 0xc2, 0xaf, 0xe2, 0xe5, 0x21, 0x41, 0x02, 0x35, 0xe1, 0xc2,
    0xaf, 0xe2, 0xc3, 0x94, 0xe1, 0x78, 0xb7, 0xca, 0x14, 0xe3, 0x7d, 0x21, 0x41, 0x02, 0xae, 0x80, 0x47, 0x1f, 0xa8,
    0x78, 0xf2, 0x13, 0xe3, 0xc6, 0x80, 0x77, 0xca, 0x77, 0xe2, 0xcd, 0x8f, 0xe3, 0x77, 0x2b, 0xc9, 0xef, 0x2f, 0xe1,
    0xb7, 0xe1, 0xf2, 0x58, 0xe1, 0xc3, 0x94, 0xe1, 0xcd, 0x75, 0xe3, 0x78, 0xb7, 0xc8, 0xc6, 0x02, 0xda, 0x94, 0xe1,
    0x47, 0xcd, 0xf2, 0xe0, 0x21, 0x41, 0x02, 0x34, 0xc0, 0xc3, 0x94, 0xe1, 0x3a, 0x40, 0x02, 0xfe, 0x2f, 0x17, 0x9f,
    0xc0, 0x3c, 0xc9, 0xef, 0x06, 0x88, 0x11, 0x00, 0x00, 0x21, 0x41, 0x02, 0x4f, 0x70, 0x06, 0x00, 0x23, 0x36, 0x80,
    0x17, 0xc3, 0x40, 0xe1, 0xef, 0xf0, 0x21, 0x40, 0x02, 0x7e, 0xee, 0x80, 0x77, 0xc9, 0xeb, 0x2a, 0x3e, 0x02, 0xe3,
    0xe5, 0x2a, 0x40, 0x02, 0xe3, 0xe5, 0xeb, 0xc9, 0xcd, 0x78, 0xe3, 0xeb, 0x22, 0x3e, 0x02, 0x60, 0x69, 0x22, 0x40,
    0x02, 0xeb, 0xc9, 0x21, 0x3e, 0x02, 0x5e, 0x23, 0x56, 0x23, 0x4e, 0x23, 0x46, 0x23, 0xc9, 0x11, 0x3e, 0x02, 0x06,
    0x04, 0x1a, 0x77, 0x13, 0x23, 0x05, 0xc2, 0x86, 0xe3, 0xc9, 0x21, 0x40, 0x02, 0x7e, 0x07, 0x37, 0x1f, 0x77, 0x3f,
    0x1f, 0x23, 0x23, 0x77, 0x79, 0x07, 0x37, 0x1f, 0x4f, 0x1f, 0xae, 0xc9, 0x78, 0xb7, 0xca, 0x28, 0x00, 0x21, 0x36,
    0xe3, 0xe5, 0xef, 0x79, 0xc8, 0x21, 0x40, 0x02, 0xae, 0x79, 0xf8, 0xcd, 0xbc, 0xe3, 0x1f, 0xa9, 0xc9, 0x23, 0x78,
    0xbe, 0xc0, 0x2b, 0x79, 0xbe, 0xc0, 0x2b, 0x7a, 0xbe, 0xc0, 0x2b, 0x7b, 0x96, 0xc0, 0xe1, 0xe1, 0xc9, 0x47, 0x4f,
    0x57, 0x5f, 0xb7, 0xc8, 0xe5, 0xcd, 0x75, 0xe3, 0xcd, 0x8f, 0xe3, 0xae, 0x67, 0xfc, 0xf3, 0xe3, 0x3e, 0x98, 0x90,
    0xcd, 0xb9, 0xe1, 0x7c, 0x17, 0xdc, 0x8a, 0xe1, 0x06, 0x00, 0xdc, 0xa5, 0xe1, 0xe1, 0xc9, 0x1b, 0x7a, 0xa3, 0x3c,
    0xc0, 0x0d, 0xc9, 0x21, 0x41, 0x02, 0x7e, 0xfe, 0x98, 0x3a, 0x3e, 0x02, 0xd0, 0x7e, 0xcd, 0xcf, 0xe3, 0x36, 0x98,
    0x7b, 0xf5, 0x79, 0x17, 0xcd, 0x40, 0xe1, 0xf1, 0xc9, 0x21, 0x00, 0x00, 0x78, 0xb1, 0xc8, 0x3e, 0x10, 0x29, 0xda,
    0x00, 0xdd, 0xeb, 0x29, 0xeb, 0xd2, 0x29, 0xe4, 0x09, 0xda, 0x00, 0xdd, 0x3d, 0xc2, 0x1b, 0xe4, 0xc9, 0xfe, 0x2d,
    0xf5, 0xca, 0x3a, 0xe4, 0xfe, 0x2b, 0xca, 0x3a, 0xe4, 0x2b, 0xcd, 0x58, 0xe1, 0x47, 0x57, 0x5f, 0x2f, 0x4f, 0xd7,
    0xda, 0x97, 0xe4, 0xfe, 0x2e, 0xca, 0x72, 0xe4, 0xfe, 0x45, 0xc2, 0x76, 0xe4, 0xd7, 0xe5, 0x21, 0x66, 0xe4, 0xe3,
    0x15, 0xfe, 0xb4, 0xc8, 0xfe, 0x2d, 0xc8, 0x14, 0xfe, 0x2b, 0xc8, 0xfe, 0xb3, 0xc8, 0xf1, 0x2b, 0xd7, 0xda, 0xb9,
    0xe4, 0x14, 0xc2, 0x76, 0xe4, 0xaf, 0x93, 0x5f, 0x0c, 0x0c, 0xca, 0x42, 0xe4, 0xe5, 0x7b, 0x90, 0xf4, 0x8f, 0xe4,
    0xf2, 0x85, 0xe4, 0xf5, 0xcd, 0x7e, 0xe2, 0xf1, 0x3c, 0xc2, 0x79, 0xe4, 0xd1, 0xf1, 0xcc, 0x52, 0xe3, 0xeb, 0xc9,
    0xc8, 0xf5, 0xcd, 0x1b, 0xe3, 0xf1, 0x3d, 0xc9, 0xd5, 0x57, 0x78, 0x89, 0x47, 0xc5, 0xe5, 0xd5, 0xcd, 0x1b, 0xe3,
    0xf1, 0xd6, 0x30, 0xcd, 0xae, 0xe4, 0xe1, 0xc1, 0xd1, 0xc3, 0x42, 0xe4, 0xcd, 0x5a, 0xe3, 0xcd, 0x3d, 0xe3, 0xc1,
    0xd1, 0xc3, 0xf2, 0xe0, 0x7b, 0x07, 0x07, 0x83, 0x07, 0x86, 0xd6, 0x30, 0x5f, 0xc3, 0x66, 0xe4, 0xe5, 0x21, 0xd7,
    0xd0, 0xcd, 0xa4, 0xde, 0xe1, 0xeb, 0xaf, 0x06, 0x98, 0xcd, 0x42, 0xe3, 0x21, 0xa3, 0xde, 0xe5, 0x21, 0x43, 0x02,
    0xe5, 0xef, 0x36, 0x20, 0xf2, 0xe4, 0xe4, 0x36, 0x2d, 0x23, 0x36, 0x30, 0xca, 0x8d, 0xe5, 0xe5, 0xfc, 0x52, 0xe3,
    0xaf, 0xf5, 0xcd, 0x93, 0xe5, 0x01, 0x43, 0x91, 0x11, 0xf8, 0x4f, 0xcd, 0xa4, 0xe3, 0xe2, 0x10, 0xe5, 0xf1, 0xcd,
    0x90, 0xe4, 0xf5, 0xc3, 0xf3, 0xe4, 0xcd, 0x7e, 0xe2, 0xf1, 0x3c, 0xf5, 0xcd, 0x93, 0xe5, 0xcd, 0xe0, 0xe0, 0x3c,
    0xcd, 0xcf, 0xe3, 0xcd, 0x6a, 0xe3, 0x01, 0x06, 0x02, 0xf1, 0x81, 0xfa, 0x2b, 0xe5, 0xfe, 0x07, 0xd2, 0x2b, 0xe5,
    0x3c, 0x47, 0x3e, 0x01, 0x3d, 0xe1, 0xf5, 0x11, 0xa5, 0xe5, 0x05, 0x36, 0x2e, 0xcc, 0x7f, 0xe3, 0xc5, 0xe5, 0xd5,
    0xcd, 0x75, 0xe3, 0xe1, 0x06, 0x2f, 0x04, 0x7b, 0x96, 0x5f, 0x23, 0x7a, 0x9e, 0x57, 0x23, 0x79, 0x9e, 0x4f, 0x2b,
    0x2b, 0xd2, 0x40, 0xe5, 0xcd, 0x99, 0xe1, 0x23, 0xcd, 0x6a, 0xe3, 0xeb, 0xe1, 0x70, 0x23, 0xc1, 0x0d, 0xc2, 0x31,
    0xe5, 0x05, 0xca, 0x71, 0xe5, 0x2b, 0x7e, 0xfe, 0x30, 0xca, 0x65, 0xe5, 0xfe, 0x2e, 0xc4, 0x7f, 0xe3, 0xf1, 0xca,
    0x90, 0xe5, 0x36, 0x45, 0x23, 0x36, 0x2b, 0xf2, 0x81, 0xe5, 0x36, 0x2d, 0x2f, 0x3c, 0x06, 0x2f, 0x04, 0xd6, 0x0a,
    0xd2, 0x83, 0xe5, 0xc6, 0x3a, 0x23, 0x70, 0x23, 0x77, 0x23, 0x71, 0xe1, 0xc9, 0x01, 0x74, 0x94, 0x11, 0xf7, 0x23,
    0xcd, 0xa4, 0xe3, 0xe1, 0xe2, 0x07, 0xe5, 0xe9, 0x00, 0x00, 0x00, 0x80, 0xa0, 0x86, 0x01, 0x10, 0x27, 0x00, 0xe8,
    0x03, 0x00, 0x64, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x01, 0x00, 0x00, 0x21, 0x52, 0xe3, 0xe3, 0xe9, 0xcd, 0x5a, 0xe3,
    0x21, 0xa1, 0xe5, 0xcd, 0x67, 0xe3, 0xc1, 0xd1, 0xef, 0xca, 0x01, 0xe6, 0x78, 0xb7, 0xca, 0x59, 0xe1, 0xd5, 0xc5,
    0x79, 0xf6, 0x7f, 0xcd, 0x75, 0xe3, 0xf2, 0xe9, 0xe5, 0xd5, 0xc5, 0xcd, 0xfa, 0xe3, 0xc1, 0xd1, 0xf5, 0xcd, 0xa4,
    0xe3, 0xe1, 0x7c, 0x1f, 0xe1, 0x22, 0x40, 0x02, 0xe1, 0x22, 0x3e, 0x02, 0xdc, 0xb7, 0xe5, 0xcc, 0x52, 0xe3, 0xd5,
    0xc5, 0xcd, 0xee, 0xe1, 0xc1, 0xd1, 0xcd, 0x2c, 0xe2, 0xcd, 0x5a, 0xe3, 0x01, 0x38, 0x81, 0x11, 0x3b, 0xaa, 0xcd,
    0x2c, 0xe2, 0x3a, 0x41, 0x02, 0xfe, 0x88, 0xd2, 0x10, 0xe3, 0xcd, 0xfa, 0xe3, 0xc6, 0x80, 0xc6, 0x02, 0xda, 0x10,
    0xe3, 0xf5, 0x21, 0xdd, 0xe1, 0xcd, 0xe3, 0xe0, 0xcd, 0x23, 0xe2, 0xf1, 0xc1, 0xd1, 0xf5, 0xcd, 0xef, 0xe0, 0xcd,
    0x52, 0xe3, 0x21, 0x41, 0xe6, 0xcd, 0x71, 0xe6, 0x11, 0x00, 0x00, 0xc1, 0x4a, 0xc3, 0x2c, 0xe2, 0x08, 0x40, 0x2e,
    0x94, 0x74, 0x70, 0x4f, 0x2e, 0x77, 0x6e, 0x02, 0x88, 0x7a, 0xe6, 0xa0, 0x2a, 0x7c, 0x50, 0xaa, 0xaa, 0x7e, 0xff,
    0xff, 0x7f, 0x7f, 0x00, 0x00, 0x80, 0x81, 0x00, 0x00, 0x00, 0x81, 0xcd, 0x5a, 0xe3, 0x11, 0x2a, 0xe2, 0xd5, 0xe5,
    0xcd, 0x75, 0xe3, 0xcd, 0x2c, 0xe2, 0xe1, 0xcd, 0x5a, 0xe3, 0x7e, 0x23, 0xcd, 0x67, 0xe3, 0x06, 0xf1, 0xc1, 0xd1,
    0x3d, 0xc8, 0xd5, 0xc5, 0xf5, 0xe5, 0xcd, 0x2c, 0xe2, 0xe1, 0xcd, 0x78, 0xe3, 0xe5, 0xcd, 0xf2, 0xe0, 0xe1, 0xc3,
    0x7a, 0xe6, 0xef, 0xfa, 0xaf, 0xe6, 0x21, 0x52, 0x02, 0xcd, 0x67, 0xe3, 0xc8, 0x01, 0x35, 0x98, 0x11, 0x7a, 0x44,
    0xcd, 0x2c, 0xe2, 0x01, 0x28, 0x68, 0x11, 0x46, 0xb1, 0xcd, 0xf2, 0xe0, 0xcd, 0x75, 0xe3, 0x7b, 0x59, 0x4f, 0x36,
    0x80, 0x2b, 0x46, 0x36, 0x80, 0xcd, 0x43, 0xe1, 0x21, 0x52, 0x02, 0xc3, 0x81, 0xe3, 0x21, 0x0a, 0xe7, 0xcd, 0xe3,
    0xe0, 0xcd, 0x5a, 0xe3, 0x01, 0x49, 0x83, 0x11, 0xdb, 0x0f, 0xcd, 0x6a, 0xe3, 0xc1, 0xd1, 0xcd, 0x8c, 0xe2, 0xcd,
    0x5a, 0xe3, 0xcd, 0xfa, 0xe3, 0xc1, 0xd1, 0xcd, 0xef, 0xe0, 0x21, 0x0e, 0xe7, 0xcd, 0xe9, 0xe0, 0xef, 0x37, 0xf2,
    0xf6, 0xe6, 0xcd, 0xe0, 0xe0, 0xef, 0xb7, 0xf5, 0xf4, 0x52, 0xe3, 0x21, 0x0e, 0xe7, 0xcd, 0xe3, 0xe0, 0xf1, 0xd4,
    0x52, 0xe3, 0x21, 0x12, 0xe7, 0xc3, 0x62, 0xe6, 0xdb, 0x0f, 0x49, 0x81, 0x00, 0x00, 0x00, 0x7f, 0x05, 0xba, 0xd7,
    0x1e, 0x86, 0x64, 0x26, 0x99, 0x87, 0x58, 0x34, 0x23, 0x87, 0xe0, 0x5d, 0xa5, 0x86, 0xda, 0x0f, 0x49, 0x83, 0xcd,
    0x5a, 0xe3, 0xcd, 0xca, 0xe6, 0xc1, 0xe1, 0xcd, 0x5a, 0xe3, 0xeb, 0xcd, 0x6a, 0xe3, 0xcd, 0xc4, 0xe6, 0xc3, 0x8a,
    0xe2, 0xef, 0xfc, 0xb7, 0xe5, 0xfc, 0x52, 0xe3, 0x3a, 0x41, 0x02, 0xfe, 0x81, 0xda, 0x57, 0xe7, 0x01, 0x00, 0x81,
    0x51, 0x59, 0xcd, 0x8c, 0xe2, 0x21, 0xe9, 0xe0, 0xe5, 0x21, 0x61, 0xe7, 0xcd, 0x62, 0xe6, 0x21, 0x0a, 0xe7, 0xc9,
    0x09, 0x4a, 0xd7, 0x3b, 0x78, 0x02, 0x6e, 0x84, 0x7b, 0xfe, 0xc1, 0x2f, 0x7c, 0x74, 0x31, 0x9a, 0x7d, 0x84, 0x3d,
    0x5a, 0x7d, 0xc8, 0x7f, 0x91, 0x7e, 0xe4, 0xbb, 0x4c, 0x7e, 0x6c, 0xaa, 0xaa, 0x7f, 0x00, 0x00, 0x00, 0x81, 0x00,
    0x00, 0xef, 0xcd, 0x2c, 0xd7, 0x1a, 0xc3, 0xbc, 0xdd, 0xcd, 0x6c, 0xda, 0xef, 0xcd, 0x2c, 0xd7, 0xc3, 0xd7, 0xe0,
    0xef, 0xcd, 0x2c, 0xd7, 0xeb, 0xcd, 0xa5, 0xe7, 0xc3, 0xbc, 0xdd, 0xe9, 0xaf, 0x32, 0x00, 0x03, 0x21, 0xba, 0xe7,
    0x7e, 0xb7, 0xca, 0x7f, 0xd1, 0x4e, 0x23, 0xcd, 0xf0, 0xc7, 0xc3, 0xad, 0xe7, 0x07, 0x2a, 0x2a, 0x2a, 0x20, 0x54,
    0x2d, 0x42, 0x41, 0x53, 0x49, 0x43, 0x20, 0x2a, 0x2a, 0x2a, 0x0d, 0x00, 0xcd, 0xaf, 0xe0, 0x32, 0x57, 0x02, 0xcf,
    0x2c, 0xcd, 0xaf, 0xe0, 0x32, 0x56, 0x02, 0xfe, 0x19, 0xd2, 0x3f, 0xd7, 0x3a, 0x57, 0x02, 0xfe, 0x40, 0xd2, 0x3f,
    0xd7, 0xe5, 0xcd, 0xbe, 0xf7, 0x3a, 0x56, 0x02, 0xcd, 0xdc, 0xf7, 0xe1, 0xc9, 0xe5, 0xcd, 0xa0, 0xf9, 0x3a, 0xfa,
    0x01, 0xb7, 0xc4, 0x00, 0xe8, 0xe1, 0xc9, 0xe5, 0xd5, 0xc5, 0xf5, 0x01, 0x00, 0x00, 0x21, 0x00, 0x00, 0x39, 0x31,
    0x00, 0xc0, 0x16, 0x30, 0x1e, 0x20, 0xc5, 0xc5, 0xc5, 0xc5, 0x1d, 0xc2, 0x12, 0xe8, 0x15, 0xc2, 0x10, 0xe8, 0xf9,
    0xf1, 0xc1, 0xd1, 0xe1, 0xc9, 0xeb, 0xcf, 0x2c, 0xcd, 0x6c, 0xda, 0xcd, 0x28, 0xd7, 0xeb, 0xc9, 0x3e, 0x00, 0xc3,
    0x36, 0xe8, 0x3e, 0x01, 0x32, 0xfb, 0x01, 0xcd, 0x59, 0xe9, 0xe5, 0x2a, 0xfc, 0x01, 0x22, 0xe0, 0x8f, 0x2a, 0xfe,
    0x01, 0x22, 0xe2, 0x8f, 0xe1, 0xcd, 0x78, 0xe9, 0xca, 0x5e, 0xe8, 0x22, 0xe4, 0x8f, 0xeb, 0xe5, 0xd5, 0xc5, 0xcd,
    0x06, 0xc8, 0xc1, 0xd1, 0xe1, 0xc9, 0x2a, 0x00, 0x02, 0x3a, 0xfb, 0x01, 0xb7, 0xca, 0x50, 0xe8, 0x2a, 0x02, 0x02,
    0xc3, 0x50, 0xe8, 0xcd, 0x59, 0xe9, 0xe5, 0x2a, 0xfc, 0x01, 0x22, 0xe8, 0x8f, 0x2a, 0xfe, 0x01, 0x22, 0xea, 0x8f,
    0xe1, 0x7e, 0xcd, 0x98, 0xd5, 0xcf, 0xb4, 0xcd, 0x59, 0xe9, 0xe5, 0x2a, 0xfc, 0x01, 0x22, 0xec, 0x8f, 0x2a, 0xfe,
    0x01, 0x22, 0xee, 0x8f, 0xe1, 0xcd, 0x78, 0xe9, 0xc2, 0x9f, 0xe8, 0x2a, 0x00, 0x02, 0x22, 0xe4, 0x8f, 0xeb, 0xe5,
    0xd5, 0xc5, 0xcd, 0x09, 0xc8, 0xc1, 0xd1, 0xe1, 0xc9, 0xcd, 0x59, 0xe9, 0xe5, 0x2a, 0xfc, 0x01, 0x22, 0xe0, 0x8f,
    0x2a, 0xfe, 0x01, 0x22, 0xe2, 0x8f, 0xe1, 0xcd, 0x78, 0xe9, 0xc2, 0xc7, 0xe8, 0x2a, 0x00, 0x02, 0x22, 0xe4, 0x8f,
    0xeb, 0xe5, 0xd5, 0xc5, 0xcd, 0x00, 0xc8, 0xc1, 0xd1, 0xe1, 0xc9, 0xcd, 0x59, 0xe9, 0xe5, 0x2a, 0xfc, 0x01, 0x22,
    0xe0, 0x8f, 0x2a, 0xfe, 0x01, 0x22, 0xe2, 0x8f, 0xe1, 0xeb, 0xcd, 0x24, 0xe8, 0x22, 0xe6, 0x8f, 0xeb, 0xcd, 0x78,
    0xe9, 0xc2, 0xf7, 0xe8, 0x2a, 0x00, 0x02, 0x22, 0xe4, 0x8f, 0xeb, 0xcd, 0x03, 0xc8, 0xc9, 0x7e, 0xcd, 0x98, 0xd5,
    0xcf, 0x28, 0xcd, 0x6c, 0xda, 0xef, 0xcd, 0x2c, 0xd7, 0xeb, 0x22, 0x04, 0x02, 0xcd, 0x24, 0xe8, 0x22, 0x06, 0x02,
    0xcd, 0x24, 0xe8, 0x22, 0x08, 0x02, 0xcd, 0x24, 0xe8, 0x22, 0x0a, 0x02, 0xeb, 0x7e, 0xcd, 0x98, 0xd5, 0xcf, 0x29,
    0xcd, 0x0c, 0xc8, 0xcd, 0x0f, 0xc8, 0xcd, 0x12, 0xc8, 0xcd, 0x15, 0xc8, 0xc9, 0xcd, 0x6c, 0xda, 0xef, 0xcd, 0x2c,
    0xd7, 0xeb, 0x26, 0x00, 0x7d, 0xe6, 0x03, 0x6f, 0x22, 0x00, 0x02, 0xeb, 0xcd, 0x78, 0xe9, 0xca, 0x57, 0xe9, 0x26,
    0x00, 0x7d, 0xe6, 0x03, 0x6f, 0x22, 0x02, 0x02, 0xeb, 0xc9, 0x7e, 0xcd, 0x98, 0xd5, 0xcf, 0x28, 0xcd, 0x6c, 0xda,
    0xef, 0xcd, 0x2c, 0xd7, 0xeb, 0x22, 0xfc, 0x01, 0xcd, 0x24, 0xe8, 0x22, 0xfe, 0x01, 0xeb, 0x7e, 0xcd, 0x98, 0xd5,
    0xcf, 0x29, 0xc9, 0x7e, 0xcd, 0x98, 0xd5, 0x7e, 0xeb, 0xfe, 0x3a, 0xc8, 0xfe, 0x00, 0xc8, 0xcd, 0x24, 0xe8, 0xf6,
    0x01, 0xc9, 0xc5, 0xcd, 0x59, 0xe9, 0xc1, 0xe5, 0xc5, 0xe5, 0xd5, 0xc5, 0x2a, 0xfc, 0x01, 0x11, 0x80, 0x01, 0x7d,
    0x93, 0x7c, 0x9a, 0xd2, 0xb2, 0xe9, 0x3a, 0xfe, 0x01, 0x2f, 0x5f, 0xcd, 0x3f, 0xca, 0xcd, 0x14, 0xca, 0xc1, 0xd1,
    0xe1, 0xc3, 0xbc, 0xdd, 0xc1, 0xd1, 0xe1, 0x1e, 0x08, 0xc3, 0x47, 0xd1, 0xd5, 0xc5, 0xcd, 0x02, 0xea, 0xe5, 0x21,
    0x00, 0xc9, 0x22, 0x2f, 0xc8, 0xcd, 0x27, 0xed, 0xcd, 0x46, 0xeb, 0xe1, 0xc1, 0xd1, 0xc9, 0xcd, 0x02, 0xea, 0xcd,
    0x4b, 0xd2, 0x21, 0x00, 0xc9, 0x22, 0x2f, 0xc8, 0x21, 0x01, 0x03, 0x22, 0x33, 0xc8, 0x3e, 0xd3, 0x32, 0x31, 0xc8,
    0xcd, 0x7b, 0xeb, 0x2a, 0x3b, 0xc8, 0x22, 0x36, 0x02, 0x21, 0x01, 0x03, 0x22, 0x72, 0x02, 0xcd, 0x46, 0xeb, 0x21,
    0xdc, 0xd0, 0xcd, 0xa4, 0xde, 0xc3, 0xf9, 0xd1, 0xc5, 0xd5, 0x7e, 0xcd, 0x98, 0xd5, 0xcd, 0x1d, 0xd7, 0x11, 0x00,
    0xc9, 0xda, 0x2f, 0xea, 0x0e, 0x06, 0x7e, 0xb7, 0xca, 0x2f, 0xea, 0xfe, 0x3a, 0xca, 0x2f, 0xea, 0xfe, 0x20, 0xc2,
    0x26, 0xea, 0x0c, 0xc3, 0x28, 0xea, 0x12, 0x13, 0x23, 0x0d, 0xc2, 0x13, 0xea, 0x2b, 0xd7, 0x3e, 0x0d, 0x12, 0xd1,
    0xc1, 0xc9, 0xc5, 0xd5, 0xcd, 0x02, 0xea, 0xe5, 0x21, 0x00, 0xc9, 0x22, 0x2f, 0xc8, 0x21, 0x01, 0x03, 0x22, 0x33,
    0xc8, 0x3e, 0xff, 0x32, 0x31, 0xc8, 0xcd, 0x7b, 0xeb, 0xcd, 0x46, 0xeb, 0xe1, 0xd1, 0xc1, 0xc9, 0xcd, 0x02, 0xea,
    0xcd, 0x4b, 0xd2, 0x21, 0x00, 0xc9, 0x22, 0x2f, 0xc8, 0x21, 0x2c, 0x04, 0x22, 0x33, 0xc8, 0x3e, 0xea, 0x32, 0x31,
    0xc8, 0xcd, 0x7b, 0xeb, 0xc3, 0xf6, 0xe9, 0xcd, 0x02, 0xea, 0xe5, 0x21, 0x00, 0xc9, 0x22, 0x2f, 0xc8, 0xcd, 0xd4,
    0xed, 0xe1, 0xaf, 0x32, 0x6b, 0x02, 0x11, 0x00, 0x00, 0xcd, 0x50, 0xd4, 0xcd, 0x46, 0xeb, 0xc9, 0xcd, 0x6c, 0xda,
    0xef, 0xcd, 0x2c, 0xd7, 0xeb, 0x22, 0x59, 0x02, 0xeb, 0xcf, 0x2c, 0xcd, 0x6c, 0xda, 0xcd, 0x28, 0xd7, 0x2b, 0xd7,
    0xe5, 0xc5, 0x2a, 0x59, 0x02, 0xeb, 0xcd, 0xb1, 0xea, 0xc1, 0xe1, 0xc9, 0x42, 0x4b, 0x50, 0x59, 0xd3, 0xb0, 0x2b,
    0x7c, 0xb5, 0xc8, 0x1b, 0x7a, 0xb3, 0xc2, 0xb7, 0xea, 0xc3, 0xb3, 0xea, 0x31, 0x00, 0xc9, 0xcd, 0xa0, 0xf9, 0xcd,
    0x00, 0xe8, 0x21, 0x00, 0x00, 0x22, 0x02, 0x02, 0x21, 0x01, 0x00, 0x22, 0x00, 0x02, 0xaf, 0x32, 0x00, 0x03, 0xcd,
    0x09, 0xeb, 0x01, 0x50, 0xeb, 0x11, 0x7b, 0xeb, 0x21, 0x6e, 0x02, 0xcd, 0x11, 0xfa, 0x3e, 0x2c, 0x32, 0x00, 0x01,
    0x21, 0x52, 0xc7, 0x22, 0x52, 0x02, 0x21, 0x4f, 0x80, 0x22, 0x54, 0x02, 0xcd, 0x4b, 0xd2, 0xc3, 0xa6, 0xe7, 0xcd,
    0x09, 0xeb, 0xc3, 0x7f, 0xd1, 0xaf, 0x32, 0x09, 0xc8, 0x3e, 0x40, 0x32, 0x02, 0xc8, 0xcd, 0x46, 0xeb, 0x3e, 0x03,
    0xd3, 0x90, 0x3e, 0x0d, 0xd3, 0x91, 0x3e, 0x00, 0xd3, 0x92, 0x3e, 0x0b, 0xd3, 0x93, 0x3e, 0xc3, 0x32, 0xf0, 0xc7,
    0x32, 0xf3, 0xc7, 0x32, 0x00, 0x00, 0x21, 0xfb, 0xf7, 0x22, 0xf1, 0xc7, 0x21, 0xfc, 0xf5, 0x22, 0xf4, 0xc7, 0x21,
    0x03, 0xeb, 0x22, 0x01, 0x00, 0xaf, 0xd3, 0xa8, 0xc9, 0xd3, 0xf8, 0xd3, 0xb9, 0x3e, 0xff, 0x32, 0xfa, 0x01, 0xc9,
    0xff, 0x7e, 0xff, 0x6a, 0x01, 0x03, 0xc3, 0x56, 0xd4, 0xcd, 0x19, 0xd1, 0xe9, 0xc3, 0x13, 0xdd, 0xdb, 0xff, 0xc9,
    0xd3, 0xff, 0xc9, 0xce, 0x00, 0xc3, 0x66, 0xe2, 0xd6, 0x00, 0x6f, 0x7c, 0xde, 0x00, 0x67, 0x78, 0xde, 0x00, 0x47,
    0x3e, 0x00, 0xc3, 0xb5, 0xe2};

// Интрактивная функция загрузки с ленты

void TapeLoad(...) {
    // Установка черно-белого видеорежима
    out(PORT_VIDEO_MODE_1_HIGH, a);
    out(PORT_VIDEO_MODE_0_LOW, a);

    // Выбор функции загрузки
    a = vTempTapeRequiredType;
    hl = &TapeLoadBasic;
    if (a != TAPE_BASIC) {
        hl = &TapeLoadAscii;
        if (a != TAPE_ASCII) {
            hl = &TapeLoadBinary;
            if (a != TAPE_BINARY) {
                vTempTapeRequiredType = a = TAPE_BASIC;
                hl = &TapeVerifyBasic;
            }
        }
    }
    vTempTapeFunction = hl;

    // Вывод на экран:
    // Press PLAY on tape
    //  & any key on keyboard
    // И ожидание нажати клавиши
    TapeBeginDialog(hl = &bPressPlayOnTape);

    // Вывод на экран:
    // Searching
    VideoPrintRomString(hl = &bSearching);

    return TapeVerifyLoadRetry();
}

void TapeVerifyLoadRetry(...) {
    TapeReadPilot();
    if (flag_c) return TapeLoadError();
    TapeReadByte();
    if (flag_c) return TapeLoadError();

    // Первый байт содержит тип
    if (a != TAPE_BINARY) {
        if (a != TAPE_BASIC) {
            if (a != TAPE_ASCII) {
                TapeReadByte();  // Взять тип из следующего байта.
                if (flag_c) return TapeLoadError();
            }
        }
    }

    // Следующие 9 байт должны повторять первый.
    c = a;
    b = 9;
    do {
        TapeReadByte();
        if (flag_c) return TapeLoadError();
        if (a != c) return TapeVerifyLoadRetry();
    } while (flag_nz(b--));

    vTempTapeFoundType = a;

    // Далее загружаем 6 байт имени
    hl = &vTempTapeName;
    b = 6;
    do {
        TapeReadByte();
        if (flag_c) return TapeLoadError();
        *hl = a;
        hl++;
    } while (flag_nz(b--));

    // Вывод на экран типа и имя файла загруженного с ленты
    TapePrintFound();

    // Сравниваем тип с требуемым
    a = vTempTapeRequiredType;
    hl = &vTempTapeFoundType;
    if (a != *hl) return TapeVerifyLoadRetry();

    // Сравниваем имя с требуемым
    hl = vTempTapeRequiredName;
    de = &vTempTapeName;
    c = 6;
    do {
        a = *hl;
        if (a == EOL) break;
        b = a;
        a = *de;
        if (a != b) return TapeVerifyLoadRetry();
        hl++;
        de++;
    } while (flag_nz(c--));

    // Вывод на экран:
    // Reading
    VideoPrintRomString(hl = &bReading);

    // Переход на функцию загрузки второго блока
    GotoHl(hl = vTempTapeFunction);
}

// Загрузка BASIC блока с ленты

void TapeLoadBasic(...) {
    TapeReadPilot();
    if (flag_c) return TapeLoadError();

    hl = vTempTape1;
loc_EC31:
    vTempTapeCounter = (a ^= a);
    do {
        TapeReadByte();
        if (flag_c) return TapeLoadError();
        *hl = a;
        hl++;

        if (flag_nz(a |= a)) goto loc_EC31;

        a = vTempTapeCounter;
        a++;
        vTempTapeCounter = a;
    } while (a != 3);
    vTempTape2 = hl;
    return TapePrintDone();
}

// Загрузка ASCII блока с ленты

void TapeLoadAscii(...) {
    vTempTapeAsciiRead = hl = vTempTape1;

    for (;;) {
        push_pop(hl) {
            TapeReadPilot();
        }
        if (flag_c) return TapeLoadError();

        b = 0;
        do {
            TapeReadByte();
            if (flag_c) return TapeLoadError();
            *hl = a;
            hl++;
            if (a == 0x1A) return loc_EC87();
        } while (flag_nz(b++));

        swap(hl, de);
        hl = word_26E;  // TODO: Переименовать
        h--;
        swap(hl, de);
        if ((a = d) < h) return TapeLoadAsciiOverflow();
        if ((a = e) < l) return TapeLoadAsciiOverflow();
    }
    return loc_EC87();
}

void loc_EC87(...) {
    vInputAddress = hl = &TapeAsciiInput;
    return TapePrintDone();
}

// Эта функция подменяет собой функцию RealInput во время загрузки ASCII с ленты
// Вход: a - символ

void TapeAsciiInput(...) {
    for (;;) {
        TapeAsciiInputInternal();
        if (a != 0x0A) return;
    }
}

// Эта функция вызывается функцией выше
// Вход: a - символ

void TapeAsciiInputInternal(...) {
    push_pop(hl) {
        hl = vTempTapeAsciiRead;
        a = *hl;
        hl++;
        vTempTapeAsciiRead = hl;
    }
    if (a != 0x1A) return;
    push_pop(hl) {
        vInputAddress = hl = &RealInput;
        a = EOL;
    }
}

// Эта функция вызывается если при загрузке ASCII блока с ленты закончилась память

void TapeLoadAsciiOverflow(...) {
    *hl = 0x1A;
    VideoPrintRomString(hl = &bFileTooLong);
    return loc_EC87();  // TODO: Переименовать
}

// Загрузка BINARY блока с ленты

void TapeLoadBinary(...) {
    TapeReadPilot();
    if (flag_c) return TapeLoadError();

    TapeReadWord();  // Адрес загрузки первого байта
    if (flag_c) return TapeLoadError();
    swap(hl, de);

    TapeReadWord();  // Адрес загрузки последнего байта
    if (flag_c) return TapeLoadError();
    push(hl);

    TapeReadWord();  // Игнорируется
    pop(hl);
    if (flag_c) return TapeLoadError();

    do {
        do {
            TapeReadByte();
            if (flag_c) return TapeLoadError();
            *de = a;
            de++;
        } while ((a = d) != h);
    } while ((a = e) != l);

    return TapePrintDone();
    return TapePrintDone();
}

// Эта функция вызывается после удачного сохранении или загрузки с ленты

void TapePrintDone(...) {
    return VideoPrintRomString(hl = &bDone);  // Done$
}

// Сравнение BASIC блока на ленте и в памяти

void TapeVerifyBasic(...) {
    TapeReadPilot();
    if (flag_c) return TapeLoadError();

    hl = vTempTape1;
loc_ECFB:
    vTempTapeCounter = (a ^= a);
    do {
        TapeReadByte();
        if (flag_c) return TapeLoadError();
        Compare(a, *hl);
        hl++;
        if (flag_nz) return TapeVerifyError();
        a |= a;
        if (flag_nz) goto loc_ECFB;

        a = vTempTapeCounter;
        a++;
        vTempTapeCounter = a;
    } while (a != 3);

    return TapePrintDone();
}

// Прочтить слово с ленты
// Выход: hl - слово

void TapeReadWord(...) {
    TapeReadByte();
    if (flag_c) return;
    l = a;
    TapeReadByte();
    h = a;
}

// Записать BASIC блок на ленту

void TapeWriteBasicBlock(...) {
    vTempTapeBegin = hl = vBasicProgrammBegin;
    vTempTapeEnd = hl = vBasicProgrammEnd;
    TapeIntractiveWriteHeader(a = TAPE_BASIC);
    TapeWritePilot(a ^= a);  // Короткий пилот-тон
    TapeWriteArray();

    // В конце записать 7 нулей
    b = 7;
    do {
        a ^= a;
        TapeDelay();
        TapeWriteByte(a);
    } while (flag_nz(b--));

    return TapePrintDone();
}

// Записать BINARY блока на ленту

void TapeWriteBinaryBlock(...) {
    TapeIntractiveWriteHeader(a = TAPE_BINARY);
    TapeWritePilot(a ^= a);  // Короткий пилот-тон
    TapeWriteWord(hl = vTempTapeBegin);
    TapeWriteWord(hl = vTempTapeEnd);
    TapeWriteWord(hl = vTempTapeBegin);
    return TapeWriteArray();
    return TapeWriteArray();
}

// Записать массив байт на ленту

void TapeWriteArray(...) {
    hl = vTempTapeEnd;
    hl++;
    swap(de, hl);
    hl = vTempTapeBegin;
    do {
        do {
            TapeWriteByte(a = *hl);
            hl++;
        } while ((a = d) != h);
    } while ((a = e) != l);
}

// Записать слово из на ленту
// Вход: hl - значение для записи

void TapeWriteWord(...) {
    TapeWriteByte(a = l);
    TapeDelay();
    TapeWriteByte(a = h);
}

// Вывод на экран текста "Press RECORD & PLAY on tape & any key on keyboard", ожидание нажатия клавиши,
// вывод на экран текста "Saving" и запись заголовка на ленту.

void TapeIntractiveWriteHeader(...) {
    push_pop(a) {
        // Установка черно-белого видеорежима
        out(PORT_VIDEO_MODE_1_HIGH, a);
        out(PORT_VIDEO_MODE_0_LOW, a);

        // Вывод текста на экран:
        // Press RECORD & PLAY on tape
        // & any key on keyboard
        // и ожидание нажатия клавиши
        TapeBeginDialog(hl = &bPressRecord);

        // Вывод на экран текста "Saving"
        VideoPrintRomString(hl = &bSaving);

        // Запись на ленту длинного пилот-тона
        TapeWritePilot(a = 1);

        // Запись на ленту типа файа 10 раз
        b = 10;
        do {
            pop(a);
            push(a);
            TapeWriteByte(a);
        } while (flag_nz(b--));
    }

    // Запись на ленту имени файла. Имя дополняется до 6 символов пробелами справа.
    b = 6;
    hl = vTempTapeRequiredName;
    do {
        TapeWriteByte(a = *hl);
        b--;
        if (flag_z) goto TapeIntractiveWriteHeaderReturn;
        hl++;
    } while ((a = *hl) != 13);

    do {
        TapeWriteByte(a = ' ');
        TapeDelay();
    } while (flag_nz(b--));
TapeIntractiveWriteHeaderReturn:;
}

// Начать запись ASCII блока на ленту. Окончание записи после записи кода 0x1A в консоль.

void TapeIntractiveWriteHeader();
void TapeAsciiPrint();

void TapeWriteAsciiBlock(...) {
    TapeIntractiveWriteHeader(a = TAPE_ASCII);
    vTempTapeAscii = hl = TAPE_ASCII_BUFFER;
    vPrintAddress = hl = &TapeAsciiPrint;
}

// Эта функция подменяет собой функцию vPrint во время записи ASCII файла на ленту
// Вход: a - символ

void TapeAsciiPrint(...) {
    push_pop(a) {
        TapeAsciiPrintInternal();
    }
    if (a != EOL) return;
    a = 0x0A;
    return TapeAsciiPrintInternal();
    return TapeAsciiPrintInternal();
}

// Внутренняя функция. Вызывается функцией TapeWriteAsciiBlock.
// Вход: a - символ

void TapeAsciiPrintInternal(...) {
    // Сохранить байт в буфер
    push(hl, de);
    hl = vTempTapeAscii;
    de = TAPE_ASCII_BUFFER;
    *hl = a;
    hl++;
    vTempTapeAscii = hl;

    if (a != 0x1A) {
        // Если буфер заполнен, то записать его на ленту
        h--;
        if ((a = h) == d) {
            if ((a = l) == e) TapeAsciiFlush();
        }
        pop(hl, de);
        return;
    }

    // Если это последний записываемый символ, то записать бфер на ленту и вернуть управление VideoPrint
    TapeAsciiFlush();
    vPrintAddress = hl = &VideoPrint;
    pop(hl, de);
}

// Внутренняя функция. Записать ASCII буфер на ленту. Вызывается функцией TapeAsciiPrintInternal.

void TapeAsciiFlush(...) {
    push_pop(bc, hl) {
        // Запись короткого пилот-тона на ленту
        TapeWritePilot(a ^= a);

        // Запись 256 байт из буфера на ленту
        b = 0;
        hl = TAPE_ASCII_BUFFER;
        do {
            TapeWriteByte(a = *hl);
            hl++;
            TapeDelay();
        } while (flag_nz(b--));

        // Очищаем буфер
        vTempTapeAscii = hl = TAPE_ASCII_BUFFER;
    }
}

// Внутренняя функция. Вызывается функцией TapeLoad. Выводит на экран тип и имя файла.

void TapePrintFound(...) {
    // Вывод на экран текста:
    // Found
    VideoPrintRomString(hl = &bFound);

    // Вывод на экран типа загружаемого файла, один из:
    // (BASIC), (ASCII), (BINARY), (UNKNOWN)
    a = vTempTapeFoundType;
    hl = &bBasic;
    if (a != TAPE_BASIC) {
        hl = &bAscii;
        if (a != TAPE_ASCII) {
            hl = &bBinary;
            if (a != TAPE_BINARY) {
                hl = &bUnknown;
            }
        }
    }
    VideoPrintRomString(hl);

    // Вывод на экран имени файла
    hl = &vTempTapeName;
    b = 6;
    do {
        VideoPrint(a = *hl);
        hl++;
    } while (flag_nz(b--));

    // Перевод строки
    PrintNewLine();
}

// Внутренняя функция. Вызывается, если произошла ошибка загрузки с ленты.

void TapeLoadError(...) {
    return VideoPrintRomString(hl = &bLoadError);
}

// Внутренняя функция. Вызывается, если произошла ошибка сравнения с лентой.

void TapeVerifyError(...) {
    return VideoPrintRomString(hl = &bVerifyError);
    return VideoPrintRomString();
}

// Вывод строки текста на экран из ПЗУ CHARGEN_ROM
// Вход: hl - адрес строки
// Строка оканчивается символом $

void VideoPrintRomString(...) {
    for (;;) {
        out(PORT_CHARGEN_ROM, a);
        a = *hl;
        out(PORT_CODE_ROM, a);
        if (a == '$') return;
        VideoPrint(a);
        hl++;
    }
}

// Вывод на экран:
// Press PLAY on tape
//  & any key on keyboard
// И ожидание нажати клавиши

void TapeBeginDialog(...) {
    VideoPrintRomString(hl);
    PrintNewLine();
    VideoPrintRomString(hl = &bAndAnyKeyOnKeyboard);
    RealInput2();
    PrintNewLine();
    return TapeDelay();
}

// Задержка. Используется функциями записи на ленту.

void TapeDelay(...) {
}

// Не используется

uint8_t unused2[80];

asm(" org 0xF000");

// Директива монитора P
// Вывести значения ячеек адресного пространства
// <начальный адрес>P<длина>

void MonitorDirectiveP(...) {
    push(bc, hl);
    MonitorParseChar();  // Пропуск директивы
    MonitorParseNumber();
    if (flag_c) {
        bc = 0x80;  // Второй параметр по умолчанию
    }
    vTempMonitorArgument2 = ((hl = vMonitorArgument1) += bc);
    return MonitorPrintHexDump();
}

// Внутренняя функция. Вызывается функцией MonitorDirectiveEmpty.

void MonitorDirectiveEmpty2(...) {
    push(bc, hl);
    hl = vTempMonitorArgument2;
    return MonitorPrintHexDump();
}

void MonitorPrintHexDump(...) {
    bc = hl;
    hl = vMonitorArgument1;

    do {
        PrintHexWord(hl);
        vPrint(a = ':');
        PrintSpace();
        PrintSpace();
        push_pop(hl) {
            do {
                PrintHexByte(a = *hl);
                PrintSpace();
                MonitorPrintHexDumpLoop();
            } while (flag_nz);
        }
        PrintSpace();
        PrintSpace();

        do {
            a = *hl;
            if (a < 0x20) {
                a = '.';
            }
            vPrint(a);
            MonitorPrintHexDumpLoop();
        } while (flag_nz);

        push_pop(a) {
            vMonitorArgument1 = hl;
            VideoNextLineClear();
        }
    } while (flag_nc);
    pop(bc, hl);
}

void MonitorPrintHexDumpLoop(...) {
    hl++;
    if ((a = l) == c) {
        if ((a = h) == b) {
            a ^= a;
            set_flag_c();
            return;
        }
    }
    a = l;
    a &= 7;
}

// Безымянная директива монитора
// Вывести значение ячейки адресного пространства
// <адрес>
// <пустая строка>

void MonitorDirectiveEmpty(...) {
    hl = vMonitorArgument1;
    hl++;
    vTempMonitorArgument2 = hl;
    return MonitorDirectiveEmpty2();
}

// Директива монитора L
// Дизассемблер
// <адрес>L<кол-во строк>

void MonitorDirectiveL(...) {
    MonitorParseChar();  // Пропуск директивы
    MonitorParseNumber();
    if (flag_c) {
        c = 21;  // Второй параметр по умолчанию
    }
    return MonitorDirectiveLInternal(a = c);
}

// Выполнить команду Монитора

void MonitorExecute(...) {
    // Выделяем первый аргумент директивы
    vTempMonitorAble1 = (a ^= a);
    vTempMonitorParse = hl = &vMonitorString;
    MonitorParseNumber();
    if (flag_nc) {
        vTempMonitorArgument1 = a = c;
        *(&vTempMonitorArgument1 + 1) = a = b;
        vTempMonitorAble1 = a = 0xFF;
    }
    // Сама директива
    a = *hl;
    if (a == '!') return MonitorDirectiveEx();
    a &= 0x5F;
    if (a == 'Z') return VideoClearScreen0();
    if (a == 'X') return VideoInverse();
    if (a == 'N') return VideoNormal();
    if (a == 'I') return MonitorDirectiveI();
    if (a == 'O') return MonitorDirectiveO();
    if (a == 'W') return MonitorDirectiveW();
    if (a == 'R') return MonitorDirectiveR();
    if (a == 'Q') return vMonitorQuit();
    // Сохраняем первый аргумент
    push_pop(a) {
        if (flag_nz((a = vTempMonitorAble1) |= a)) {
            vMonitorArgument1 = hl = vTempMonitorArgument1;
        }
    }
    if (a == ':' & 0x5F) {
        if (flag_nz((a = vTempMonitorAble1) |= a)) return MonitorDirectiveSet();
        hl = vMonitorArgument1;
        hl--;
        vMonitorArgument1 = hl;
        return MonitorDirectiveSet();
    }
    if (a == 'L') return MonitorDirectiveL();
    if (a == 'P') return MonitorDirectiveP();
    if (a == 'G') return MonitorDirectiveG();
    if (a == EOL) return MonitorDirectiveEmpty();
    if (a == 'M') return MonitorDirectiveM();
    if (a == 'V') return MonitorDirectiveV();
    if (a == 'T') return MonitorDirectiveT();
    return MonitorError();
}

void MonitorError(...) {
    vPrint(a = 7);
    VideoNextLineClear();
}

// Вывод строки текста в консоль, а затем перевод строки.
// Строка завершающаяся кодом EOL.
// Вход: hl - адрес строки текста

void PrintStringNewLine(...) {
    PrintString(c = EOL);
    vPrint(a = c);
}

// Вывод строки текста в консоль.
// Вход: hl - адрес строки текста, c - код окончания строки

void PrintString(...) {
    for (;;) {
        a = *hl;
        if (a == c) return;
        vPrint(a);
        hl++;
    }
}

// Получить очедерной числовой параметр дириктивы монитора
// Выход: bc - число, cf - произошла ошибка, a и d - кол-во обработанных цифр

void MonitorParseNumber(...) {
    bc = 0;
    d = 0;
    hl = vTempMonitorParse;
    SkipSpaces(hl);
    for (;;) {
        a = *hl;
        CharCodeToNumber();
        if (a == 0xFF) break;
        push_pop(hl) {
            hl = bc;
            hl += hl += hl += hl += hl;
            b = h;
            c = (a |= l);
        }
        hl++;
        d++;
    }
    vTempMonitorParse = hl;
    if (flag_nz((a = d) |= a)) return;
    set_flag_c();
}

// Директива монитора W
// Сохранение на ленту в формате BINARY
// <начальный адрес>W<конечный адрес> <имя>

void MonitorDirectiveW(...) {
    if (flag_z((a = vTempMonitorAble1) |= a)) return MonitorError();
    hl = vTempMonitorParse;  // Лишняя команда
    MonitorParseChar();      // Пропустить директиву
    MonitorParseNumber();
    if (flag_c) return MonitorError();
    vTempTapeEnd = hl = bc;
    vTempTapeBegin = hl = vTempMonitorArgument1;
    hl = vTempMonitorParse;  // Лишняя команда
    MonitorParseSkip(hl);
    vTempTapeRequiredName = hl;
    return TapeWriteBinaryBlock();
}

// Директива монитора R
// Загрузка с ленты в формате BINARY
// R<имя>

void MonitorDirectiveR(...) {
    vTempTapeRequiredType = a = TAPE_BINARY;
    MonitorParseSkip();  // Пропустить директиву и пробелы
    vTempTapeRequiredName = hl;
    return TapeLoad();
}

// Распознавание введенной пользователем строки в Мониторе.
// Пропустить символ, а затем все пробелы.
// Выход: hl - адрес строки. hl необходимо сохранить в vMonitorParse.

void MonitorParseSkip(...) {
    MonitorParseChar();
    return SkipSpaces();
}

// Пропустить все пробелы в строке
// Вход: hl - адрес строки
// Выход: hl - адрес строки

void SkipSpaces(...) {
    for (;;) {
        a = *hl;
        if (a != ' ') return;
        hl++;
    }
}

// Директива монитора !
// Изменяет режим экрана 48/64 символа в ширину

void MonitorDirectiveEx(...) {
    a = vVideoTextWidth;
    if (a != 48) {
        a = 48;
    } else {
        a = 64;
    }
    vVideoTextWidth = a;
    return VideoRedrawTextScreen();
}

// Директива монитора :
// Записать значения в память
// <адрес>:<байт> <байт> <байт>...

void MonitorDirectiveSet(...) {
    hl = vMonitorArgument1;
    swap(de, hl);
    for (;;) {
        MonitorParseChar();  // Пропуск директивы или разделителя значений
        push_pop(de) {
            MonitorParseNumber();
        }
        if (flag_c) return;
        *de = a = c;
        de++;
    }
}

// Директива монитора T
// Записать текст по указанному адресу
// <адрес>G<текст>

void MonitorDirectiveT(...) {
    hl = vMonitorArgument1;
    swap(hl, de);
    MonitorParseChar();  // Пропуск директивы
    for (;;) {
        a = *hl;
        if (a == EOL) return;
        *de = a;
        de++;
        hl++;
    }
    return;
}

// Директива монитора G
// Запустить программу по указанному адресу
// <адрес>G
// G<адрес>

void MonitorDirectiveG(...) {
    GotoHl(hl = vMonitorArgument1);
}

// Директива монитора I
// Прочитать байт из порта ввода-вывода
// <порт>I

void MonitorDirectiveI(...) {
    // Первый параметр директивы I запоминается. Следующие разы его можно не писать.
    if (flag_nz((a = vTempMonitorAble1) |= a)) {
        vMonitorDirectiveIPort = a = vTempMonitorArgument1;
    }
    vTempMonitorProgramm1 = a = vMonitorDirectiveIPort;
    PrintHexByte(a);
    vPrint(a = '=');
    MonitorDirectiveIOInternal(a = OPCODE_IN);
    vTempMonitorProgramm();
    PrintHexByte(a);
    return VideoNextLineClear();
}

// Директива монитора O
// Записать байт в порт ввода-вывода
// <порт>O<значение>

void MonitorDirectiveO(...) {
    // Первый параметр директивы O запоминается. Следующие разы его можно не писать.
    if (flag_nz((a = vTempMonitorAble1) |= a)) {
        vMonitorDirectiveOPort = a = vTempMonitorArgument1;
    }
    vTempMonitorProgramm1 = a = vMonitorDirectiveOPort;
    PrintHexByte(a);
    vPrint(a = ':');
    vPrint(a = '=');
    MonitorDirectiveIOInternal(a = OPCODE_OUT);
    MonitorParseChar();
    MonitorParseNumber();
    if (flag_c) {
        VideoInverse();
        vPrint(a = '?');
        VideoNormal();
        return VideoNextLineClear();
    }
    PrintHexByte(a = c);
    VideoNextLineClear();
    return vTempMonitorProgramm(a = c);
}

// Используется директивами монитора I и O. Подготавливается програма.

void MonitorDirectiveIOInternal(...) {
    vTempMonitorProgramm0 = a;
    vTempMonitorProgramm2 = a = OPCODE_RET;
}

void MonitorParseArguments23(...) {
    MonitorParseChar();  // Пропуск директивы
    MonitorParseNumber();
    if (flag_c) {
        pop(hl);
        return MonitorError();
    }
    vTempMonitorArgument2 = hl = bc;

    MonitorParseChar();  // Пропуск разделителя
    MonitorParseNumber();
    if (flag_c) {
        pop(hl);
        return MonitorError();
    }
    bc++;
    de = bc;
    bc = hl = vTempMonitorArgument2;
    hl = vMonitorArgument1;
}

// Распознавание введенной пользователем строки в Мониторе
// Получить очередной символ
// Выход: a - символ, hl - содержимое vMonitorParse

void MonitorParseChar(...) {
    hl = vTempMonitorParse;
    a = *hl;
    if (a == EOL) return;
    hl++;
    vTempMonitorParse = hl;
}

void CharCodeToNumber(...) {  // TODO: Rewrite
    if (flag_p(Compare(a, 'A'))) goto loc_F2B0;
    if (flag_p(Compare(a, 0x3A))) goto loc_F2BA;
    if (flag_m(Compare(a, '0'))) goto loc_F2BA;
    a -= '0';
    return;

loc_F2B0:
    a &= 0x5F;
    if (flag_p(Compare(a, 0x47))) goto loc_F2BA;
    a -= '7';
    return;

loc_F2BA:
    a = 0xFF;
}

// Вывести в консоль 16-ричное число из регистровой пары HL. Четыре символа.
// Вход: hl - число

void PrintHexWord(...) {
    PrintHexByte(a = h);
    PrintHexByte(a = l);
}

// Вывести в консоль 16-ричное число из регистра A. Два символа.
// Вход: a - число

void PrintHexByte(...) {
    push_pop(a) {
        CyclicRotateRight(a, 4);
        PrintHexNibble(a);
    }
    PrintHexNibble();
}

// Вывести в консоль 16-ричное число из 4-х младших битов регистра A. Один символ.
// Вход: a - число

void PrintHexNibble(...) {
    a &= 0x0F;
    if (a < 10) {
        a += '0';
    } else {
        a += 'A' - 10;
    }
    vPrint();
}

// Директива монитора M
// Скопировать блок адресного пространства
// <адрес куда>V<адрес откуда> <конец откуда>
// V<адрес откуда> <конец откуда>

void MonitorDirectiveM(...) {
    MonitorParseArguments23();
    return MemcpyHlBcDe();
}

// Директива монитора V
// Сравнить два блока адресного пространства
// <адрес 1>V<адрес 2> <конец 2>
// V<адрес 2> <конец 2>

void MonitorDirectiveV(...) {
    MonitorParseArguments23();
    for (;;) {
        if ((a = c) == e) {
            if ((a = b) == d) return;
        }
        if ((a = *bc) != *hl) MonitorDirectiveVPrint();
        bc++;
        hl++;
    }
}

// Вывод одной строки дампа адерсного пространства

void MonitorDirectiveVPrint(...) {
    push_pop(bc, de, hl) {
        push(bc);
        push_pop(hl) {
            PrintHexWord(hl);
            vPrint(a = ':');
            PrintSpace();
        }
        PrintHexByte(a = *hl);
        PrintSpace();
        vPrint(a = '(');
        pop(hl);
        PrintHexByte(a = *hl);
        vPrint(a = ')');
        VideoNextLineClear();
    }
}

// Внутренняя функция. Запуск компьютера. Вызывается функциями InitMonitor, Init3

extern uint8_t aIskra1080Tartu[];

void Init4(...) {
    VideoNormal();
    VideoClearScreen0();
    vUnused = (a ^= a);
    vMonitorQuitOpcode = a = OPCODE_RET;
    vRst38 = a;
    Init2();
    PrintStringNewLine(hl = &aIskra1080Tartu);
}

uint8_t aIskra1080Tartu[] = {'\x1B', '=', ' ', '5', 'I', 's', 'k', 'r', 'a', ' ',    '1',
                             '0',    '8', '0', ' ', 'T', 'a', 'r', 't', 'u', '\x07', '\r'};  // TODO

// Внутренняя функция. Запуск компьютера. Вызывается функциями Init, InitCold, Init4

void Init2(...) {
    // Установка черно-белого видеорежима
    out(PORT_VIDEO_MODE_0_LOW, a);
    out(PORT_VIDEO_MODE_1_HIGH, a);

    // Выбор ПЗУ с кодом
    out(PORT_CODE_ROM, a);

    // Сброс переменных
    vVideoInverse = (a ^= a);  // Сброс графических функций

    // Подключить ОЗУ
    out(PORT_ROM_0000, a = PORT_ROM_0000__RAM);

    // Установка палитры
    out(PORT_PALETTE_3, a = PALETTE_BLUE);
    out(PORT_PALETTE_2, a = PALETTE_DARK_GREEN);
    out(PORT_PALETTE_1, a = PALETTE_WHITE);
    out(PORT_PALETTE_0, a = PALETTE_DARK_BLUE);

    // Установка стандартных функций ввода вывода в консоль.
    vPrintOpcode = a = OPCODE_CALL;
    vInputOpcode = a;
    vPrintAddress = hl = &VideoPrint;
    vInputAddress = hl = &RealInput;

    // Сброс переменных
    vVideoFontHeight10 = (a ^= a);                     // Сброс графических функций
    vVideoEscState = a;                                // Сброс функции вывода в консоль
    vVideoEscCursorState = a;                          // Сброс функции вывода в консоль
    vKeyboardCapsLock = a;                             // Сброс клавиатуры
    vKeyboardNumLock = a;                              // Сброс клавиатуры
    vVideoTextWidth = a = 64;                          // Сброс графических функций
    vKeyboardLast = a = 0xFF;                          // Сброс клавиатуры
    vKeyboardDelay = hl = 0x1FF;                       // Сброс клавиатуры
    vVideoFont = hl = FONT_ADDRESS;                    // Сброс графических функций
    vKeyboardLayout = hl = &bKeybaordEnglishLayout;    // Сброс клавиатуры
    vKeyboardLeds = a = LED_CAPS_LOCK | LED_NUM_LOCK;  // Сброс клавиатуры

    // Настройка UART. Баг. При теплой перезагрузке рабоатет некорректно.
    UartSetMode(a = UART_MODE__SPEED_3 | UART_MODE__DATA_8 | UART_MODE__STOP_1);

    // Сброс переменных
    vKeyboardF1 = a = 0x9B;       // Сброс клавиатуры
    vKeyboardF2 = a = 0x9C;       // Сброс клавиатуры
    vKeyboardF3 = a = 0x9D;       // Сброс клавиатуры
    vKeyboardShiftF1 = a = 0x97;  // Сброс клавиатуры
    vKeyboardShiftF2 = a = 0x98;  // Сброс клавиатуры
    vKeyboardShiftF3 = a = 0x99;  // Сброс клавиатуры
}

// Внутренняя функция. Запуск компьютера. Вызывается функцией Rst0.
//                                                                      /-> CP/M?
//              /---------------Init2 --------\        /-> vResetOpcode --> MonitorResetHandler ->MonitorLoop
// Rst0 -> Init --> InitCold -> Init2 -> Test -> Init3 --> InitFloppy   \-> Basic?
//              \                                      \-> Init4 -> Init2 -> BasicEntry
//               \---------> InitMonitor ----------------> Init4 -> Init2 -> MonitorLoop

void Init(...) {
    if ((a = vInited12) != 0x12) return InitCold();
    if ((a = vInited34) != 0x34) return InitCold();
    sp = STACK_ADDRESS;
    KeyboardIsCtrPressed();
    if (flag_c) {
        KeyboardIsShiftPressed();
        if (flag_c) return InitCold();
        return InitMonitor();
    }
    Init2();
    return Init3();
}

// Внутренняя функция. Запуск компьютера. Вызывается функциями InitCold и Init.

void Init3(...) {
    if ((a = vResetOpcode) == OPCODE_CALL) return vReset();

    // Если что то подключено, то загрузиться с него
    IsSomethingConnected();
    if (flag_c) return InitSomething();

    // Если контроллер дисководов подключен, то загрузиться с него
    IsFloppyConnected();
    if (flag_c) return InitFloppy();

    Init4();
    return BasicEntry();
}

// Внутренняя функция. Запуск компьютера. Вызывается функцией Init.

void MonitorResetHandler();

void InitMonitor(...) {
    Init4();

    // Кнопка "сброс" возвращает в Монитор
    vResetAddress = hl = &MonitorResetHandler;
    vResetOpcode = a = OPCODE_CALL;

    // Восстаналиваем приглашение
    vMonitorPrompt = a = 0x7F;  // Это смайлик

    return MonitorLoop();
}

// Вызывается при нажатии на клавишу "Сброс" при работе в мониторе.

void MonitorResetHandler(...) {
    sp = STACK_ADDRESS;
    vVideoCursorX = (a ^= a);
    VideoSetCursorY(a = TEXT_SCREEN_HEIGHT - 1);
    return MonitorLoop();
}

// Основной цикл монитора

void MonitorLoop(...) {
    for (;;) {
        sp = STACK_ADDRESS;
        MonitorInput();
        MonitorExecute();
    }
}

// Внутренняя функция. Запуск компьютера. Вызывается функциями Init.

void InitCold(...) {
    sp = STACK_ADDRESS;
    Init2();
    Test();
    vInited12 = hl = 0x3412;
    return Init3();
}

// Если что то подключено

void IsSomethingConnected(...) {
    a ^= a;
}

uint8_t vEmptyCheck[] = {0xFF, 0xFF, 0xFF};

// Загрузить с чего то

void InitSomething(...) {
}

uint8_t vEmptyFunction[] = {0xFF, 0xFF, 0xFF};

// Возвращает флаг C, если контроллер дисковода подключен.

void IsFloppyConnected(...) {
    a = In(PORT_TAPE_AND_IDX2);
    a &= PORT_TAPE_AND_IDX2_ID2_2;
    set_flag_c();
    if (flag_nz) return;
    invert_flag_c();
}

// Внутренняя функция. Запуск компьютера. Вызывается функцией Init3.

void InitFloppy(...) {
    return BiosBoot();
}

// Обработка прерываний.
// Эта функция вызывается, если произошло прерывание при включенном ПЗУ в адресах 0000.
// Эта функция отключает ПЗУ и повторно вызывает прерывание

void CallRamRst38Handler(...) {
    vTempRst38 = a;
    out(PORT_ROM_0000, a = PORT_ROM_0000__RAM);
    Rst(0x38);
    out(PORT_ROM_0000, a = PORT_ROM_0000__ROM);
    a = vTempRst38;
}

// Продолжение выполнения директивы монитора L
// Вход: a - кол-во строк (0 обозначает 256)

void MonitorDirectiveLInternal(...) {
    push_pop(hl, bc, de, a) {
        do {
            push_pop(a) {
                Disassembler();
                out(PORT_CODE_ROM, a);
            }
        } while (flag_nz(a--));
    }
}

// Дизассемблер

void Disassembler(...) {
    // Вывод адреса на экран
    PrintHexWord(hl = vMonitorArgument1);
    VideoPrintSpaces(d = 6);
    swap(de, hl);

    // Вариант 1. Опкод не содержит аргументов.
    hl = &bDisassemlerOpcodes1;
    // Массив содержит опкоды
    // 0xC3, 0xCD, 0xC9, 0xEB, 0x2A, 0x22, 0xFE, 0xE6,
    // 0xF6, 0xEE, 0xC6, 0xD6, 0xCE, 0xDE, 0x2F, 0x00,
    // 0xD3, 0x1F, 0x17, 0x0F, 0x07, 0xE9, 0xF9, 0x37,
    // 0x3F, 0xE3, 0x27, 0x76, 0xFB, 0xF3, 0xDB, 0x3A,
    a = *de;  // Опкод из памяти
    c = 32;   // Кол-во элементов в массиве
    out(PORT_CHARGEN_ROM, a);
    do {
        // Совпадение
        if (a == *hl) return DisassemblerPrintVariant1(de, c);
        // Следующий элемент массива
        c--;
        hl++;
    } while (flag_p);

    // Вариант MOV
    a &= 0xC0;
    if (a == 0x40) return DisassemblerMov();

    // Вариант 2. Опкод содержит аргуметы.
    hl = &bDisassemlerOpcodes2;
    // Содержимое массива:
    // 0xC7, 0xF4
    // 0xF8, 0xBC
    // 0xF8, 0xA4
    // 0xF8, 0xB4
    // 0xF8, 0xAC
    // 0xF8, 0x84
    // 0xF8, 0x94
    // 0xF8, 0x8C
    // 0xF8, 0x9C
    // 0xCF, 0x23
    // 0xCF, 0x2B
    // 0xC7, 0x24
    // 0xC7, 0x25
    // 0xC7, 0x26
    // 0xCF, 0x21
    // 0xEF, 0x1A
    // 0xEF, 0x12
    // 0xCF, 0xF5
    // 0xCF, 0xF1
    // 0xC7, 0xF2
    // 0xC7, 0xF0
    // 0xC7, 0xEF
    // 0xCF, 0x29
    c = 22;  // Размер массива - 1
    do {
        // Накладываем на опкод маску из *hl
        b = ((a = *de) &= *hl);
        // Накладываем на hl[1] маску из *hl
        a = *hl;
        hl++;
        a &= *hl;
        // Совпадение
        if (a == b) return DisassemblerVariant2(hl, de, c);
        // Следующий элемент массива
        hl++;
    } while (flag_p(c--));

    // Неизвестный опкод
    hl = &bDisassemlerUnknown;  // Содержит: 0xFF, 0x7F, 0x7F, 0x20  длина команды 1
    c = 4;                      // Длина
    DisassemblerPrint();

    return DisassemblerEnd();
}

// Внутренняя функция дизассемблера
// Вариант 2. Опкод содержит аргуметы.

void DisassemblerVariant2(...) {
    hl--;
    push_pop(hl, a) {
        hl = &bDisassemlerNames2;
        // Содержимое массива:
        // 0xC4, 0x41, 0x44, 0x20  1  DAD
        // 0xD2, 0x53, 0x54, 0x20  1  RST
        // 0xD2, 0x00, 0x00, 0x00  1  R
        // 0xCA, 0x80, 0x80, 0x00  3  J
        // 0xD0, 0x4F, 0x50, 0x20  1  POP
        // 0xD0, 0x55, 0x53, 0x48  1  PUSH
        // 0xD3, 0x54, 0x41, 0x58  1  STAX
        // 0xCC, 0x44, 0x41, 0x58  1  LDAX
        // 0xCC, 0xD8, 0xC9, 0x20  3  LXI
        // 0xCD, 0xD6, 0x49, 0x20  2  MVI
        // 0xC4, 0x43, 0x52, 0x20  1  DCR
        // 0xC9, 0x4E, 0x52, 0x20  1  INR
        // 0xC4, 0x43, 0x58, 0x20  1  DCX
        // 0xC9, 0x4E, 0x58, 0x20  1  INX
        // 0xD3, 0x42, 0x42, 0x20  1  SBB
        // 0xC1, 0x44, 0x43, 0x20  1  ADC
        // 0xD3, 0x55, 0x42, 0x20  1  SUB
        // 0xC1, 0x44, 0x44, 0x20  1  ADD
        // 0xD8, 0x52, 0x41, 0x20  1  XRA
        // 0xCF, 0x52, 0x41, 0x20  1  ORA
        // 0xC1, 0x4E, 0x41, 0x20  1  ANA
        // 0xC3, 0x4D, 0x50, 0x20  1  CMP
        DisassemblerPrintFromArray();
    }
    // Код команды
    d = a = *de;
    // Получаем маску аргуманта из массива
    a = *hl;
    Invert(a);
    c = a;
    // Получаем аргумент
    d = (a &= d);
    hl++;
    // Получаем тип аргуманта из массива
    e = ((a = *hl) &= c);
    // Выводим аргумент на экран
    DisassemblerArgumentD();
    return DisassemblerEnd();
}

// Внутренняя функция дизассемблера
// Вывод последнего аргумента, дампа и перевод строки.

void DisassemblerEnd(...) {
    // Адрес дизассемблирования
    hl = vMonitorArgument1;

    // Вывод последнего аргумента команды
    a = vTempDisassemblerSize;  // Длина команды в байтах
    if (a != 1) {
        push_pop(a) {
            VideoPrintSpaces11();

            a = '$';
            out(PORT_CODE_ROM, a);
            VideoPrint(a);
            out(PORT_CHARGEN_ROM, a);
        }
        hl++;
        if (a == 3) PrintHexByteFromHl();
        out(PORT_CHARGEN_ROM, a);
        a = *hl;
        out(PORT_CODE_ROM, a);
        PrintHexByte(a);
        out(PORT_CHARGEN_ROM, a);
        hl--;
    }

    // Вывод 16-ричного дампа
    c = a = vTempDisassemblerSize;
    VideoPrintSpaces(d = 20);

    out(PORT_CHARGEN_ROM, a);
    do {
        a = *hl;
        out(PORT_CODE_ROM, a);
        PrintHexByte(a);
        PrintSpace();
        out(PORT_CHARGEN_ROM, a);
        c--;
        hl++;
    } while (flag_nz);

    // Конец строки
    out(PORT_CODE_ROM, a);
    PrintNewLine();
    out(PORT_CHARGEN_ROM, a);

    // Адрес дизассемблирования
    vMonitorArgument1 = hl;
}

// Внутренняя функция дизассемблера
// Вариант 1. Опкод не содержит аргуметов.

void DisassemblerPrintVariant1(...) {
    hl = &bDisassemlerNames1;
    // Содержимое массива:
    // 0xD3, 0xD4, 0xC1, 0x20  3  STA
    // 0xCC, 0xC4, 0xC1, 0x20  3  LDA
    // 0xC9, 0xCE, 0x20, 0x04  2  IN \x04   TODO: Bug
    // 0xC4, 0x49, 0x20, 0x20  1  DI
    // 0xC5, 0x49, 0x20, 0x20  1  EI
    // 0xC8, 0x4C, 0x54, 0x20  1  HLT
    // 0xC4, 0x41, 0x41, 0x20  1  DAA
    // 0xD8, 0x54, 0x48, 0x4C  1  XTHL
    // 0xC3, 0x4D, 0x43, 0x20  1  CMC
    // 0xD3, 0x54, 0x43, 0x20  1  STC
    // 0xD3, 0x50, 0x48, 0x4C  1  SPHL
    // 0xD0, 0x43, 0x48, 0x4C  1  PCHL
    // 0xD2, 0x4C, 0x43, 0x20  1  RLC
    // 0xD2, 0x52, 0x43, 0x20  1  RRC
    // 0xD2, 0x41, 0x4C, 0x20  1  RAL
    // 0xD2, 0x41, 0x52, 0x20  1  RAR
    // 0xCF, 0xD5, 0x54, 0x20  2  OUT
    // 0xCE, 0x4F, 0x50, 0x20  1  NOP
    // 0xC3, 0x4D, 0x41, 0x20  1  CMA
    // 0xD3, 0xC2, 0x49, 0x20  2  SBI
    // 0xC1, 0xC3, 0x49, 0x20  2  ACI
    // 0xD3, 0xD5, 0x49, 0x20  2  SUI
    // 0xC1, 0xC4, 0x49, 0x20  2  ADI
    // 0xD8, 0xD2, 0x49, 0x20  2  XRI
    // 0xCF, 0xD2, 0x49, 0x20  2  ORI
    // 0xC1, 0xCE, 0x49, 0x20  2  ANI
    // 0xC3, 0xD0, 0x49, 0x20  2  CPI
    // 0xD3, 0xC8, 0xCC, 0x44  3  SHLD
    // 0xCC, 0xC8, 0xCC, 0x44  3  LHLD
    // 0xD8, 0x43, 0x48, 0x47  1  XCHG
    // 0xD2, 0x45, 0x54, 0x20  1  RET
    // 0xC3, 0xC1, 0xCC, 0x4C  3  CALL
    // 0xCA, 0xCD, 0xD0, 0x20  3  JMP
    DisassemblerPrintFromArray(hl, c);

    return DisassemblerEnd();
}

// Внутренняя функция дизассемблера
// Дизассемблирование команды MOV

void DisassemblerMov(...) {
    // Вывод опкода MOV
    c = 4;                  // Размер элемента массива
    hl = &bDisassemlerMov;  // 0xCD, 0x4Fh, 0x56h, 0x20  MOV  длина команды 1
    DisassemblerPrint(hl, c);

    // Первый аргумент
    a = *de;
    push_pop(de) {
        e = 4 << 3;  // Массив BCDEHLMA
        c = 0x38;    // Маска аргумента
        a &= c;      // Аргумент
        DisassemblerArgumentA(a, c);
    }

    // Второй аргумент
    a = *de;
    c = 7;   // Маска аргумента
    a &= c;  // Аргумент
    e = 4;   // Массив BCDEHLMA
    DisassemblerArgumentA(a, c);

    return DisassemblerEnd();
}

// Внутренняя функция дизассемблера
// Дизассемблирование аргумента команды
// Вход: E - номер массива, D - элемент массива, C - маска

void DisassemblerArgumentD(...) {
    return DisassemblerArgumentA(a = d);
}

// Внутренняя функция дизассемблера
// Дизассемблирование аргумента команды
// Вход: E - номер массива, A - элемент массива, C - маска

void DisassemblerArgumentA(...) {
    d = CyclicRotateRight(a);
    e = CyclicRotateRight(a = e);
    c = CyclicRotateRight(a = c);
    if (flag_nc) return DisassemblerArgumentD();

    // Откатываем последний сдвиг
    c = CyclicRotateLeft(a = d);  // Элемент массива
    CyclicRotateLeft(a = e, 1);   // Номер массива

    push_pop(de) {
        hl = &bDisassemlerArguments - 2;
        // Массив содержит указатели на массивы:
        // 1) 1, B, D
        // 2) 2, B, D, H, SP
        // 3) 3, B, D, H, PSW
        // 4) 1, B, C, D, E, H, L, M, A
        // 5) 1, 0, 1, 2, 3, 4, 5, 6, 7
        // 6) 2, NZ, Z, NC, C, PO, PE, P, M

        // Для массивов 1 - 5 отступаем до 11 колонки.
        push_pop(a) {
            if (a < 6) VideoPrintSpaces11();
        }

        // Получаем адрес массива
        do {
            hl++;
            hl++;
        } while (flag_nz(a--));
        out(PORT_CHARGEN_ROM, a);
        e = *hl;
        hl++;
        d = *hl;
        swap(de, hl);
    }
    return DisassemblerPrintFromArray();
}

// Внутренняя функция дизассемблера.
// Вывести на экран текст из элемента C массива HL, записать в vTempDisassemblerSize длину команды
// Длина команды закодирована 7-ыми битами в имени
// Вход: HL - массив, C - номер элемента

void DisassemblerPrintFromArray(...) {
    // Вычислить в HL адрес текстовой строки, в C длину строки
    push_pop(de) {
        d = 0;
        e = *hl;
        hl++;

        a = c;
        while (flag_nz(a &= a)) {
            hl += de;
            a--;
        }

        c = e;
    }
    return DisassemblerPrint();
}

// Внутренняя функция дизассемблера.
// Вывести на экран текст из HL длиной C, записать в vTempDisassemblerSize длину команды
// Длина команды закодирована 7-ыми битами в имени
// Вход: hl - адрес строки, c - длина строки
// Выход: b - длина команды

void DisassemblerPrint(...) {
    push_pop(bc) {
        b = 0;
        do {
            a = *hl;
            if (flag_m(a &= a)) DisassemblerPrintInternal();
            a &= 0x7F;
            out(PORT_CODE_ROM, a);
            VideoPrint(a);
            out(PORT_CHARGEN_ROM, a);
            c--;
            hl++;
        } while (flag_nz);

        if (flag_nz((a = b) &= a)) {
            vTempDisassemblerSize = a;
        }
    }
}

// Внутренняя функция дизассемблера. Используется функцией DisassemblerPrint.

void DisassemblerPrintInternal(...) {
    if ((a = c) == 4) {  // Если осталось 4 символа
    loc_F5D2:
        b++;  // Увеличить длину
    loc_F5D3:
        a = *hl;  // Востановить A
        return;
    }
    if (flag_nz((a = b) &= a)) goto loc_F5D2;  // Только если длина команды больше 0
    goto loc_F5D3;
}

// Выводить пробелы, пока положение курсора по оси X меньше 11

void VideoPrintSpaces11(...) {
    d = 11;
    return VideoPrintSpaces();
}

// Выводить пробелы, пока положение курсора по оси X меньше D
// Вход: D - положение курсора по оси X

void VideoPrintSpaces(...) {
    for (;;) {
        a = vVideoCursorX;
        if (a == d) return;
        out(PORT_CODE_ROM, a);
        if (flag_nc) break;
        PrintSpace();
    }
    return VideoPrint(a = ',');
}

// Вывести в консоль 16-ричное число из HL + 1. Два символа.
// Вход: HL - адрес

void PrintHexByteFromHl(...) {
    hl++;
    a = *hl;
    hl--;
    out(PORT_CODE_ROM, a);
    return PrintHexByte(a);
}

// Получить символ нажатой клавиши с ожиданием.
// Функция:
// - Перемещает курсор по экрану при нажатии на стрелки
// - Обрабатывает нажатие клавиш NUM LOCK, CAPS LOCK, RUS, LAT, COP
// - Заменяет скан-коды правой клавиатуры в зависимости от нажатия NUM LOCK
// - Заменяет коды клавиш на F1 - F3  на коды из переменных vKeyboardF?, vKeyboardShiftF?
// - Заменяет строчные/заглавные буквы если нажат CAPS LOCK
// Вызываемая ей функция:
// - Сканирует клавиатуру
// - Заменяет некоторые скан-коды на символы.
// - Обрабатывает нажатие клавиши SHIFT, CTL   TODO: Узнать 3-ю клавишу
// - Обеспечивает задержки перед первым и последующими повторами
// - Рисует мигающий курсор
// Вход: нет
// Выход: a - код символа, регистры bc, de, hl сохраняются

void RealInput(...) {
    RealInput2();

    // Обработка клавиши NUM LOCK
    if (a == KEY_NUM_LOCK) {
        a = vKeyboardNumLock;
        Invert(a);
        vKeyboardNumLock = a;
        vKeyboardLeds = ((a = vKeyboardLeds) ^= LED_NUM_LOCK);
        return RealInput();
    }

    // Замена скан кодов клавиш F1 - F3 на коды из переменных vKeyboardF?, vKeyboardShiftF?.
    push_pop(hl) {
        vTempInputPrint = a;
        KeyboardReplaceFKeys();
        a = *hl;
    }

    // Замена скан-кодов правой клавиатуры на цифры если нажат NUM LOCK
    push(a);
    if (flag_nz((a = vKeyboardNumLock) |= a)) {
        pop(a);
        if (a == KEY_EXT_POINT) {
            a = '.';
            goto RealInput1;  // TODO: Optimize
        }
        if (a < KEY_EXT_0) goto RealInput1;       // TODO: Optimize
        if (a >= KEY_EXT_9 + 1) goto RealInput1;  // TODO: Optimize
        a -= KEY_EXT_0 - '0';
    } else {
        pop(a);
    }
RealInput1:

    // Перемещение курсора по экрану при нажатии на стрелки
    if (a == KEY_UP) {
        VideoMoveCursorUp();
        return RealInput();
    }
    if (a == KEY_DOWN) {
        VideoMoveCursorDown();
        return RealInput();
    }
    if (a == KEY_LEFT) {
        VideoMoveCursorLeft();
        return RealInput();
    }
    if (a == KEY_RIGHT) {
        VideoMoveCursorRight();
        return RealInput();
    }
    if (a == KEY_LEFT_DOWN) {
        VideoMoveCursorDown();
        VideoMoveCursorLeft();
        return RealInput();
    }
    if (a == KEY_RIGHT_DOWN) {
        VideoMoveCursorDown();
        VideoMoveCursorRight();
        return RealInput();
    }
    if (a == KEY_LEFT_UP) {
        VideoMoveCursorUp();
        VideoMoveCursorLeft();
        return RealInput();
    }
    if (a == KEY_RIGHT_UP) {
        VideoMoveCursorUp();
        VideoMoveCursorRight();
        return RealInput();
    }

    // Обработка клавиши COP
    if (a == KEY_COP) return VideoGetCharCodeUnderCursor();

    // Правая точка при не нажатом NUM LOCK работает как COP
    if (a == KEY_EXT_POINT) return VideoGetCharCodeUnderCursor();

    // Правая 5 при не нажатом NUM LOCK возвращает код 0x13
    if (a == KEY_EXT_5) {
        a = 0x13;
    }

    // Обработка клавиш CAPS LOCK, RUS, LAT
    if (a == KEY_CAPS_LOCK) {
        a = vKeyboardCapsLock;
        Invert(a);
        vKeyboardCapsLock = a;
        vKeyboardLeds = ((a = vKeyboardLeds) ^= LED_CAPS_LOCK);
        return RealInput();
    }
    if (a == KEY_RUS) {
        KeyboardSetRussianLayout();
        return RealInput();
    }
    if (a == KEY_LAT) {
        KeyboardSetEnglishLayout();
        return RealInput();
    }

    // Правая 0 при не нажатом NUM LOCK возвращает код 0x8
    if (a == KEY_EXT_0) {
        a = 8;
        return;
    }

    // Замена строчных/заглавных букв если нажат CAPS LOCK
    push(a);
    if (flag_nz((a = vKeyboardCapsLock) |= a)) {
        pop(a);
        if (a < 'A') return;
        if (a < 'Z' + 1) goto RealInputEnglishChar;
        if (a < 'a') return;
        if (a < 'z' + 1) goto RealInputEnglishChar;
        if (a < 0xB0) return;
        if (a >= 0xF0) return;
        a += 0x10;
        a ^= 0x20;
        a -= 0x10;
        return;
    RealInputEnglishChar:
        a ^= 0x20;
        return;
    }
    pop(a);
}

// Включить русскую раскладку клавиатуры

void KeyboardSetRussianLayout(...) {
    push(hl);
    return KeyboardSetLayout(hl = &bKeybaordRussianLayout);
}

// Таблица из ПЗУ компьютера
// 36 6   D3 г   DE о   EC ь   37 7   E8 ш   DB л   D1 б
// 35 5   DD н   E0 р   E2 т   38 8   E9 щ   D4 д   EE ю
// 34 4   D5 е   DF п   D8 и   39 9   D7 з   D6 ж   F1 ё
// 8D     8C     8B     FF     8F      8     8E     20
// 33 3   DA к   D0 а   DC м   30 0   E5 х   ED э   2C ,
// 32 2   E3 у   D2 в   E1 с   2D -   EA ъ   3A :   2E .
// 31 1   8A     E4 ф   EF я   5E ^   2F /   3B ;   80
// FF     E6 ц   EB ы   E7 ч   7F     87     84     81
// 0D     D9 й    9     FF     5C \   88     85     82
// 92     FF     90     91     1B     89     86     83

// 26 &   B3 Г   BE О   CC Ь   27 '   C8 Ш   BB Л   B1 Б
// 25 %   BD Н   C0 Р   C2 Т   28 (   C9 Щ   B4 Д   CE Ю
// 24 $   B5 Е   BF П   B8 И   29 )   B7 Х   B6 Ж   A1 Ё
// 8D     8C     8B     FF     8F      8     8E     20
// 23 #   BA К   B0 А   BC М   5F _   C5 Х   CD Э   3C <
// 22 "   C3 У   B2 В   C1 С   3D =   CA Ъ   2A *   3E >
// 21 !   8A     C4 Ф   CF Я   7E ~   3F ?   2B +   80
// FF     C6 Ц   CB Ы   C7 Ч   7F     87     84     81
// 0D     B9 Й    9     FF     7C |   88     85     82
// 95     FF     93     94     1B     89     86     83

// Внутренняя функция. Используется функциями KeyboardSetRussianLayout, KeyboardSetEnglishLayout.

void KeyboardSetLayout(...) {
    vKeyboardLayout = hl;
    pop(hl);
}

// Включить английскую раскладку клавиатуры

void KeyboardSetEnglishLayout(...) {
    push(hl);
    return KeyboardSetLayout(hl = &bKeybaordEnglishLayout);
}

// Таблица из ПЗУ компьютера
// 36 6   75 u   6A j   6D m   37 7   69 i   6B k   60 `
// 35 5   79 y   68 h   6E n   38 8   6F o   6C l   40 @
// 34 4   74 t   67 g   62 b   39 9   70 p   5B [   9A
// 8D     8C     8B     FF     8F      8     8E     20
// 33 3   72 r   66 f   76 v   30 0   7B {   5D ]   2C ,
// 32 2   65 e   64 d   63 c   2D -   7D }   3A :   2E .
// 31 1   8A К   61 a   7A z   5E ^   2F /   3B ;   80
// FF     77 w   73 s   78 x   7F     87 З   84 Д   81
// 0D     71 q    9     0F     5C \   88 И   85 Е   82
// 92     FF     90     91     1B     89     86     83

// 26 &   55 U   4A J   4D M   27 '   49 I   4B K   60 `
// 25 %   59 Y   48 H   4E N   28 (   4F O   4C L   40 @
// 24 $   54 T   47 G   42 B   29 )   50 P   5B [   96
// 8D     8C     8B     FF     8F      8     8E     20
// 23 #   52 R   46 F   56 V   5F _   7B {   5D ]   3C <
// 22 "   45 E   44 D   43 C   3D =   7D }   2A *   3E >
// 21 !   8A К   41 A   5A Z   7E ~   3F ?   2B +   80
// FF     57 W   53 S   58 X   7F     87     84     81
// 0D     51 Q    9     FF     7C |   88     85     82
// 95     FF     93     94     1B     89     86     83

// Внутренняя функция. Используется функцией RealInput.
// Замена скан кодов клавиш F1 - F3 на коды из переменных vKeyboardF?, vKeyboardShiftF?.

void KeyboardReplaceFKeys(...) {
    hl = &vTempInputPrint;
    if (a < KEY_F1) return;  // TODO: Что за код?
    if (a >= KEY_SHIFT_F3 + 1) return;
    a -= KEY_F1;
    push_pop(de) {
        e = a;
        d = 0;
        (hl = &vKeyboardF1) += de;
    }
}

// Перевод строки, а затем ввод директивы монитора пользователем

void MonitorInputNextLine(...) {
    VideoNextLine();
    return MonitorInput();
}

// Ввод директивы монитора пользователем

void MonitorInput(...) {
    // Вывести приглашение
    vPrint(a = vMonitorPrompt);

    push(hl);
    hl = &vMonitorString;
    do {
    MonitorInputRetry:
        RealInput();
        if (a == 8) {
            MonitorInputBackspace();
            goto MonitorInputRetry;
        }
        if (a < ' ') {
            if (a == 0x18) return MonitorInputError();
            if (a == 0x0A) {
                a = EOL;
            }
            if (a != EOL) goto MonitorInputRetry;
            *hl = a;
            VideoNextLineClear();
            vMonitorStringLength = a = l;
            pop(hl);
            return;
        }
        *hl = a;
        hl++;
        vPrint(a);
    } while ((a = l) != 0xC0);
    return MonitorInputError();
}

// Внутренняя функция. Вызывается функцией MonitorInput если пользователь отменил ввод.

void MonitorInputError(...) {
    vPrint(a = 0x5C);  // TODO: Backslash
    vPrint(a = 7);
    VideoNextLine();
    pop(hl);
    return MonitorInput();
}

// Выключить инверсию при выводе текста
// Функция сохраняет все регистры

void VideoNormal(...) {
    push(a);
    return VideoInverseInternal(a ^= a);
}

// Включить инверсию при выводе текста
// Функция сохраняет все регистры

void VideoInverse(...) {
    push(a);
    return VideoInverseInternal(a = 0xFF);
}

// Используется функциями VideoNormal и VideoInverse

void VideoInverseInternal(...) {
    vVideoInverse = a;
    pop(a);
}

// Включить режим 48 символов в строке
// Функция сохраняет все регистры

void VideoSetMode48(...) {
    push(a);
    return VideoSetModeInternal(a = 48);
}

// Включить режим 64 символа в строке
// Функция сохраняет все регистры

void VideoSetMode64(...) {
    push(a);
    return VideoSetModeInternal(a = 64);
}

// Внутренняя функция. Используется функциями VideoSetMode48 и VideoSetMode64

void VideoSetModeInternal(...) {
    vVideoTextWidth = a;
    VideoRedrawTextScreen();
    pop(a);
}

// Высота символа в установленном знакогенераторе 8 пикселей
// Функция сохраняет все регистры

void VideoSetFontHeight8(...) {
    push(a);
    a ^= a;
    return VideoSetFontHeightInternal();
}

// Высота символа в установленном знакогенераторе 10 пикселей
// Функция сохраняет все регистры

void VideoSetFontHeight10(...) {
    push(a);
    a = 0xFF;
    return VideoSetFontHeightInternal();
}

// Внутренняя функция. Используется функциями VideoSetFontHeight8 и VideoSetFontHeight10

void VideoSetFontHeightInternal(...) {
    vVideoFontHeight10 = a;
    pop(a);
}

void VideoSetCursorX(...) {
    push_pop(de) {
        d = a;
        a = vVideoTextWidth;
        a--;
        Compare(a, d);
        a = d;
    }
    if (flag_c) return;

    push(de, hl);
    vVideoCursorX = a;
    e = a;
    d = 0;
    l = a = vVideoCursorY;
    h = 0;
    MultipleHlBy64();
    return VideoSetCursorInternal();
}

void VideoSetCursorY(...) {
    if (a >= TEXT_SCREEN_HEIGHT) return;
    push(de, hl);
    vVideoCursorY = a;
    l = a;
    h = 0;
    MultipleHlBy64();
    e = a = vVideoCursorX;
    d = 0;
    return VideoSetCursorInternal();
}

void VideoSetCursorInternal(...) {
    hl += de;
    hl += (de = TEXT_SCREEN_ADDRESS);
    vVideoCursorAddress = hl;
    pop(de, hl);
}

// Вывод в консоль
// Вход: a - код

void VideoPrint(...) {
    push_pop(a) {
        if (flag_nz((a = vVideoEscCursorState) |= a)) return VideoPrintEscCursor();
        if (flag_z((a = vVideoEscState) |= a)) return VideoPrintNoEsc();
        vVideoEscState = (a ^= a);
    }
    if (a == 0x2A) return VideoClearScreen0();
    if (a == 0x54) return VideoClearRight();
    if (a == 0x29) return VideoNormal();
    if (a == 0x28) return VideoInverse();
    if (a != 0x3D) return;
    vVideoEscCursorState = a = 2;
}

// Обработка 3 и 4 ого символа ESC-последовательности устанавливающей положение курсора
// Последовательность: 0x1B, 0x3D, Y + 0x20, X + 0x20

void VideoPrintEscCursor(...) {
    // Тут A = vVideoEscCursorState
    if (a == 2) {
        a--;
        vVideoEscCursorState = a;
        pop(a);
        a -= 0x20;
        if (a >= TEXT_SCREEN_HEIGHT) return;
        vVideoCursorY = a;
        return;
    }
    vVideoEscCursorState = (a ^= a);
    pop(a);
    a -= 0x20;
    return VideoSetCursorX(a);
}

void VideoPrintNoEsc(...) {
    pop(a);
    if (a == 0x1B) {
        vVideoEscState = a = 0xFF;
        return;
    }
    if (a >= 0x20) {
        VideoDrawChar(a);
        return VideoMoveCursorRight2();
    }
    if (a == EOL) return VideoNextLine();
    if (a == 0x07) return Beep();
    if (a == 0x08) return VideoMoveCursorLeft();
    if (a == 0x0B) return VideoMoveCursorUp();
    if (a == 0x0C) return VideoMoveCursorRight();
    if (a == 0x1E) return VideoMoveCursorLeftTop();
}

void VideoClearRightInternal(...) {
    push_pop(bc) {
        b = a = vVideoCursorX;
        b = ((a = vVideoTextWidth) -= b);
        if (flag_nz) {
            VideoMoveCursorLeft();
            do {
                VideoMoveCursorRight2();
                VideoDrawChar(a = ' ');
            } while (flag_nz(b--));
        }
    }
}

void VideoClearRight(...) {
    a = vVideoCursorX;
    push_pop(a) {
        VideoClearRightInternal();
    }
    return VideoSetCursorX();
}

void VideoNextLineClear(...) {
    VideoClearRightInternal();
    return vPrint(a = EOL);
}

extern uint8_t cVideoTextRowAddess[];

void VideoDrawChar(...) {
    push(hl, de, bc, a);

    // Сохранить код символа
    vTempInputPrint = (a -= 0x20);

    // Получить в E адрес текстовой строки в видеопамяти
    bc = &cVideoTextRowAddess;
    l = a = vVideoCursorY;
    h = 0;
    hl += bc;
    e = *hl;

    // Вычислить в HL адрес символа в знакогенераторе
    // В регистре C высоту символа в знакогенераторе
    bc = hl = vVideoFont;
    l = a = vTempInputPrint;
    h = 0;
    hl += hl += hl += hl;
    hl += bc;
    c = 8;
    if (flag_nz((a = vVideoFontHeight10) |= a)) {
        c = a = vTempInputPrint;
        b = 0;
        hl += bc;
        hl += bc;
        c = 10;
    }

    // Если в стрке 64 символа, то продолжаем в другой функции.
    if ((a = vVideoTextWidth) == 64) {
        vTempVideoInverse = a = vVideoInverse;
        vTempVideoCursorX = a = vVideoCursorX;
        vTempVideoFontHeight10 = a = vVideoFontHeight10;
        return VideoDrawChar64();
    }

    // Получить в D адрес текстового столбца в видеопамяти.
    b = a = vVideoCursorX;
    d = ((a = 0xFF) -= b);

    // Скопировать символ из знакогенератора в видеопамять.
    b = a = vVideoInverse;
    do {
        *de = ((a = *hl) ^= b);
        de--;
        hl++;
    } while (flag_nz(c--));
    if (flag_z((a = vVideoFontHeight10) |= a)) {
        *de = a = vVideoInverse;
        de--;
        *de = a;
    }
    return VideoDrawCharEnd();
}

void VideoDrawCharEnd(...) {
    pop(a);
    hl = vVideoCursorAddress;
    *hl = a;
    pop(hl, de, bc);
}

// Переместить курсор вправо

void VideoMoveCursorRight2(...) {
    push_pop(hl) {
        hl = vVideoCursorAddress;
        hl++;
        vVideoCursorAddress = hl;

        a = vVideoCursorX;
        a++;
        hl = &vVideoTextWidth;
        Compare(a, *hl);
    }
    if (flag_nz) return VideoSetCursorXInternal();
    return VideoNextLine();
}

// Перевод строки
// Сохраняет: de, hl

void VideoNextLine(...) {
    push_pop(de, hl) {
        a = vVideoCursorY;
        a++;
        if (a == TEXT_SCREEN_HEIGHT) {
            VideoScrollUp();
            a = TEXT_SCREEN_HEIGHT - 1;
        }
        vVideoCursorY = a;

        l = a;
        h = 0;
        MultipleHlBy64();
        hl += (de = TEXT_SCREEN_ADDRESS);
        vVideoCursorAddress = hl;

        WaitIfKeyPressed();
        a ^= a;
    }
    return VideoSetCursorXInternal();
}

void VideoSetCursorXInternal(...) {
    vVideoCursorX = a;
}

void PrintNewLine(...) {
    return vPrint(a = EOL);
}

void PrintSpace(...) {
    return vPrint(a = ' ');
}

uint8_t data7[] = {0x3E, 0x20, 0xCD, 0xB0, 0xF8, 0xC3, 0x2E, 0xF9};  // TODO

void WaitIfKeyPressed(...) {
    KeyboardGet();
    if (flag_m) return;

    if (a != 0x20) {
        if (a != 0x13) {
            if (a != 0x85) return;
        }
    }

    push_pop(bc) {
        b = a;
        do {
            KeyboardGet();
        } while (flag_z(a ^= b));
    }

    do {
        KeyboardGet();
    } while (flag_m);
}

// Очистить черно-белый экран и переместить курсор в координаты 0, 0
// Инверсия влияет на очистку экрана.
// Функция сохраняет все регистры.

void VideoClearScreen0(...) {
    push_pop(hl, de, bc, a) {
        a = vVideoInverse;
        VideoClearScreenInternal(b = a, c = a, de = SCREEN_0_ADDRESS + SCREEN_SIZE);
        MemsetHlBDe(hl = TEXT_SCREEN_ADDRESS, de = TEXT_SCREEN_WIDTH * TEXT_SCREEN_HEIGHT, b = ' ');
        VideoMoveCursorLeftTop();
    }
}

// Заполняет область памяти DE-2..DE-0x3000 словом BC

void VideoClearScreenInternal(...) {
    vTempSP = ((hl = 0) += sp);
    swap(hl, de);
    sp = hl;
    d = SCREEN_WIDTH / BIT_PER_BYTE;
    do {
        e = SCREEN_HEIGHT / 16;  // 16 это количество push
        do {
            push(bc, bc, bc, bc, bc, bc, bc, bc);
        } while (flag_nz(e--));
    } while (flag_nz(d--));
    sp = hl = vTempSP;
}

// Очистить дополнительную видеоплоскость.
// Инверсия влияет на очистку экрана.
// Функция сохраняет все регистры.

void VideoClearScreen1(...) {
    push_pop(hl, de, bc, a) {
        a = vVideoInverse;
        VideoClearScreenInternal(b = a, c = a, de = SCREEN_1_ADDRESS + SCREEN_SIZE);
    }
}

// Переместить курсор в левый верхний угол экрана
// Функция сохраняет регистры BC, DE, HL

void VideoMoveCursorLeftTop(...) {
    push_pop(hl) {
        a ^= a;
        vVideoCursorX = a;
        vVideoCursorY = a;
        vVideoCursorAddress = hl = TEXT_SCREEN_ADDRESS;
    }
}

// Заполнить память от hl до de - 1 байтом b

void MemsetHlBDe(...) {
    for (;;) {
        if (flag_z((a = d) |= e)) return;
        *hl = b;
        hl++;
        de--;
    }
}

// Скопировать память от bc до de - 1 в hl

void MemcpyHlBcDe(...) {
    for (;;) {
        if ((a = c) == e) {
            if ((a = b) == d) return;
        }
        *hl = a = *bc;
        bc++;
        hl++;
    }
}

// Умножить HL на 64
// Функция сохраняет регистры A, BC, DE

void MultipleHlBy64(...) {
    hl += hl += hl += hl += hl += hl += hl;
}

// Адрес строки текста (0 - 24) в графической памяти

uint8_t cVideoTextRowAddess[] = {0xFF - 0 * 10,  0xFF - 1 * 10,  0xFF - 2 * 10,  0xFF - 3 * 10,  0xFF - 4 * 10,
                                 0xFF - 5 * 10,  0xFF - 6 * 10,  0xFF - 7 * 10,  0xFF - 8 * 10,  0xFF - 9 * 10,
                                 0xFF - 10 * 10, 0xFF - 11 * 10, 0xFF - 12 * 10, 0xFF - 13 * 10, 0xFF - 14 * 10,
                                 0xFF - 15 * 10, 0xFF - 16 * 10, 0xFF - 17 * 10, 0xFF - 18 * 10, 0xFF - 19 * 10,
                                 0xFF - 20 * 10, 0xFF - 21 * 10, 0xFF - 22 * 10, 0xFF - 23 * 10, 0xFF - 24 * 10};

// Звуковой сигнал
// Функция сохраняет регистры BC, DE, HL

void Beep(...) {
    push_pop(hl, bc) {
        bc = 255;
        do {
            out(PORT_TAPE_OUT, a);
            hl = 31;
            do {
                hl--;
            } while (flag_nz((a = h) |= l));
            bc--;
        } while (flag_nz((a = b) |= c));
    }
}

// Получить символ или скан-код нажатой клавиши с ожиданием.
// Функция:
// - Не перемещает курсор по экрану при нажатии на стрелки
// - Не обрабатывает нажатие клавиш NUM LOCK, CAPS LOCK, RUS, LAT, COP
// - Не заменяет скан-коды правой клавиатуры в зависимости от нажатия NUM LOCK
// - Не заменяет коды клавиш на F1 - F3  на коды из переменных vKeyboardF?, vKeyboardShiftF?
// - Не заменяет строчные/заглавные буквы если нажат CAPS LOCK
// - Рисует мигающий курсор
// Вызываемая ей функция:
// - Сканирует клавиатуру
// - Заменяет некоторые скан-коды на символы.
// - Обрабатывает нажатие клавиши SHIFT, CTL   TODO: Узнать 3-ю клавишу
// - Обеспечивает задержки перед первым и последующими повторами
// Вход: нет
// Выход: a - код символа, регистры bc, de, hl сохраняются

void RealInput2(...) {
    push_pop(hl, de, bc) {
        d = a = vVideoInverse;

        for (;;) {
            a = vVideoInverse;
            Invert(a);
            vVideoInverse = a;

            bc = 0x1FF;
            VideoDrawChar(a = *(hl = vVideoCursorAddress));
            do {
                bc--;
                KeyboardGet();
                if (a != 0xFF) goto RealInput2Exit;
            } while (flag_nz((a = b) |= c));
        }
    RealInput2Exit:
        push_pop(a) {
            vVideoInverse = a = d;
            VideoDrawChar(a = *(hl = vVideoCursorAddress));
        }
    }
}

// Переместить курсор вверх

void VideoMoveCursorUp(...) {
    a = vVideoCursorY;
    a--;
    return VideoSetCursorY(a);
}

// Переместить курсор вниз.
// Если курсор находится в последней строке, то происходит прокрутка экрана.

void VideoMoveCursorDown(...) {
    a = vVideoCursorY;
    a++;
    if (a != TEXT_SCREEN_HEIGHT) return VideoSetCursorY(a);

    a = vVideoCursorX;
    push_pop(a) {
        VideoNextLine();
        vVideoCursorY = a = TEXT_SCREEN_HEIGHT - 1;
    }
    return VideoSetCursorX(a);
}

// Переместить курсор влево.

void VideoMoveCursorLeft(...) {
    // Если курсор находится не в крайней левой колонке, то курсор перемещается влево.
    a = vVideoCursorX;
    if (flag_nz(a |= a)) {
        a--;
        return VideoSetCursorX(a);
    }

    // Если курсор находится в левом верхнем углу экрана, то ничего не происходит.
    a = vVideoCursorY;
    if (flag_z(a |= a)) return;

    // Если курсор находится в крайней левой колонке, то курсор перемещается
    // в крайнюю правую колонку и на строку выше.
    a--;
    vVideoCursorY = a;

    a = vVideoTextWidth;
    a--;
    return VideoSetCursorX(a);
}

// Переместить курсор вправо

void VideoMoveCursorRight(...) {
    // Если курсор находится не в крайней правой колонке, то курсор перемещается вправо.
    push_pop(bc) {
        b = a = vVideoTextWidth;
        a = vVideoCursorX;
        a++;
        Compare(a, b);
    }
    if (flag_nz) return VideoSetCursorX(a);

    // Иначе курсор перемещается в крайнюю левую колонку.
    // Если курсор находится в последней строке, то происходит прокрутка
    // экрана, иначе курсор перемещается на строку ниже.
    vVideoCursorX = (a ^= a);
    return VideoMoveCursorDown();
}

// Получить код символа под курсором

void VideoGetCharCodeUnderCursor(...) {
    push_pop(hl) {
        a = *(hl = vVideoCursorAddress);
    }
}

// Внутренняя функция.
// Вызывается из MonitorInput, когда пользователь нажимает клавишу влево.

void MonitorInputBackspace(...) {
    hl--;
    if ((a = (intptr_t(&vMonitorString - 1) & 0xFF)) == l) {
        if ((a = intptr_t(&vMonitorString - 1) >> 8) == h) {
            pop(a);
            return MonitorInputError();
        }
    }
    VideoMoveCursorLeft();
}

// Перерисовать все символы на черно-белом графическом экране по информации из текстового экрана (буферу)
// Функция сохраняет регистр BC
// Инверсия не сохраняется. Инверсия влияет на работу этой функции.

void VideoRedrawTextScreen(...) {
    push_pop(bc) {
        VideoMoveCursorLeftTop();
        b = TEXT_SCREEN_HEIGHT;
        do {
            c = a = vVideoTextWidth;
            do {
                VideoGetCharCodeUnderCursor();
                VideoPrint(a);
            } while (flag_nz(c--));
        } while (flag_nz(b--));
    }
}

// Прокрутить на одну строку вверх текстовый и черно-белый экран

void VideoScrollUp(...) {
    push_pop(hl, de, bc) {
        VideoScrollUp0();
        // Прокрутить на одну строку вверх текстовый экран без очистки нижней строки
        MemcpyHlBcDe(hl = TEXT_SCREEN_ADDRESS, bc = TEXT_SCREEN_ADDRESS + TEXT_SCREEN_WIDTH,
                     de = TEXT_SCREEN_ADDRESS + TEXT_SCREEN_WIDTH * TEXT_SCREEN_HEIGHT);
        // Очистить нижнюю строку
        MemsetHlBDe(hl = TEXT_SCREEN_ADDRESS + TEXT_SCREEN_WIDTH * (TEXT_SCREEN_HEIGHT - 1), de = TEXT_SCREEN_WIDTH,
                    b = ' ');
    }
}

// Прокрутить на одну строку вверх графический черно-белый экран

void VideoScrollUp0(...) {
    // Прокрутить без очистки нижней строки
    Call0000(hl = &VideoCopy0Up);

    // Очистить нижнюю строку
    vTempSP = ((hl = 0) += sp);
    hl = 0xFF10;
    b = a = vVideoInverse;
    c = a;
    a = 48;
    do {
        sp = hl;
        push(bc, bc, bc, bc, bc, bc, bc, bc);
        (hl = -240) += sp;
    } while (flag_nz(a--));
    sp = hl = vTempSP;
}

// Вызвать функцию по адресу HL и подключить ПЗУ в адреса 0000..00FF на время выполнения этой функции.
// вход: hl - адрес функции

void Call0000EnableRom();
void Call0000End();

void Call0000(...) {
    vTempCall0000 = hl;

    hl = &Call0000EnableRom;
    vTempVideoRom = (a ^= a);
    if (flag_nz((a = vTempVideoRom) |= a)) {
        hl = &Call0000End;
    }
    push(hl);

    hl = vTempCall0000;
    Enable0000Rom();
    GotoHl();
}

// Внутренняя функция. Используется функцией Call0000.

void Call0000EnableRom(...) {
    Enable0000Ram();
    return Call0000End();
}

// Внутренняя функция. Используется функцией Call0000.

void Call0000End(...) {
}

// Подключить ПЗУ к адресам 0 - 0FFh
// Функция сохрнаяет все регистры

void Enable0000Rom(...) {
    push(a);
    return Enable0000Internal(a = PORT_ROM_0000__ROM);
}

// Внутренняя функция. Используется функциями Enable0000Rom, Enable0000Ram

void Enable0000Internal(...) {
    out(PORT_ROM_0000, a);
    pop(a);
}

// Подключить ОЗУ к адресам 0 - 0FFh
// Функция сохрнаяет все регистры

void Enable0000Ram(...) {
    push(a);
    return Enable0000Internal(a = PORT_ROM_0000__RAM);
}

// Таблица из ПЗУ компьютера
// 36 6   75 u   6A j   6D m   37 7   69 i   6B k   60 `
// 35 5   79 y   68 h   6E n   38 8   6F o   6C l   40 @
// 34 4   74 t   67 g   62 b   39 9   70 p   5B [   9A
// 8D     8C     8B     FF     8F      8     8E     20
// 33 3   72 r   66 f   76 v   30 0   7B {   5D ]   2C ,
// 32 2   65 e   64 d   63 c   2D -   7D }   3A :   2E .
// 31 1   8A К   61 a   7A z   5E ^   2F /   3B ;   80
// FF     77 w   73 s   78 x   7F     87 З   84 Д   81
// 0D     71 q    9     0F     5C \   88 И   85 Е   82
// 92     FF     90     91     1B     89     86     83

// 26 &   55 U   4A J   4D M   27 '   49 I   4B K   60 `
// 25 %   59 Y   48 H   4E N   28 (   4F O   4C L   40 @
// 24 $   54 T   47 G   42 B   29 )   50 P   5B [   96
// 8D     8C     8B     FF     8F      8     8E     20
// 23 #   52 R   46 F   56 V   5F _   7B {   5D ]   3C <
// 22 "   45 E   44 D   43 C   3D =   7D }   2A *   3E >
// 21 !   8A К   41 A   5A Z   7E ~   3F ?   2B +   80
// FF     57 W   53 S   58 X   7F     87     84     81
// 0D     51 Q    9     FF     7C |   88     85     82
// 95     FF     93     94     1B     89     86     83

// 36 6   D3 г   DE о   EC ь   37 7   E8 ш   DB л   D1 б
// 35 5   DD н   E0 р   E2 т   38 8   E9 щ   D4 д   EE ю
// 34 4   D5 е   DF п   D8 и   39 9   D7 з   D6 ж   F1 ё
// 8D     8C     8B     FF     8F      8     8E     20
// 33 3   DA к   D0 а   DC м   30 0   E5 х   ED э   2C ,
// 32 2   E3 у   D2 в   E1 с   2D -   EA ъ   3A :   2E .
// 31 1   8A     E4 ф   EF я   5E ^   2F /   3B ;   80
// FF     E6 ц   EB ы   E7 ч   7F     87     84     81
// 0D     D9 й    9     FF     5C \   88     85     82
// 92     FF     90     91     1B     89     86     83

// 26 &   B3 Г   BE О   CC Ь   27 '   C8 Ш   BB Л   B1 Б
// 25 %   BD Н   C0 Р   C2 Т   28 (   C9 Щ   B4 Д   CE Ю
// 24 $   B5 Е   BF П   B8 И   29 )   B7 Х   B6 Ж   A1 Ё
// 8D     8C     8B     FF     8F      8     8E     20
// 23 #   BA К   B0 А   BC М   5F _   C5 Х   CD Э   3C <
// 22 "   C3 У   B2 В   C1 С   3D =   CA Ъ   2A *   3E >
// 21 !   8A     C4 Ф   CF Я   7E ~   3F ?   2B +   80
// FF     C6 Ц   CB Ы   C7 Ч   7F     87     84     81
// 0D     B9 Й    9     FF     7C |   88     85     82
// 95     FF     93     94     1B     89     86     83

// Получить символ или скан-код нажатой клавиши с ожиданием.
// Функция:
// - Не рисует мигающий курсор
// - Не перемещает курсор по экрану при нажатии на стрелки
// - Не обрабатывает нажатие клавиш NUM LOCK, CAPS LOCK, RUS, LAT, COP
// - Не заменяет скан-коды правой клавиатуры в зависимости от нажатия NUM LOCK
// - Не заменяет коды клавиш на F1 - F3  на коды из переменных vKeyboardF?, vKeyboardShiftF?
// - Не заменяет строчные/заглавные буквы если нажат CAPS LOCK
// - Обеспечивает задержки перед первым и последующими повторами
// Вызываемая ей функция:
// - Сканирует клавиатуру
// - Заменяет некоторые скан-коды на символы.
// - Обрабатывает нажатие клавиши SHIFT, CTL   TODO: Узнать 3-ю клавишу
// Вход: нет
// Выход: a - код символа, регистры bc, de, hl сохраняются

void KeyboardGet(...) {
    push(bc, de, hl);

    KeyboardGetNoWait();
    if (a == 0xFF) goto KeyboardGet4;

    KeyboardGetInternal();
    if (flag_nz) goto KeyboardGet5;

    hl = vKeyboardDelay;
    do {
        hl--;
        KeyboardGetNoWait();
        if (a == 0xFF) {
            DelayHl(hl = 31);

            KeyboardGetNoWait();
            if (a == 0xFF) goto KeyboardGet4;
        }

        KeyboardGetInternal();
        if (flag_nz) goto KeyboardGet5;

        b = a;
    } while (flag_nz((a = h) |= l));

    a = b;
    vKeyboardDelay = hl = 31;
    goto KeyboardGet2;

KeyboardGet1:
    DelayHl(hl = 31);
    vKeyboardLast = a;
    vKeyboardDelay = hl = 511;

KeyboardGet2:
    b = a;
    a ^= a;
    a = b;

KeyboardGet3:
    pop(bc, de, hl);
    return;

KeyboardGet4:
    vKeyboardLast = a;
    vKeyboardDelay = hl = 511;
    a |= a;
    goto KeyboardGet3;

KeyboardGet5:
    vKeyboardLast = a = b;
    goto KeyboardGet1;
}

// Внутренняя функция. Используется функцией KeyboardGetInternal.

void KeyboardGetInternal(...) {
    b = a;
    a = vKeyboardLast;
    Compare(a, b);
}

// Задержка
// Вход: hl - длительность

void DelayHl(...) {
    push_pop(hl, a) {
        nop();
        do {
            hl--;
            nop();
        } while (flag_nz((a = h) |= l));
    }
}

// Получить символ или скан-код нажатой клавиши без ожидания.
// Функция:
// - Не рисует мигающий курсор
// - Не перемещает курсор по экрану при нажатии на стрелки
// - Не обрабатывает нажатие клавиш NUM LOCK, CAPS LOCK, RUS, LAT, COP
// - Не заменяет скан-коды правой клавиатуры в зависимости от нажатия NUM LOCK
// - Не заменяет коды клавиш на F1 - F3  на коды из переменных vKeyboardF?, vKeyboardShiftF?
// - Не заменяет строчные/заглавные буквы если нажат CAPS LOCK
// - Не обеспечивает задержки перед первым и последующими повторами
// - Сканирует клавиатуру
// - Заменяет некоторые скан-коды на символы.
// - Обрабатывает нажатие клавиши SHIFT, CTL   TODO: Узнать 3-ю клавишу
// Вход: нет
// Выход: a - код символа, регистры bc, de, hl сохраняются

void KeyboardGetNoWait(...) {
    push(bc, de, hl);
    b = 9;
    do {
        out(PORT_KEYBOARD, (a = vKeyboardLeds) |= b);
        a = In(PORT_KEYBOARD);
        if (flag_nz(a |= a)) {
            c = 7;
            d = 0x80;
            e = a;
            do {
                if (flag_nz((a = e) &= d)) {
                    KeyboardGetNoWaitIsShift();
                    if (flag_nc) return KeyboardGetNoWaitInternal();
                }
                d = CarryRotateRight((a = d) |= a, 1);  // Это d >>= 1
            } while (flag_p(c--));
        }
    } while (flag_p(b--));
    a = 0xFF;
    return KeyboardGetNoWaitEnd(a);
}

// Внутренняя функция. Используется функцией KeyboardGetNoWait.

void KeyboardGetNoWaitInternal(...) {
    ((((a = b) += a) += a) += a) += c;  // Это a = b * 8 + c
    hl = vKeyboardLayout;

    KeyboardIsShiftPressed();
    if (flag_c) {
        hl += (de = 80);
    } else {
        KeyboardIsCtrPressed();
        if (flag_c) {
            hl += (de = 160);
        } else {
            KeyboardIs71Pressed();
            if (flag_c) {
                (hl = 240) += de;
            }
        }
    }
    e = a;
    d = 0;
    hl += de;
    out(PORT_CHARGEN_ROM, a);
    a = *hl;
    out(PORT_CODE_ROM, a);
    return KeyboardGetNoWaitEnd();
}

// Внутренняя функция. Используется функцией KeyboardGetNoWait.

void KeyboardGetNoWaitEnd(...) {
    pop(bc, de, hl);
}

// Внутренняя функция. Используется функцией KeyboardGetNoWait.

void KeyboardGetNoWaitIsShift(...) {
    push(hl, a);
    hl = 0x303;
    CompareBcHl();
    if (flag_nz) {
        hl = 0x803;
        CompareBcHl();
        if (flag_nz) {
            hl = 0x700;
            CompareBcHl();
            if (flag_nz) {
                pop(a);
                SetFlagC();
                InvertFlagC();
                pop(hl);
                return;
            }
        }
    }
    pop(a);
    SetFlagC();
    pop(hl);
}

// Сравнить BC и HL. Функция возвращает флаг Z, если регистры равны.
// Функция сохраняет регистры BC, DE, HL.

void CompareBcHl(...) {
    if ((a = b) != h) return;
    Compare(a = c, l);
}

// Нажата ли клавиша SHIFT?
// Выход: cf - нажата
// Функция сохраняет все регистры

void KeyboardIsShiftPressed(...) {
    push(bc);
    return KeyboardIsKeyPressedInternal(bc = 0x308);
}

// Внутренняя функция. Используется функциями KeyboardIsShiftPressed и KeyboardIsCtrPressed.

void KeyboardIsKeyPressedInternal(...) {
    KeyboardIsKeyPressed();
    pop(bc);
}

// Нажата ли клавиша CTL?
// Выход: cf - нажата
// Функция сохраняет все регистры

void KeyboardIsCtrPressed(...) {
    push(bc);
    return KeyboardIsKeyPressedInternal(bc = 0x808);
}

// TODO: Что это?

void KeyboardIs71Pressed(...) {
    push(bc);
    return KeyboardIsKeyPressedInternal(bc = 0x701);
}

// Нажаты ли клавиши?
// Вход: b - ряд клавиатуры, c - битовая маска
// Выход: cf - одна из клавиш нажата
// Функция сохраняет все регистры

void KeyboardIsKeyPressed(...) {
    push_pop(a) {
        out(PORT_KEYBOARD, a = b);
        a = In(PORT_KEYBOARD);
        a &= c;
        if (flag_nz) {
            pop(a);
            set_flag_c();
            return;
        }
    }
    a |= a;  // Clear CF flag
}

// Самодиагностика при включении

void Test(...) {
    // *** Проверка, что ПЗУ по адресам C000..CFFF, F000..FFFF не пустые ***
    TestEmptyRom(b = 0);
    TestEmptyRom(b = 0xFF);

    // Очистка экрана
    VideoClearScreen0();
    VideoClearScreen1();

    // *** Проверка верхней памяти ***
    // Заполнение памяти от 0x9000 до 0xFFFF кодом 0xA5.
    b = 0xA5;
    de = 0x9000;
    hl = 0;
    push_pop(de, hl) {
        MemsetHlBDe();
    }
    // Проверка, что память содержит эти значения
    TestCheckFill();
    if (flag_nz) return TestFailed();
    // Тест пройден
    VideoPrint(a = 'F');

    // *** Проверка шины адреса и мультиплексоров ОЗУ ***
    // Заполнение ячеек памяти 1, 2, 4, 8 .. 0x8000 числами 1, 2, 3, 4 .. 16
    hl = 1;
    b = 1;
    for (;;) {
        *hl = b;
        hl += hl;
        if (flag_c) break;
        b++;
    }
    // Проверка, что память содержит эти значения
    hl = 1;
    b = 1;
    for (;;) {
        a = *hl;
        if (a != b) return TestFailed();
        PrintHexNibble();  // Тут выводятся  16-ричные цифры от 1 до F
        hl += hl;
        if (flag_c) break;
        b++;
    }
    // Тест пройден
    VideoNextLineClear();

    // *** Проверка переключения ОЗУ/ПЗУ в начале адресного пространства ***
    hl = &TestRom;
    *hl = OPCODE_HALT;
    // Подключить ПЗУ к 0x0000 .. 0x00FF
    Out(PORT_ROM_0000, a ^= a);  // Тут a == PORT_ROM_0000__ROM
    // ПЗУ содержит RET, а ОЗУ содержит HALT
    TestRom();
    // Подключить ОЗУ к 0x0000 .. 0x00FF
    Invert(a);
    Out(PORT_ROM_0000, a);  // Тут a != PORT_ROM_0000__ROM
    // Тест пройден
    VideoPrint(a = 'Z');

    // *** Проверка переключения ПЗУ по адресу 0xC000 ***
    out(PORT_CHARGEN_ROM, a);
    hl = 0xC0FF;
    a = *hl;
    if (a == OPCODE_RET) return TestFailed();
    out(PORT_CODE_ROM, a);
    // Тест пройден
    VideoPrint(a = 'C');
    VideoNextLineClear();

    // *** Вывод знакогенератора в консоль ***
    a = 0x20;
    do {
        push_pop(a) {
            VideoPrint(a);
        }
        a++;
    } while (flag_nz);

    // *** Очистка экрана ***
    VideoClearScreen0();
    VideoClearScreen1();
}

// Проверка, что ПЗУ по адресам C000..CFFF, F000..FFFF не заполнено значением регистра B
// Вход: b - значение для проверки

void TestEmptyRom(...) {
    TestCheckFill(hl = 0xF000, de = 0x1000);
    if (flag_z) return TestFailed();
    TestCheckFill(hl = 0xC000, de = 0x1000);
    if (flag_z) return TestFailed();
}

// Проверка, что память HL .. HL + DE - 1 заполнена константой B.
// Вход: B - константа, HL - адрес, DE - длина
// Результат: Z - память заполнена этой константой, портит все регистры

void TestCheckFill(...) {
    for (;;) {
        if ((a = *hl) != b) return;
        hl++;
        de--;
        if (flag_z((a = d) |= e)) return;
    }
}

// Вызывается, если самодиагностика не пройдена

void TestFailed(...) {
    Halt();
    return BiosBoot();
}

void BiosBoot(...) {
    out(PORT_RESET_CU2, a);
    out(PORT_RESET_CU4, a);
    sp = CPM_STACK_ADDRESS;

    // Очистка черно-белого экрана
    VideoClearScreen0();

    // Выбор ПЗУ c CP/M BIOS и переход туда
    out(PORT_CHARGEN_ROM, a);
    BiosBoot2();
    out(PORT_CODE_ROM, a);
    return BiosWarmBoot();
}

void BiosWarmBoot(...) {
    sp = CPM_STACK_ADDRESS;
    out(PORT_CHARGEN_ROM, a);
    BiosInit2();
    BiosLoadDph2();
    BiosLoadCpm2();
    out(PORT_CODE_ROM, a);
    return CpmEntry();
}

void BiosConst(...) {
    KeyboardGet();
    a ^= 0xFF;
    if (flag_z) return;
    a = 0xFF;
}

void BiosWaitKey(...) {
    return vInput();
}

void BiosPutch(...) {
    a = c;
    if (a == 0x1D) goto loc_FDC0;
    if (a != 0x1E) return vPrint();
    a = 64;
loc_FDBC:
    vVideoTextWidth = a;
    return;
loc_FDC0:
    a = 48;
    goto loc_FDBC;
}

void BiosList(...) {
    out(PORT_CHARGEN_ROM, a);
    BiosList2();
    out(PORT_CODE_ROM, a);
}

void BiosListSt(...) {
    a ^= a;
    return BiosAuxOut();
}

void BiosAuxOut(...) {
}

void BiosAuxIn(...) {
    a = 0x1A;
}

void BiosRead4(...) {
    BiosRead();
    out(PORT_CHARGEN_ROM, a);
}

// Фукнкция CP/M BIOS. Выбрать диск.

void BiosSetDsk(...) {
    hl = 0;  // Return value
    if ((a = c) >= 1) return;
    vCpmDisk = a;
    vBiosDisk = a;

    a = vCpmDisk;
    l = a;
    h = 0;
    hl += hl += hl += hl += hl;
    hl += (de = &vBiosEntryDisks);
}

// Фукнкция CP/M BIOS. Выбрать нулевую дорожку.

void BiosHome(...) {
    return vBiosEntrySetTrk(bc = 0);
}

// Фукнкция CP/M BIOS. Выбрать дорожку.

void BiosSetTrk(...) {
    vBiosTrackLow = a = c;
    vBiosTrackHigh = a = b;
}

// Фукнкция CP/M BIOS. Выбрать сектор.

void BiosSetSec(...) {
    vBiosSector = a = c;
}

// Фукнкция CP/M BIOS. Преобразование номера сектора из логического в физический.

void BiosSectTran(...) {
    hl = bc;
}

// Фукнкция CP/M BIOS. Установить адрес буфера для чтения или записи сектора.

void BiosSetDma(...) {
    l = c;
    h = b;
    vBiosDma = hl;
}

// Фукнкция CP/M BIOS. Прочитать сектор с диска.

void BiosRead(...) {
    out(PORT_RESET_CU2, a);
    out(PORT_RESET_CU4, a);
    out(PORT_A0, a);

    // Установка черно-белого видеорежима
    out(PORT_VIDEO_MODE_1_HIGH, a);
    out(PORT_VIDEO_MODE_0_LOW, a);

    // Выбор ПЗУ c CP/M BIOS и переход туда
    out(PORT_CHARGEN_ROM, a);
    BiosRead2();
    return BiosWriteReadInternal();
}

// Фукнкция CP/M BIOS. Записать сектор на диск.

void BiosWrite(...) {
    out(PORT_RESET_CU2, a);
    out(PORT_RESET_CU4, a);
    out(PORT_A0, a);

    // Установка черно-белого видеорежима
    out(PORT_VIDEO_MODE_1_HIGH, a);
    out(PORT_VIDEO_MODE_0_LOW, a);

    // Выбор ПЗУ c CP/M BIOS и переход туда
    out(PORT_CHARGEN_ROM, a);
    BiosWrite2();
    return BiosWriteReadInternal();
}

// Внутренняя функция. Исользуется функциями BiosRead и BiosWindow

void BiosWriteReadInternal(...) {
    out(PORT_CODE_ROM, a);
    return vBiosReadWrite();
}

// Функция UART. Получить байт из буфера передачи микросхемы UART.
// Выход: a - байт.

void UartResoreMode(...) {
    return UartSetMode(a = vUartMode);
}

// Функция UART. Настройка UART интерфейса
// Вход: a - режим, смотри константы UART_MODE
// Перед вызовом неободимо выполнить out(PORT_UART_CONFIG, a = VV51_COMMAND__INTERNAL_RESET)

void UartSetMode(...) {
    push(a);
    a &= VV51_MODE__ASYNC_MASK;
    if (flag_z) return UartSetModeSpeed0();
    a--;
    if (flag_z) return UartSetModeSpeed1();
    a--;
    if (flag_z) return UartSetModeSpeed2();

    // Скорость 3
    out(PORT_UART_SPEED_0, a);
    return UartSetModeInternal();
}

// Внутренняя функция. Используется функцией UartSetMode.

void UartSetModeInternal(...) {
    pop(a);
    (a &= 0xFF ^ VV51_MODE__ASYNC_MASK) |= VV51_MODE__ASYNC_16;
    out(PORT_UART_CONFIG, a);
}

// Внутренняя функция. Используется функцией UartSetMode. Скорость 2.

void UartSetModeSpeed2(...) {
    out(PORT_UART_SPEED_1, a);
    return UartSetModeInternal();
}

// Внутренняя функция. Используется функцией UartSetMode. Скорость 1.

void UartSetModeSpeed1(...) {
    out(PORT_UART_SPEED_0, a);
    return UartModeInternal10();
}

// Внутренняя функция. Используется функцией UartSetMode.

void UartModeInternal10(...) {
    pop(a);
    (a &= 0xFF ^ VV51_MODE__ASYNC_MASK) |= VV51_MODE__ASYNC_64;
    out(PORT_UART_CONFIG, a);
}

// Внутренняя функция. Используется функцией UartSetMode. Скорость 0.

void UartSetModeSpeed0(...) {
    out(PORT_UART_SPEED_1, a);
    return UartModeInternal10();
}

// Функция UART. Проверить буфер приёма микросхемы UART.
// Выход: a = 0 если буфер пуст.

void UartRxReady(...) {
    a = In(PORT_UART_STATE);
    a &= VV51_STATE__RX_READY;
    a = 0xFF;
    if (flag_nz) return;
    a ^= a;
}

// Функция UART. Проверить буфер передачи микросхемы UART.
// Выход: a - 0 если буфер заполнен.

void UartTxReady(...) {
    a = In(PORT_UART_STATE);
    a &= VV51_STATE__TX_READY;
    a = 0xFF;
    if (flag_nz) return;
    a ^= a;
}

// Функция UART. Получить байт из буфера приёма микросхемы UART.
// Выход: a - байт.

void UartRead(...) {
    a = In(PORT_UART_DATA);
}

// Функция UART. Отправить режим UART.

void UartWriteMode(...) {
    out(PORT_UART_DATA, a = vUartMode);
}

// Записать пилот-тон на ленту
// Вход: a = 0 - короткий пилот-тон, иначе длинный

void TapeWritePilot(...) {
    // Запись тишины
    a |= a;
    push_pop(a) {
        hl = 0;
        do {
            hl--;
        } while (flag_nz((a = h) |= l));
    }

    // Короткий или длинный пилот-тон
    bc = 4000;
    if (flag_nz) {
        bc = 16000;
    }

    // Запись пилот-тона
    do {
        TapeWriteHalfBit1();
        a = In(PORT_TAPE_AND_IDX2);  // Задержка
        a = In(PORT_TAPE_AND_IDX2);  // Задержка
        bc--;
    } while (flag_nz((a = b) |= c));
}

// Записать байт на ленту
// Вход: a - байт

void TapeWriteByte(...) {
    push_pop(bc, hl) {
        hl = 0x3B31;  // Длительности периода
        push_pop(a) {
            l = ((a = l) -= 3);
            TapeWritePeriod();
        }
        b = 8;
        do {
            CyclicRotateRight(a);
            if (flag_c) TapeWriteBit1();
            if (flag_nc) TapeWriteBit0();
        } while (flag_nz(b--));
        TapeWriteBit1();
        TapeWriteBit1();
    }
}

// Записать нулевой бит на ленту

void TapeWriteBit0(...) {
    hl = 0x3B31;  // Длительности периода
    nop();        // Задержка
    nop();        // Задержка
    TapeWritePeriod();
}

// Записать единичный бит на ленту

void TapeWriteBit1(...) {
    TapeWriteHalfBit1();
    swap(*sp, hl);  // Задержка
    swap(*sp, hl);  // Задержка
    nop();          // Задержка
    nop();          // Задержка
    nop();          // Задержка
    TapeWriteHalfBit1();
}

// Записать один период частоты единичного бита на ленту

void TapeWriteHalfBit1(...) {
    hl = 0x1D14;  // Длительности периода
    nop();        // Задержка
    nop();        // Задержка
    return TapeWritePeriod();
}

// Записать один период на ленту
// Вход: h, l - длительности

void TapeWritePeriod(...) {
    push_pop(a) {
        do {
        } while (flag_nz(l--));
        out(PORT_TAPE_OUT, a);
        do {
        } while (flag_nz(h--));
        out(PORT_TAPE_OUT, a);
    }
}

// Настройка констант скорости загрузки с ленты по пилот-тону
// Выход: cf - ошшибка чтения или прервано нажатием F1

void TapeReadPilot(...) {
    hl = 1111;
    do {
        d = c;
        TapeReadBit();
        if (flag_c) return;
        a = c;
        if (a >= 222) return TapeReadPilot();
        if (a < 5) return TapeReadPilot();
        a -= d;
        if (flag_c) {
            invert(a);
            a++;
        }
        if (a >= 8) return TapeReadPilot();
        hl--;
    } while (flag_nz((a = h) |= l));

    hl = 0;
    b = l;
    d = l;
    do {
        TapeReadBit();
        if (flag_c) return;
        hl += bc;
    } while (flag_nz(d--));

    hl += (bc = 1710);

    d = (CarryRotateRight(a = h) &= 0x7F);
    hl += hl;
    d = ((a = h) -= d);
    a -= 6;
    vTempTape3 = a;

    vTempTape4 = (CyclicRotateRight((((a = d) += a) += d) &= 0xFC, 2) -= 3);
    a |= a;  // return nc
}

// Чтение байта с ленты
// Выход: а - байт, cf - ошшибка чтения или прервано нажатием F1

void TapeReadByte(...) {
    push_pop(de, bc, hl) {
        d = a = vTempTape3;

        // Ждем, пока на входе 1
        do {
            KeyboardIsF1Pressed();
            if (flag_c) goto TapeReadByteError;
            a = In(PORT_TAPE_AND_IDX2);
        } while (flag_nc(CyclicRotateRight(a)));

        // Ждем, пока на входе 0
        do {
            KeyboardIsF1Pressed();
            if (flag_c) goto TapeReadByteError;
            e = a = In(PORT_TAPE_AND_IDX2);
        } while (flag_c(CyclicRotateRight(a)));

        // Измеряем длительность, пока на входе 1
        TapeReadHalfBitF1();
        do {
            do {
                b = c;
                TapeReadHalfBitF1();
                if (flag_c) goto TapeReadByteError;
                (a = b) += c;
            } while (flag_c);
        } while (a < d);

        // Чтение 8 бит
        l = BIT_PER_BYTE;
        do {
            // Измерение количества изменений полярности сигнала на входе с ленты за определенный интервал
            TapeReadChanges();

            // Если 4 или больше изменений, то выходим с ошибкой
            Compare(a, 4);
            invert_flag_c();
            if (flag_c) goto TapeReadByteError;

            // Если 2 или 3 изменения, сохраняем единичный бит, иначе нулевой
            Compare(a, 2);
            invert_flag_c();
            d = CarryRotateRight(a = d);

            // Если 0 или 2 изменения, то ждем еще одно изменение
            if (flag_nc(CyclicRotateRight(a = c))) TapeReadHalfBit();

            // Ждем одно изменение
            TapeReadHalfBitF1();
        } while (flag_nz(l--));
        KeyboardIsF1Pressed();
        a = d;
    TapeReadByteError:;
    }
}

// Измерение количества изменений полярности сигнала на входе с ленты за определенный интервал
// Выход: с - количество изменений

void TapeReadChanges(...) {
    b = a = vTempTape4;
    c = 0;

    do {
        do {
            a = In(PORT_TAPE_AND_IDX2);
            a ^= e;
            if (flag_z) goto loc_FFB0;
            e = (a ^= e);
            c++;
        } while (flag_nz(b--));
        a = c;
        return;

loc_FFB0:
        nop();
        nop();
        nop();
        a++;
    } while (flag_nz(b--));
    a = c;
}

// Измерение длительности полупериода колебания на входе с ленты с проверкой нажатия F1
// Вход: e - прошлое состояние на входе
// Выход: с - счетчик, e - прошлое состояние на входе, cf - ошшибка чтения или прервано нажатием F1

void TapeReadHalfBitF1(...) {
    KeyboardIsF1Pressed();
    if (flag_c) return;
    return TapeReadHalfBit();
}

// Измерение длительности полупериода колебания на входе с ленты
// Вход: e - прошлое состояние на входе
// Выход: с - счетчик, e - прошлое состояние на входе, cf - ошшибка чтения

void TapeReadHalfBit(...) {
    c = 0;
    return TapeReadEndBit();
}

// Измерение длительности полупериода колебания на входе с ленты без сброса счетчика
// Вход: с - счетчик, e - прошлое состояние на входе
// Выход: с - счетчик, e - прошлое состояние на входе, cf - ошшибка чтения

void TapeReadEndBit(...) {
    do {
        c++;
        if (flag_z) return TapeReadEndBitOverflow();
        a = In(PORT_TAPE_AND_IDX2);
        a ^= e;
    } while (flag_z);
    e = (a ^= e);
}

// Внутренняя функция. Испльзуется функцией TapeReadEndPeriod для установки флага CF

void TapeReadEndBitOverflow(...) {
    c--;
}

// Измерение длительности целого периода колебания на входе с ленты
// Выход: с - счетчик, e - прошлое состояние на входе, cf - ошшибка чтения

void TapeReadBit(...) {
    // Ждем, пока на входе 1
    do {
        KeyboardIsF1Pressed();
        if (flag_c) return;
        e = a = In(PORT_TAPE_AND_IDX2);
        CyclicRotateRight(a);
    } while (flag_c);

    // Измеряем длительность целого периода
    TapeReadHalfBit();
    return TapeReadEndBit();
}

// Проверка нажатия клавиши F1
// Выход: cf - нажата

void KeyboardIsF1Pressed(...) {
    out(PORT_KEYBOARD, a = 9);
    a = In(PORT_KEYBOARD);
    CyclicRotateRight(a);
}

uint8_t unused[4];

// Копирование из ПЗУ2 0C000h - 0C7FFh, ПЗУ 1 0D000h - 0FFFFh в ОЗУ
// Вход: bc - откуда, de - конечный адрес откуда, hl - куда

void CopyRom2(...) {
    for (;;) {
        if ((a = c) == e) {
            if ((a = b) == d) return;
        }
        out(PORT_CHARGEN_ROM, a);
        a = *bc;
        out(PORT_CODE_ROM, a);
        *hl = a;
        bc++;
        hl++;
    }
}

// Последний байт ПЗУ

uint8_t data8 = 0xFF;

// Сохранение файлов для сборки образа

asm(" savebin \"i1080.a.bin\", 0x0, 0x100");
asm(" savebin \"i1080.b.bin\", 0xC100, 0x10000");
