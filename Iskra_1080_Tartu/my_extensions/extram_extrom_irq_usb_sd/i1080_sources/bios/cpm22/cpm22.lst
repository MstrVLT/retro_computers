0001   0000             ;**************************************************************
0002   0000             ;*
0003   0000             ;*             C P / M   version   2 . 2
0004   0000             ;*
0005   0000             ;*   Reconstructed from memory image on February 27, 1981
0006   0000             ;*
0007   0000             ;*                by Clark A. Calkins
0008   0000             ;*
0009   0000             ;**************************************************************
0010   0000             ;
0011   0000             ;   Set memory limit here. This is the amount of contigeous
0012   0000             ; ram starting from 0000. CP/M will reside at the end of this space.
0013   0000             ;
0014   0000             
0015   0000             IOBYTE	.EQU	3		;i/o definition byte.
0016   0000             TDRIVE	.EQU	4		;current drive name and user number.
0017   0000             ENTRY	.EQU	5		;entry point for the cp/m bdos.
0018   0000             TFCB	.EQU	5CH		;default file control block.
0019   0000             TBUFF	.EQU	80H		;i/o buffer and command line storage.
0020   0000             TBASE	.EQU	100H		;transiant program storage area.
0021   0000             ;
0022   0000             ;   Set control character equates.
0023   0000             ;
0024   0000             CNTRLC	.EQU	3		;control-c
0025   0000             CNTRLE	.EQU	05H		;control-e
0026   0000             BS	.EQU	08H		;backspace
0027   0000             TAB	.EQU	09H		;tab
0028   0000             LF	.EQU	0AH		;line feed
0029   0000             FF	.EQU	0CH		;form feed
0030   0000             CR	.EQU	0DH		;carriage return
0031   0000             CNTRLP	.EQU	10H		;control-p
0032   0000             CNTRLR	.EQU	12H		;control-r
0033   0000             CNTRLS	.EQU	13H		;control-s
0034   0000             CNTRLU	.EQU	15H		;control-u
0035   0000             CNTRLX	.EQU	18H		;control-x
0036   0000             CNTRLZ	.EQU	1AH		;control-z (end-of-file mark)
0037   0000             DEL	.EQU	7FH		;rubout
0038   0000             
0039   0000             ;
0040   0000             ;   Set origin for CP/M
0041   0000             ;
0042   0000                     .ORG	0E500H
0043   E500             ;
0044   E500 C3 5C E8    CBASE: 	JP	COMMAND		;execute command processor (ccp).
0045   E503 C3 58 E8    	JP	CLEARBUF	;entry to empty input buffer before starting ccp.
0046   E506             
0047   E506             ;
0048   E506             ;   Standard cp/m ccp input buffer. Format is (max length),
0049   E506             ; (actual length), (char #1), (char #2), (char #3), etc.
0050   E506             ;
0051   E506 7F          INBUFF: 	.DB	127		;length of input buffer.
0052   E507 00          	.DB	0		;current length of contents.
0053   E508             	.DB	"Copyright"
0053   E508 436F70797269676874
0054   E511             	.DB	" 1979 (c) by Digital Research      "
0054   E511 203139373920286329206279204469676974616C205265736561726368202020
0054   E531 202020
0055   E534             	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0055   E534 0000000000000000000000000000000000000000000000
0056   E54B             	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0056   E54B 0000000000000000000000000000000000000000000000
0057   E562             	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0057   E562 0000000000000000000000000000000000000000000000
0058   E579             	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0058   E579 000000000000000000000000000000
0059   E588 08 E5       INPOINT: .DW	INBUFF+2	;input line pointer
0060   E58A 00 00       NAMEPNT: .DW	0		;input line pointer used for error message. Points to
0061   E58C             ;			;start of name in error.
0062   E58C             ;
0063   E58C             ;   Routine to print (A) on the console. All registers used.
0064   E58C             ;
0065   E58C 5F          PRINT: 	LD	E,A		;setup bdos call.
0066   E58D 0E 02       	LD	C,2
0067   E58F C3 05 00    	JP	ENTRY
0068   E592             ;
0069   E592             ;   Routine to print (A) on the console and to save (BC).
0070   E592             ;
0071   E592 C5          PRINTB: 	PUSH	BC
0072   E593 CD 8C E5    	CALL	PRINT
0073   E596 C1          	POP	BC
0074   E597 C9          	RET	
0075   E598             ;
0076   E598             ;   Routine to send a carriage return, line feed combination
0077   E598             ; to the console.
0078   E598             ;
0079   E598 3E 0D       CRLF: 	LD	A,CR
0080   E59A CD 92 E5    	CALL	PRINTB
0081   E59D 3E 0A       	LD	A,LF
0082   E59F C3 92 E5    	JP	PRINTB
0083   E5A2             ;
0084   E5A2             ;   Routine to send one space to the console and save (BC).
0085   E5A2             ;
0086   E5A2 3E 20       SPACE: 	LD	A,' '
0087   E5A4 C3 92 E5    	JP	PRINTB
0088   E5A7             ;
0089   E5A7             ;   Routine to print character string pointed to be (BC) on the
0090   E5A7             ; console. It must terminate with a null byte.
0091   E5A7             ;
0092   E5A7 C5          PLINE: 	PUSH	BC
0093   E5A8 CD 98 E5    	CALL	CRLF
0094   E5AB E1          	POP	HL
0095   E5AC 7E          PLINE2: 	LD	A,(HL)
0096   E5AD B7          	OR	A
0097   E5AE C8          	RET	Z
0098   E5AF 23          	INC	HL
0099   E5B0 E5          	PUSH	HL
0100   E5B1 CD 8C E5    	CALL	PRINT
0101   E5B4 E1          	POP	HL
0102   E5B5 C3 AC E5    	JP	PLINE2
0103   E5B8             ;
0104   E5B8             ;   Routine to reset the disk system.
0105   E5B8             ;
0106   E5B8 0E 0D       RESDSK: 	LD	C,13
0107   E5BA C3 05 00    	JP	ENTRY
0108   E5BD             ;
0109   E5BD             ;   Routine to select disk (A).
0110   E5BD             ;
0111   E5BD 5F          DSKSEL: 	LD	E,A
0112   E5BE 0E 0E       	LD	C,14
0113   E5C0 C3 05 00    	JP	ENTRY
0114   E5C3             ;
0115   E5C3             ;   Routine to call bdos and save the return code. The zero
0116   E5C3             ; flag is set on a return of 0ffh.
0117   E5C3             ;
0118   E5C3 CD 05 00    ENTRY1: 	CALL	ENTRY
0119   E5C6 32 EE EC    	LD	(RTNCODE),A	;save return code.
0120   E5C9 3C          	INC	A		;set zero if 0ffh returned.
0121   E5CA C9          	RET	
0122   E5CB             ;
0123   E5CB             ;   Routine to open a file. (DE) must point to the FCB.
0124   E5CB             ;
0125   E5CB 0E 0F       OPEN: 	LD	C,15
0126   E5CD C3 C3 E5    	JP	ENTRY1
0127   E5D0             ;
0128   E5D0             ;   Routine to open file at (FCB).
0129   E5D0             ;
0130   E5D0 AF          OPENFCB: XOR	A		;clear the record number byte at fcb+32
0131   E5D1 32 ED EC    	LD	(FCB+32),A
0132   E5D4 11 CD EC    	LD	DE,FCB
0133   E5D7 C3 CB E5    	JP	OPEN
0134   E5DA             ;
0135   E5DA             ;   Routine to close a file. (DE) points to FCB.
0136   E5DA             ;
0137   E5DA 0E 10       CLOSE: 	LD	C,16
0138   E5DC C3 C3 E5    	JP	ENTRY1
0139   E5DF             ;
0140   E5DF             ;   Routine to search for the first file with ambigueous name
0141   E5DF             ; (DE).
0142   E5DF             ;
0143   E5DF 0E 11       SRCHFST: LD	C,17
0144   E5E1 C3 C3 E5    	JP	ENTRY1
0145   E5E4             ;
0146   E5E4             ;   Search for the next ambigeous file name.
0147   E5E4             ;
0148   E5E4 0E 12       SRCHNXT: LD	C,18
0149   E5E6 C3 C3 E5    	JP	ENTRY1
0150   E5E9             ;
0151   E5E9             ;   Search for file at (FCB).
0152   E5E9             ;
0153   E5E9 11 CD EC    SRCHFCB: LD	DE,FCB
0154   E5EC C3 DF E5    	JP	SRCHFST
0155   E5EF             ;
0156   E5EF             ;   Routine to delete a file pointed to by (DE).
0157   E5EF             ;
0158   E5EF 0E 13       DELETE: 	LD	C,19
0159   E5F1 C3 05 00    	JP	ENTRY
0160   E5F4             ;
0161   E5F4             ;   Routine to call the bdos and set the zero flag if a zero
0162   E5F4             ; status is returned.
0163   E5F4             ;
0164   E5F4 CD 05 00    ENTRY2: 	CALL	ENTRY
0165   E5F7 B7          	OR	A		;set zero flag if appropriate.
0166   E5F8 C9          	RET	
0167   E5F9             ;
0168   E5F9             ;   Routine to read the next record from a sequential file.
0169   E5F9             ; (DE) points to the FCB.
0170   E5F9             ;
0171   E5F9 0E 14       RDREC: 	LD	C,20
0172   E5FB C3 F4 E5    	JP	ENTRY2
0173   E5FE             ;
0174   E5FE             ;   Routine to read file at (FCB).
0175   E5FE             ;
0176   E5FE 11 CD EC    READFCB: LD	DE,FCB
0177   E601 C3 F9 E5    	JP	RDREC
0178   E604             ;
0179   E604             ;   Routine to write the next record of a sequential file.
0180   E604             ; (DE) points to the FCB.
0181   E604             ;
0182   E604 0E 15       WRTREC: 	LD	C,21
0183   E606 C3 F4 E5    	JP	ENTRY2
0184   E609             ;
0185   E609             ;   Routine to create the file pointed to by (DE).
0186   E609             ;
0187   E609 0E 16       CREATE: 	LD	C,22
0188   E60B C3 C3 E5    	JP	ENTRY1
0189   E60E             ;
0190   E60E             ;   Routine to rename the file pointed to by (DE). Note that
0191   E60E             ; the new name starts at (DE+16).
0192   E60E             ;
0193   E60E 0E 17       RENAM: 	LD	C,23
0194   E610 C3 05 00    	JP	ENTRY
0195   E613             ;
0196   E613             ;   Get the current user code.
0197   E613             ;
0198   E613 1E FF       GETUSR: 	LD	E,0FFH
0199   E615             ;
0200   E615             ;   Routne to get or set the current user code.
0201   E615             ; If (E) is FF then this is a GET, else it is a SET.
0202   E615             ;
0203   E615 0E 20       GETSETUC:  LD	C,32
0204   E617 C3 05 00    	JP	ENTRY
0205   E61A             ;
0206   E61A             ;   Routine to set the current drive byte at (TDRIVE).
0207   E61A             ;
0208   E61A CD 13 E6    SETCDRV: CALL	GETUSR		;get user number
0209   E61D 87          	ADD	A,A		;and shift into the upper 4 bits.
0210   E61E 87          	ADD	A,A
0211   E61F 87          	ADD	A,A
0212   E620 87          	ADD	A,A
0213   E621 21 EF EC    	LD	HL,CDRIVE	;now add in the current drive number.
0214   E624 B6          	OR	(HL)
0215   E625 32 04 00    	LD	(TDRIVE),A	;and save.
0216   E628 C9          	RET	
0217   E629             ;
0218   E629             ;   Move currently active drive down to (TDRIVE).
0219   E629             ;
0220   E629 3A EF EC    MOVECD: 	LD	A,(CDRIVE)
0221   E62C 32 04 00    	LD	(TDRIVE),A
0222   E62F C9          	RET	
0223   E630             ;
0224   E630             ;   Routine to convert (A) into upper case ascii. Only letters
0225   E630             ; are affected.
0226   E630             ;
0227   E630 FE 61       UPPER: 	CP	'a'		;check for letters in the range of 'a' to 'z'.
0228   E632 D8          	RET	C
0229   E633 FE 7B       	CP	'{'
0230   E635 D0          	RET	NC
0231   E636 E6 5F       	AND	5FH		;convert it if found.
0232   E638 C9          	RET	
0233   E639             ;
0234   E639             ;   Routine to get a line of input. We must check to see if the
0235   E639             ; user is in (BATCH) mode. If so, then read the input from file
0236   E639             ; ($$$.SUB). At the end, reset to console input.
0237   E639             ;
0238   E639 3A AB EC    GETINP: 	LD	A,(BATCH)	;if =0, then use console input.
0239   E63C B7          	OR	A
0240   E63D CA 96 E6    	JP	Z,GETINP1
0241   E640             ;
0242   E640             ;   Use the submit file ($$$.sub) which is prepared by a
0243   E640             ; SUBMIT run. It must be on drive (A) and it will be deleted
0244   E640             ; if and error occures (like eof).
0245   E640             ;
0246   E640 3A EF EC    	LD	A,(CDRIVE)	;select drive 0 if need be.
0247   E643 B7          	OR	A
0248   E644 3E 00       	LD	A,0		;always use drive A for submit.
0249   E646 C4 BD E5    	CALL	NZ,DSKSEL	;select it if required.
0250   E649 11 AC EC    	LD	DE,BATCHFCB
0251   E64C CD CB E5    	CALL	OPEN		;look for it.
0252   E64F CA 96 E6    	JP	Z,GETINP1	;if not there, use normal input.
0253   E652 3A BB EC    	LD	A,(BATCHFCB+15)	;get last record number+1.
0254   E655 3D          	DEC	A
0255   E656 32 CC EC    	LD	(BATCHFCB+32),A
0256   E659 11 AC EC    	LD	DE,BATCHFCB
0257   E65C CD F9 E5    	CALL	RDREC		;read last record.
0258   E65F C2 96 E6    	JP	NZ,GETINP1	;quit on end of file.
0259   E662             ;
0260   E662             ;   Move this record into input buffer.
0261   E662             ;
0262   E662 11 07 E5    	LD	DE,INBUFF+1
0263   E665 21 80 00    	LD	HL,TBUFF	;data was read into buffer here.
0264   E668 06 80       	LD	B,128		;all 128 characters may be used.
0265   E66A CD 42 E9    	CALL	HL2DE		;(HL) to (DE), (B) bytes.
0266   E66D 21 BA EC    	LD	HL,BATCHFCB+14
0267   E670 36 00       	LD	(HL),0		;zero out the 's2' byte.
0268   E672 23          	INC	HL		;and decrement the record count.
0269   E673 35          	DEC	(HL)
0270   E674 11 AC EC    	LD	DE,BATCHFCB	;close the batch file now.
0271   E677 CD DA E5    	CALL	CLOSE
0272   E67A CA 96 E6    	JP	Z,GETINP1	;quit on an error.
0273   E67D 3A EF EC    	LD	A,(CDRIVE)	;re-select previous drive if need be.
0274   E680 B7          	OR	A
0275   E681 C4 BD E5    	CALL	NZ,DSKSEL	;don't do needless selects.
0276   E684             ;
0277   E684             ;   Print line just read on console.
0278   E684             ;
0279   E684 21 08 E5    	LD	HL,INBUFF+2
0280   E687 CD AC E5    	CALL	PLINE2
0281   E68A CD C2 E6    	CALL	CHKCON		;check console, quit on a key.
0282   E68D CA A7 E6    	JP	Z,GETINP2	;jump if no key is pressed.
0283   E690             ;
0284   E690             ;   Terminate the submit job on any keyboard input. Delete this
0285   E690             ; file such that it is not re-started and jump to normal keyboard
0286   E690             ; input section.
0287   E690             ;
0288   E690 CD DD E6    	CALL	DELBATCH	;delete the batch file.
0289   E693 C3 82 E8    	JP	CMMND1		;and restart command input.
0290   E696             ;
0291   E696             ;   Get here for normal keyboard input. Delete the submit file
0292   E696             ; incase there was one.
0293   E696             ;
0294   E696 CD DD E6    GETINP1: CALL	DELBATCH	;delete file ($$$.sub).
0295   E699 CD 1A E6    	CALL	SETCDRV		;reset active disk.
0296   E69C 0E 0A       	LD	C,10		;get line from console device.
0297   E69E 11 06 E5    	LD	DE,INBUFF
0298   E6A1 CD 05 00    	CALL	ENTRY
0299   E6A4 CD 29 E6    	CALL	MOVECD		;reset current drive (again).
0300   E6A7             ;
0301   E6A7             ;   Convert input line to upper case.
0302   E6A7             ;
0303   E6A7 21 07 E5    GETINP2: LD	HL,INBUFF+1
0304   E6AA 46          	LD	B,(HL)		;(B)=character counter.
0305   E6AB 23          GETINP3: INC	HL
0306   E6AC 78          	LD	A,B		;end of the line?
0307   E6AD B7          	OR	A
0308   E6AE CA BA E6    	JP	Z,GETINP4
0309   E6B1 7E          	LD	A,(HL)		;convert to upper case.
0310   E6B2 CD 30 E6    	CALL	UPPER
0311   E6B5 77          	LD	(HL),A
0312   E6B6 05          	DEC	B		;adjust character count.
0313   E6B7 C3 AB E6    	JP	GETINP3
0314   E6BA 77          GETINP4: LD	(HL),A		;add trailing null.
0315   E6BB 21 08 E5    	LD	HL,INBUFF+2
0316   E6BE 22 88 E5    	LD	(INPOINT),HL	;reset input line pointer.
0317   E6C1 C9          	RET	
0318   E6C2             ;
0319   E6C2             ;   Routine to check the console for a key pressed. The zero
0320   E6C2             ; flag is set is none, else the character is returned in (A).
0321   E6C2             ;
0322   E6C2 0E 0B       CHKCON: 	LD	C,11		;check console.
0323   E6C4 CD 05 00    	CALL	ENTRY
0324   E6C7 B7          	OR	A
0325   E6C8 C8          	RET	Z		;return if nothing.
0326   E6C9 0E 01       	LD	C,1		;else get character.
0327   E6CB CD 05 00    	CALL	ENTRY
0328   E6CE B7          	OR	A		;clear zero flag and return.
0329   E6CF C9          	RET	
0330   E6D0             ;
0331   E6D0             ;   Routine to get the currently active drive number.
0332   E6D0             ;
0333   E6D0 0E 19       GETDSK: 	LD	C,25
0334   E6D2 C3 05 00    	JP	ENTRY
0335   E6D5             ;
0336   E6D5             ;   Set the stabdard dma address.
0337   E6D5             ;
0338   E6D5 11 80 00    STDDMA: 	LD	DE,TBUFF
0339   E6D8             ;
0340   E6D8             ;   Routine to set the dma address to (DE).
0341   E6D8             ;
0342   E6D8 0E 1A       DMASET: 	LD	C,26
0343   E6DA C3 05 00    	JP	ENTRY
0344   E6DD             ;
0345   E6DD             ;  Delete the batch file created by SUBMIT.
0346   E6DD             ;
0347   E6DD 21 AB EC    DELBATCH:  LD	HL,BATCH	;is batch active?
0348   E6E0 7E          	LD	A,(HL)
0349   E6E1 B7          	OR	A
0350   E6E2 C8          	RET	Z
0351   E6E3 36 00       	LD	(HL),0		;yes, de-activate it.
0352   E6E5 AF          	XOR	A
0353   E6E6 CD BD E5    	CALL	DSKSEL		;select drive 0 for sure.
0354   E6E9 11 AC EC    	LD	DE,BATCHFCB	;and delete this file.
0355   E6EC CD EF E5    	CALL	DELETE
0356   E6EF 3A EF EC    	LD	A,(CDRIVE)	;reset current drive.
0357   E6F2 C3 BD E5    	JP	DSKSEL
0358   E6F5             ;
0359   E6F5             ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
0360   E6F5             ; the same or we halt....
0361   E6F5             ;
0362   E6F5 11 28 E8    VERIFY: 	LD	DE,PATTRN1	;these are the serial number bytes.
0363   E6F8 21 00 ED    	LD	HL,PATTRN2	;ditto, but how could they be different?
0364   E6FB 06 06       	LD	B,6		;6 bytes each.
0365   E6FD 1A          VERIFY1: LD	A,(DE)
0366   E6FE BE          	CP	(HL)
0367   E6FF C2 CF E8    	JP	NZ,HALT		;jump to halt routine.
0368   E702 13          	INC	DE
0369   E703 23          	INC	HL
0370   E704 05          	DEC	B
0371   E705 C2 FD E6    	JP	NZ,VERIFY1
0372   E708 C9          	RET	
0373   E709             ;
0374   E709             ;   Print back file name with a '?' to indicate a syntax error.
0375   E709             ;
0376   E709 CD 98 E5    SYNERR: 	CALL	CRLF		;end current line.
0377   E70C 2A 8A E5    	LD	HL,(NAMEPNT)	;this points to name in error.
0378   E70F 7E          SYNERR1: LD	A,(HL)		;print it until a space or null is found.
0379   E710 FE 20       	CP	' '
0380   E712 CA 22 E7    	JP	Z,SYNERR2
0381   E715 B7          	OR	A
0382   E716 CA 22 E7    	JP	Z,SYNERR2
0383   E719 E5          	PUSH	HL
0384   E71A CD 8C E5    	CALL	PRINT
0385   E71D E1          	POP	HL
0386   E71E 23          	INC	HL
0387   E71F C3 0F E7    	JP	SYNERR1
0388   E722 3E 3F       SYNERR2: LD	A,'?'		;add trailing '?'.
0389   E724 CD 8C E5    	CALL	PRINT
0390   E727 CD 98 E5    	CALL	CRLF
0391   E72A CD DD E6    	CALL	DELBATCH	;delete any batch file.
0392   E72D C3 82 E8    	JP	CMMND1		;and restart from console input.
0393   E730             ;
0394   E730             ;   Check character at (DE) for legal command input. Note that the
0395   E730             ; zero flag is set if the character is a delimiter.
0396   E730             ;
0397   E730 1A          CHECK: 	LD	A,(DE)
0398   E731 B7          	OR	A
0399   E732 C8          	RET	Z
0400   E733 FE 20       	CP	' '		;control characters are not legal here.
0401   E735 DA 09 E7    	JP	C,SYNERR
0402   E738 C8          	RET	Z		;check for valid delimiter.
0403   E739 FE 3D       	CP	'='
0404   E73B C8          	RET	Z
0405   E73C FE 5F       	CP	'_'
0406   E73E C8          	RET	Z
0407   E73F FE 2E       	CP	'.'
0408   E741 C8          	RET	Z
0409   E742 FE 3A       	CP	':'
0410   E744 C8          	RET	Z
0411   E745 FE 3B       	CP	03BH ; ';'
0412   E747 C8          	RET	Z
0413   E748 FE 3C       	CP	'<'
0414   E74A C8          	RET	Z
0415   E74B FE 3E       	CP	'>'
0416   E74D C8          	RET	Z
0417   E74E C9          	RET	
0418   E74F             ;
0419   E74F             ;   Get the next non-blank character from (DE).
0420   E74F             ;
0421   E74F 1A          NONBLANK:  LD	A,(DE)
0422   E750 B7          	OR	A		;string ends with a null.
0423   E751 C8          	RET	Z
0424   E752 FE 20       	CP	' '
0425   E754 C0          	RET	NZ
0426   E755 13          	INC	DE
0427   E756 C3 4F E7    	JP	NONBLANK
0428   E759             ;
0429   E759             ;   Add (HL)=(HL)+(A)
0430   E759             ;
0431   E759 85          ADDHL: 	ADD	A,L
0432   E75A 6F          	LD	L,A
0433   E75B D0          	RET	NC		;take care of any carry.
0434   E75C 24          	INC	H
0435   E75D C9          	RET	
0436   E75E             ;
0437   E75E             ;   Convert the first name in (FCB).
0438   E75E             ;
0439   E75E 3E 00       CONVFST: LD	A,0
0440   E760             ;
0441   E760             ;   Format a file name (convert * to '?', etc.). On return,
0442   E760             ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
0443   E760             ; the position within the fcb for the name (either 0 or 16).
0444   E760             ;
0445   E760 21 CD EC    CONVERT: LD	HL,FCB
0446   E763 CD 59 E7    	CALL	ADDHL
0447   E766 E5          	PUSH	HL
0448   E767 E5          	PUSH	HL
0449   E768 AF          	XOR	A
0450   E769 32 F0 EC    	LD	(CHGDRV),A	;initialize drive change flag.
0451   E76C 2A 88 E5    	LD	HL,(INPOINT)	;set (HL) as pointer into input line.
0452   E76F EB          	EX	DE,HL
0453   E770 CD 4F E7    	CALL	NONBLANK	;get next non-blank character.
0454   E773 EB          	EX	DE,HL
0455   E774 22 8A E5    	LD	(NAMEPNT),HL	;save pointer here for any error message.
0456   E777 EB          	EX	DE,HL
0457   E778 E1          	POP	HL
0458   E779 1A          	LD	A,(DE)		;get first character.
0459   E77A B7          	OR	A
0460   E77B CA 89 E7    	JP	Z,CONVRT1
0461   E77E DE 40       	SBC	A,'A'-1		;might be a drive name, convert to binary.
0462   E780 47          	LD	B,A		;and save.
0463   E781 13          	INC	DE		;check next character for a ':'.
0464   E782 1A          	LD	A,(DE)
0465   E783 FE 3A       	CP	':'
0466   E785 CA 90 E7    	JP	Z,CONVRT2
0467   E788 1B          	DEC	DE		;nope, move pointer back to the start of the line.
0468   E789 3A EF EC    CONVRT1: LD	A,(CDRIVE)
0469   E78C 77          	LD	(HL),A
0470   E78D C3 96 E7    	JP	CONVRT3
0471   E790 78          CONVRT2: LD	A,B
0472   E791 32 F0 EC    	LD	(CHGDRV),A	;set change in drives flag.
0473   E794 70          	LD	(HL),B
0474   E795 13          	INC	DE
0475   E796             ;
0476   E796             ;   Convert the basic file name.
0477   E796             ;
0478   E796 06 08       CONVRT3: LD	B,08H
0479   E798 CD 30 E7    CONVRT4: CALL	CHECK
0480   E79B CA B9 E7    	JP	Z,CONVRT8
0481   E79E 23          	INC	HL
0482   E79F FE 2A       	CP	'*'		;note that an '*' will fill the remaining
0483   E7A1 C2 A9 E7    	JP	NZ,CONVRT5	;field with '?'.
0484   E7A4 36 3F       	LD	(HL),'?'
0485   E7A6 C3 AB E7    	JP	CONVRT6
0486   E7A9 77          CONVRT5: LD	(HL),A
0487   E7AA 13          	INC	DE
0488   E7AB 05          CONVRT6: DEC	B
0489   E7AC C2 98 E7    	JP	NZ,CONVRT4
0490   E7AF CD 30 E7    CONVRT7: CALL	CHECK		;get next delimiter.
0491   E7B2 CA C0 E7    	JP	Z,GETEXT
0492   E7B5 13          	INC	DE
0493   E7B6 C3 AF E7    	JP	CONVRT7
0494   E7B9 23          CONVRT8: INC	HL		;blank fill the file name.
0495   E7BA 36 20       	LD	(HL),' '
0496   E7BC 05          	DEC	B
0497   E7BD C2 B9 E7    	JP	NZ,CONVRT8
0498   E7C0             ;
0499   E7C0             ;   Get the extension and convert it.
0500   E7C0             ;
0501   E7C0 06 03       GETEXT: 	LD	B,03H
0502   E7C2 FE 2E       	CP	'.'
0503   E7C4 C2 E9 E7    	JP	NZ,GETEXT5
0504   E7C7 13          	INC	DE
0505   E7C8 CD 30 E7    GETEXT1: CALL	CHECK
0506   E7CB CA E9 E7    	JP	Z,GETEXT5
0507   E7CE 23          	INC	HL
0508   E7CF FE 2A       	CP	'*'
0509   E7D1 C2 D9 E7    	JP	NZ,GETEXT2
0510   E7D4 36 3F       	LD	(HL),'?'
0511   E7D6 C3 DB E7    	JP	GETEXT3
0512   E7D9 77          GETEXT2: LD	(HL),A
0513   E7DA 13          	INC	DE
0514   E7DB 05          GETEXT3: DEC	B
0515   E7DC C2 C8 E7    	JP	NZ,GETEXT1
0516   E7DF CD 30 E7    GETEXT4: CALL	CHECK
0517   E7E2 CA F0 E7    	JP	Z,GETEXT6
0518   E7E5 13          	INC	DE
0519   E7E6 C3 DF E7    	JP	GETEXT4
0520   E7E9 23          GETEXT5: INC	HL
0521   E7EA 36 20       	LD	(HL),' '
0522   E7EC 05          	DEC	B
0523   E7ED C2 E9 E7    	JP	NZ,GETEXT5
0524   E7F0 06 03       GETEXT6: LD	B,3
0525   E7F2 23          GETEXT7: INC	HL
0526   E7F3 36 00       	LD	(HL),0
0527   E7F5 05          	DEC	B
0528   E7F6 C2 F2 E7    	JP	NZ,GETEXT7
0529   E7F9 EB          	EX	DE,HL
0530   E7FA 22 88 E5    	LD	(INPOINT),HL	;save input line pointer.
0531   E7FD E1          	POP	HL
0532   E7FE             ;
0533   E7FE             ;   Check to see if this is an ambigeous file name specification.
0534   E7FE             ; Set the (A) register to non zero if it is.
0535   E7FE             ;
0536   E7FE 01 0B 00    	LD	BC,11		;set name length.
0537   E801 23          GETEXT8: INC	HL
0538   E802 7E          	LD	A,(HL)
0539   E803 FE 3F       	CP	'?'		;any question marks?
0540   E805 C2 09 E8    	JP	NZ,GETEXT9
0541   E808 04          	INC	B		;count them.
0542   E809 0D          GETEXT9: DEC	C
0543   E80A C2 01 E8    	JP	NZ,GETEXT8
0544   E80D 78          	LD	A,B
0545   E80E B7          	OR	A
0546   E80F C9          	RET	
0547   E810             ;
0548   E810             ;   CP/M command table. Note commands can be either 3 or 4 characters long.
0549   E810             ;
0550   E810             NUMCMDS .EQU	6		;number of commands
0551   E810 44 49 52 20 CMDTBL: 	.DB	"DIR "
0552   E814 45 52 41 20 	.DB	"ERA "
0553   E818 54 59 50 45 	.DB	"TYPE"
0554   E81C 53 41 56 45 	.DB	"SAVE"
0555   E820 52 45 4E 20 	.DB	"REN "
0556   E824 55 53 45 52 	.DB	"USER"
0557   E828             ;
0558   E828             ;   The following six bytes must agree with those at (PATTRN2)
0559   E828             ; or cp/m will HALT. Why?
0560   E828             ;
0561   E828             PATTRN1: .DB	0,22,0,0,0,0	;(* serial number bytes *).
0561   E828 001600000000
0562   E82E             ;
0563   E82E             ;   Search the command table for a match with what has just
0564   E82E             ; been entered. If a match is found, then we jump to the
0565   E82E             ; proper section. Else jump to (UNKNOWN).
0566   E82E             ; On return, the (C) register is set to the command number
0567   E82E             ; that matched (or NUMCMDS+1 if no match).
0568   E82E             ;
0569   E82E 21 10 E8    SEARCH: 	LD	HL,CMDTBL
0570   E831 0E 00       	LD	C,0
0571   E833 79          SEARCH1: LD	A,C
0572   E834 FE 06       	CP	NUMCMDS		;this commands exists.
0573   E836 D0          	RET	NC
0574   E837 11 CE EC    	LD	DE,FCB+1	;check this one.
0575   E83A 06 04       	LD	B,4		;max command length.
0576   E83C 1A          SEARCH2: LD	A,(DE)
0577   E83D BE          	CP	(HL)
0578   E83E C2 4F E8    	JP	NZ,SEARCH3	;not a match.
0579   E841 13          	INC	DE
0580   E842 23          	INC	HL
0581   E843 05          	DEC	B
0582   E844 C2 3C E8    	JP	NZ,SEARCH2
0583   E847 1A          	LD	A,(DE)		;allow a 3 character command to match.
0584   E848 FE 20       	CP	' '
0585   E84A C2 54 E8    	JP	NZ,SEARCH4
0586   E84D 79          	LD	A,C		;set return register for this command.
0587   E84E C9          	RET	
0588   E84F 23          SEARCH3: INC	HL
0589   E850 05          	DEC	B
0590   E851 C2 4F E8    	JP	NZ,SEARCH3
0591   E854 0C          SEARCH4: INC	C
0592   E855 C3 33 E8    	JP	SEARCH1
0593   E858             ;
0594   E858             ;   Set the input buffer to empty and then start the command
0595   E858             ; processor (ccp).
0596   E858             ;
0597   E858 AF          CLEARBUF:  XOR	A
0598   E859 32 07 E5    	LD	(INBUFF+1),A	;second byte is actual length.
0599   E85C             ;
0600   E85C             ;**************************************************************
0601   E85C             ;*
0602   E85C             ;*
0603   E85C             ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
0604   E85C             ;*
0605   E85C             ;**************************************************************
0606   E85C             ;*
0607   E85C 31 AB EC    COMMAND: LD	SP,CCPSTACK	;setup stack area.
0608   E85F C5          	PUSH	BC		;note that (C) should be equal to:
0609   E860 79          	LD	A,C		;(uuuudddd) where 'uuuu' is the user number
0610   E861 1F          	RRA			;and 'dddd' is the drive number.
0611   E862 1F          	RRA	
0612   E863 1F          	RRA	
0613   E864 1F          	RRA	
0614   E865 E6 0F       	AND	0FH		;isolate the user number.
0615   E867 5F          	LD	E,A
0616   E868 CD 15 E6    	CALL	GETSETUC	;and set it.
0617   E86B CD B8 E5    	CALL	RESDSK		;reset the disk system.
0618   E86E 32 AB EC    	LD	(BATCH),A	;clear batch mode flag.
0619   E871 C1          	POP	BC
0620   E872 79          	LD	A,C
0621   E873 E6 0F       	AND	0FH		;isolate the drive number.
0622   E875 32 EF EC    	LD	(CDRIVE),A	;and save.
0623   E878 CD BD E5    	CALL	DSKSEL		;...and select.
0624   E87B 3A 07 E5    	LD	A,(INBUFF+1)
0625   E87E B7          	OR	A		;anything in input buffer already?
0626   E87F C2 98 E8    	JP	NZ,CMMND2	;yes, we just process it.
0627   E882             ;
0628   E882             ;   Entry point to get a command line from the console.
0629   E882             ;
0630   E882 31 AB EC    CMMND1: 	LD	SP,CCPSTACK	;set stack straight.
0631   E885 CD 98 E5    	CALL	CRLF		;start a new line on the screen.
0632   E888 CD D0 E6    	CALL	GETDSK		;get current drive.
0633   E88B C6 41       	ADD	A,'A'
0634   E88D CD 8C E5    	CALL	PRINT		;print current drive.
0635   E890 3E 3E       	LD	A,'>'
0636   E892 CD 8C E5    	CALL	PRINT		;and add prompt.
0637   E895 CD 39 E6    	CALL	GETINP		;get line from user.
0638   E898             ;
0639   E898             ;   Process command line here.
0640   E898             ;
0641   E898 11 80 00    CMMND2: 	LD	DE,TBUFF
0642   E89B CD D8 E6    	CALL	DMASET		;set standard dma address.
0643   E89E CD D0 E6    	CALL	GETDSK
0644   E8A1 32 EF EC    	LD	(CDRIVE),A	;set current drive.
0645   E8A4 CD 5E E7    	CALL	CONVFST		;convert name typed in.
0646   E8A7 C4 09 E7    	CALL	NZ,SYNERR	;wild cards are not allowed.
0647   E8AA 3A F0 EC    	LD	A,(CHGDRV)	;if a change in drives was indicated,
0648   E8AD B7          	OR	A		;then treat this as an unknown command
0649   E8AE C2 A5 EB    	JP	NZ,UNKNOWN	;which gets executed.
0650   E8B1 CD 2E E8    	CALL	SEARCH		;else search command table for a match.
0651   E8B4             ;
0652   E8B4             ;   Note that an unknown command returns
0653   E8B4             ; with (A) pointing to the last address
0654   E8B4             ; in our table which is (UNKNOWN).
0655   E8B4             ;
0656   E8B4 21 C1 E8    	LD	HL,CMDADR	;now, look thru our address table for command (A).
0657   E8B7 5F          	LD	E,A		;set (DE) to command number.
0658   E8B8 16 00       	LD	D,0
0659   E8BA 19          	ADD	HL,DE
0660   E8BB 19          	ADD	HL,DE		;(HL)=(CMDADR)+2*(command number).
0661   E8BC 7E          	LD	A,(HL)		;now pick out this address.
0662   E8BD 23          	INC	HL
0663   E8BE 66          	LD	H,(HL)
0664   E8BF 6F          	LD	L,A
0665   E8C0 E9          	JP	(HL)		;now execute it.
0666   E8C1             ;
0667   E8C1             ;   CP/M command address table.
0668   E8C1             ;
0669   E8C1             CMDADR: 	.DW	DIRECT,ERASE,TYPE,SAVE
0669   E8C1 77E91FEA5DEAADEA
0670   E8C9             	.DW	RENAME,USER,UNKNOWN
0670   E8C9 10EB8EEBA5EB
0671   E8CF             ;
0672   E8CF             ;   Halt the system. Reason for this is unknown at present.
0673   E8CF             ;
0674   E8CF 21 F3 76    HALT: 	LD	HL,76F3H	;'DI HLT' instructions.
0675   E8D2 22 00 E5    	LD	(CBASE),HL
0676   E8D5 21 00 E5    	LD	HL,CBASE
0677   E8D8 E9          	JP	(HL)
0678   E8D9             ;
0679   E8D9             ;   Read error while TYPEing a file.
0680   E8D9             ;
0681   E8D9 01 DF E8    RDERROR: LD	BC,RDERR
0682   E8DC C3 A7 E5    	JP	PLINE
0683   E8DF             RDERR: 	.DB	"Read error"
0683   E8DF 52656164206572726F72
0684   E8E9 00          	.DB	0
0685   E8EA             ;
0686   E8EA             ;   Required file was not located.
0687   E8EA             ;
0688   E8EA 01 F0 E8    NONE: 	LD	BC,NOFILE
0689   E8ED C3 A7 E5    	JP	PLINE
0690   E8F0             NOFILE: 	.DB	"No file"
0690   E8F0 4E6F2066696C65
0691   E8F7 00          	.DB	0
0692   E8F8             ;
0693   E8F8             ;   Decode a command of the form 'A>filename number{ filename}.
0694   E8F8             ; Note that a drive specifier is not allowed on the first file
0695   E8F8             ; name. On return, the number is in register (A). Any error
0696   E8F8             ; causes 'filename?' to be printed and the command is aborted.
0697   E8F8             ;
0698   E8F8 CD 5E E7    DECODE: 	CALL	CONVFST		;convert filename.
0699   E8FB 3A F0 EC    	LD	A,(CHGDRV)	;do not allow a drive to be specified.
0700   E8FE B7          	OR	A
0701   E8FF C2 09 E7    	JP	NZ,SYNERR
0702   E902 21 CE EC    	LD	HL,FCB+1	;convert number now.
0703   E905 01 0B 00    	LD	BC,11		;(B)=sum register, (C)=max digit count.
0704   E908 7E          DECODE1: LD	A,(HL)
0705   E909 FE 20       	CP	' '		;a space terminates the numeral.
0706   E90B CA 33 E9    	JP	Z,DECODE3
0707   E90E 23          	INC	HL
0708   E90F D6 30       	SUB	'0'		;make binary from ascii.
0709   E911 FE 0A       	CP	10		;legal digit?
0710   E913 D2 09 E7    	JP	NC,SYNERR
0711   E916 57          	LD	D,A		;yes, save it in (D).
0712   E917 78          	LD	A,B		;compute (B)=(B)*10 and check for overflow.
0713   E918 E6 E0       	AND	0E0H
0714   E91A C2 09 E7    	JP	NZ,SYNERR
0715   E91D 78          	LD	A,B
0716   E91E 07          	RLCA	
0717   E91F 07          	RLCA	
0718   E920 07          	RLCA			;(A)=(B)*8
0719   E921 80          	ADD	A,B		;.......*9
0720   E922 DA 09 E7    	JP	C,SYNERR
0721   E925 80          	ADD	A,B		;.......*10
0722   E926 DA 09 E7    	JP	C,SYNERR
0723   E929 82          	ADD	A,D		;add in new digit now.
0724   E92A DA 09 E7    DECODE2: JP	C,SYNERR
0725   E92D 47          	LD	B,A		;and save result.
0726   E92E 0D          	DEC	C		;only look at 11 digits.
0727   E92F C2 08 E9    	JP	NZ,DECODE1
0728   E932 C9          	RET	
0729   E933 7E          DECODE3: LD	A,(HL)		;spaces must follow (why?).
0730   E934 FE 20       	CP	' '
0731   E936 C2 09 E7    	JP	NZ,SYNERR
0732   E939 23          	INC	HL
0733   E93A 0D          DECODE4: DEC	C
0734   E93B C2 33 E9    	JP	NZ,DECODE3
0735   E93E 78          	LD	A,B		;set (A)=the numeric value entered.
0736   E93F C9          	RET	
0737   E940             ;
0738   E940             ;   Move 3 bytes from (HL) to (DE). Note that there is only
0739   E940             ; one reference to this at (A2D5h).
0740   E940             ;
0741   E940 06 03       MOVE3: 	LD	B,3
0742   E942             ;
0743   E942             ;   Move (B) bytes from (HL) to (DE).
0744   E942             ;
0745   E942 7E          HL2DE: 	LD	A,(HL)
0746   E943 12          	LD	(DE),A
0747   E944 23          	INC	HL
0748   E945 13          	INC	DE
0749   E946 05          	DEC	B
0750   E947 C2 42 E9    	JP	NZ,HL2DE
0751   E94A C9          	RET	
0752   E94B             ;
0753   E94B             ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
0754   E94B             ;
0755   E94B 21 80 00    EXTRACT: LD	HL,TBUFF
0756   E94E 81          	ADD	A,C
0757   E94F CD 59 E7    	CALL	ADDHL
0758   E952 7E          	LD	A,(HL)
0759   E953 C9          	RET	
0760   E954             ;
0761   E954             ;  Check drive specified. If it means a change, then the new
0762   E954             ; drive will be selected. In any case, the drive byte of the
0763   E954             ; fcb will be set to null (means use current drive).
0764   E954             ;
0765   E954 AF          DSELECT: XOR	A		;null out first byte of fcb.
0766   E955 32 CD EC    	LD	(FCB),A
0767   E958 3A F0 EC    	LD	A,(CHGDRV)	;a drive change indicated?
0768   E95B B7          	OR	A
0769   E95C C8          	RET	Z
0770   E95D 3D          	DEC	A		;yes, is it the same as the current drive?
0771   E95E 21 EF EC    	LD	HL,CDRIVE
0772   E961 BE          	CP	(HL)
0773   E962 C8          	RET	Z
0774   E963 C3 BD E5    	JP	DSKSEL		;no. Select it then.
0775   E966             ;
0776   E966             ;   Check the drive selection and reset it to the previous
0777   E966             ; drive if it was changed for the preceeding command.
0778   E966             ;
0779   E966 3A F0 EC    RESETDR: LD	A,(CHGDRV)	;drive change indicated?
0780   E969 B7          	OR	A
0781   E96A C8          	RET	Z
0782   E96B 3D          	DEC	A		;yes, was it a different drive?
0783   E96C 21 EF EC    	LD	HL,CDRIVE
0784   E96F BE          	CP	(HL)
0785   E970 C8          	RET	Z
0786   E971 3A EF EC    	LD	A,(CDRIVE)	;yes, re-select our old drive.
0787   E974 C3 BD E5    	JP	DSKSEL
0788   E977             ;
0789   E977             ;**************************************************************
0790   E977             ;*
0791   E977             ;*           D I R E C T O R Y   C O M M A N D
0792   E977             ;*
0793   E977             ;**************************************************************
0794   E977             ;
0795   E977 CD 5E E7    DIRECT: 	CALL	CONVFST		;convert file name.
0796   E97A CD 54 E9    	CALL	DSELECT		;select indicated drive.
0797   E97D 21 CE EC    	LD	HL,FCB+1	;was any file indicated?
0798   E980 7E          	LD	A,(HL)
0799   E981 FE 20       	CP	' '
0800   E983 C2 8F E9    	JP	NZ,DIRECT2
0801   E986 06 0B       	LD	B,11		;no. Fill field with '?' - same as *.*.
0802   E988 36 3F       DIRECT1: LD	(HL),'?'
0803   E98A 23          	INC	HL
0804   E98B 05          	DEC	B
0805   E98C C2 88 E9    	JP	NZ,DIRECT1
0806   E98F 1E 00       DIRECT2: LD	E,0		;set initial cursor position.
0807   E991 D5          	PUSH	DE
0808   E992 CD E9 E5    	CALL	SRCHFCB		;get first file name.
0809   E995 CC EA E8    	CALL	Z,NONE		;none found at all?
0810   E998 CA 1B EA    DIRECT3: JP	Z,DIRECT9	;terminate if no more names.
0811   E99B 3A EE EC    	LD	A,(RTNCODE)	;get file's position in segment (0-3).
0812   E99E 0F          	RRCA	
0813   E99F 0F          	RRCA	
0814   E9A0 0F          	RRCA	
0815   E9A1 E6 60       	AND	60H		;(A)=position*32
0816   E9A3 4F          	LD	C,A
0817   E9A4 3E 0A       	LD	A,10
0818   E9A6 CD 4B E9    	CALL	EXTRACT		;extract the tenth entry in fcb.
0819   E9A9 17          	RLA			;check system file status bit.
0820   E9AA DA 0F EA    	JP	C,DIRECT8	;we don't list them.
0821   E9AD D1          	POP	DE
0822   E9AE 7B          	LD	A,E		;bump name count.
0823   E9AF 1C          	INC	E
0824   E9B0 D5          	PUSH	DE
0825   E9B1 E6 03       	AND	03H		;at end of line?
0826   E9B3 F5          	PUSH	AF
0827   E9B4 C2 CC E9    	JP	NZ,DIRECT4
0828   E9B7 CD 98 E5    	CALL	CRLF		;yes, end this line and start another.
0829   E9BA C5          	PUSH	BC
0830   E9BB CD D0 E6    	CALL	GETDSK		;start line with ('A:').
0831   E9BE C1          	POP	BC
0832   E9BF C6 41       	ADD	A,'A'
0833   E9C1 CD 92 E5    	CALL	PRINTB
0834   E9C4 3E 3A       	LD	A,':'
0835   E9C6 CD 92 E5    	CALL	PRINTB
0836   E9C9 C3 D4 E9    	JP	DIRECT5
0837   E9CC CD A2 E5    DIRECT4: CALL	SPACE		;add seperator between file names.
0838   E9CF 3E 3A       	LD	A,':'
0839   E9D1 CD 92 E5    	CALL	PRINTB
0840   E9D4 CD A2 E5    DIRECT5: CALL	SPACE
0841   E9D7 06 01       	LD	B,1		;'extract' each file name character at a time.
0842   E9D9 78          DIRECT6: LD	A,B
0843   E9DA CD 4B E9    	CALL	EXTRACT
0844   E9DD E6 7F       	AND	7FH		;strip bit 7 (status bit).
0845   E9DF FE 20       	CP	' '		;are we at the end of the name?
0846   E9E1 C2 F9 E9    	JP	NZ,DRECT65
0847   E9E4 F1          	POP	AF		;yes, don't print spaces at the end of a line.
0848   E9E5 F5          	PUSH	AF
0849   E9E6 FE 03       	CP	3
0850   E9E8 C2 F7 E9    	JP	NZ,DRECT63
0851   E9EB 3E 09       	LD	A,9		;first check for no extension.
0852   E9ED CD 4B E9    	CALL	EXTRACT
0853   E9F0 E6 7F       	AND	7FH
0854   E9F2 FE 20       	CP	' '
0855   E9F4 CA 0E EA    	JP	Z,DIRECT7	;don't print spaces.
0856   E9F7 3E 20       DRECT63: LD	A,' '		;else print them.
0857   E9F9 CD 92 E5    DRECT65: CALL	PRINTB
0858   E9FC 04          	INC	B		;bump to next character psoition.
0859   E9FD 78          	LD	A,B
0860   E9FE FE 0C       	CP	12		;end of the name?
0861   EA00 D2 0E EA    	JP	NC,DIRECT7
0862   EA03 FE 09       	CP	9		;nope, starting extension?
0863   EA05 C2 D9 E9    	JP	NZ,DIRECT6
0864   EA08 CD A2 E5    	CALL	SPACE		;yes, add seperating space.
0865   EA0B C3 D9 E9    	JP	DIRECT6
0866   EA0E F1          DIRECT7: POP	AF		;get the next file name.
0867   EA0F CD C2 E6    DIRECT8: CALL	CHKCON		;first check console, quit on anything.
0868   EA12 C2 1B EA    	JP	NZ,DIRECT9
0869   EA15 CD E4 E5    	CALL	SRCHNXT		;get next name.
0870   EA18 C3 98 E9    	JP	DIRECT3		;and continue with our list.
0871   EA1B D1          DIRECT9: POP	DE		;restore the stack and return to command level.
0872   EA1C C3 86 EC    	JP	GETBACK
0873   EA1F             ;
0874   EA1F             ;**************************************************************
0875   EA1F             ;*
0876   EA1F             ;*                E R A S E   C O M M A N D
0877   EA1F             ;*
0878   EA1F             ;**************************************************************
0879   EA1F             ;
0880   EA1F CD 5E E7    ERASE: 	CALL	CONVFST		;convert file name.
0881   EA22 FE 0B       	CP	11		;was '*.*' entered?
0882   EA24 C2 42 EA    	JP	NZ,ERASE1
0883   EA27 01 52 EA    	LD	BC,YESNO	;yes, ask for confirmation.
0884   EA2A CD A7 E5    	CALL	PLINE
0885   EA2D CD 39 E6    	CALL	GETINP
0886   EA30 21 07 E5    	LD	HL,INBUFF+1
0887   EA33 35          	DEC	(HL)		;must be exactly 'y'.
0888   EA34 C2 82 E8    	JP	NZ,CMMND1
0889   EA37 23          	INC	HL
0890   EA38 7E          	LD	A,(HL)
0891   EA39 FE 59       	CP	'Y'
0892   EA3B C2 82 E8    	JP	NZ,CMMND1
0893   EA3E 23          	INC	HL
0894   EA3F 22 88 E5    	LD	(INPOINT),HL	;save input line pointer.
0895   EA42 CD 54 E9    ERASE1: 	CALL	DSELECT		;select desired disk.
0896   EA45 11 CD EC    	LD	DE,FCB
0897   EA48 CD EF E5    	CALL	DELETE		;delete the file.
0898   EA4B 3C          	INC	A
0899   EA4C CC EA E8    	CALL	Z,NONE		;not there?
0900   EA4F C3 86 EC    	JP	GETBACK		;return to command level now.
0901   EA52             YESNO: 	.DB	"All (y/n)?"
0901   EA52 416C6C2028792F6E293F
0902   EA5C 00          	.DB	0
0903   EA5D             ;
0904   EA5D             ;**************************************************************
0905   EA5D             ;*
0906   EA5D             ;*            T Y P E   C O M M A N D
0907   EA5D             ;*
0908   EA5D             ;**************************************************************
0909   EA5D             ;
0910   EA5D CD 5E E7    TYPE: 	CALL	CONVFST		;convert file name.
0911   EA60 C2 09 E7    	JP	NZ,SYNERR	;wild cards not allowed.
0912   EA63 CD 54 E9    	CALL	DSELECT		;select indicated drive.
0913   EA66 CD D0 E5    	CALL	OPENFCB		;open the file.
0914   EA69 CA A7 EA    	JP	Z,TYPE5		;not there?
0915   EA6C CD 98 E5    	CALL	CRLF		;ok, start a new line on the screen.
0916   EA6F 21 F1 EC    	LD	HL,NBYTES	;initialize byte counter.
0917   EA72 36 FF       	LD	(HL),0FFH	;set to read first sector.
0918   EA74 21 F1 EC    TYPE1: 	LD	HL,NBYTES
0919   EA77 7E          TYPE2: 	LD	A,(HL)		;have we written the entire sector?
0920   EA78 FE 80       	CP	128
0921   EA7A DA 87 EA    	JP	C,TYPE3
0922   EA7D E5          	PUSH	HL		;yes, read in the next one.
0923   EA7E CD FE E5    	CALL	READFCB
0924   EA81 E1          	POP	HL
0925   EA82 C2 A0 EA    	JP	NZ,TYPE4	;end or error?
0926   EA85 AF          	XOR	A		;ok, clear byte counter.
0927   EA86 77          	LD	(HL),A
0928   EA87 34          TYPE3: 	INC	(HL)		;count this byte.
0929   EA88 21 80 00    	LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
0930   EA8B CD 59 E7    	CALL	ADDHL
0931   EA8E 7E          	LD	A,(HL)
0932   EA8F FE 1A       	CP	CNTRLZ		;end of file mark?
0933   EA91 CA 86 EC    	JP	Z,GETBACK
0934   EA94 CD 8C E5    	CALL	PRINT		;no, print it.
0935   EA97 CD C2 E6    	CALL	CHKCON		;check console, quit if anything ready.
0936   EA9A C2 86 EC    	JP	NZ,GETBACK
0937   EA9D C3 74 EA    	JP	TYPE1
0938   EAA0             ;
0939   EAA0             ;   Get here on an end of file or read error.
0940   EAA0             ;
0941   EAA0 3D          TYPE4: 	DEC	A		;read error?
0942   EAA1 CA 86 EC    	JP	Z,GETBACK
0943   EAA4 CD D9 E8    	CALL	RDERROR		;yes, print message.
0944   EAA7 CD 66 E9    TYPE5: 	CALL	RESETDR		;and reset proper drive
0945   EAAA C3 09 E7    	JP	SYNERR		;now print file name with problem.
0946   EAAD             ;
0947   EAAD             ;**************************************************************
0948   EAAD             ;*
0949   EAAD             ;*            S A V E   C O M M A N D
0950   EAAD             ;*
0951   EAAD             ;**************************************************************
0952   EAAD             ;
0953   EAAD CD F8 E8    SAVE: 	CALL	DECODE		;get numeric number that follows SAVE.
0954   EAB0 F5          	PUSH	AF		;save number of pages to write.
0955   EAB1 CD 5E E7    	CALL	CONVFST		;convert file name.
0956   EAB4 C2 09 E7    	JP	NZ,SYNERR	;wild cards not allowed.
0957   EAB7 CD 54 E9    	CALL	DSELECT		;select specified drive.
0958   EABA 11 CD EC    	LD	DE,FCB		;now delete this file.
0959   EABD D5          	PUSH	DE
0960   EABE CD EF E5    	CALL	DELETE
0961   EAC1 D1          	POP	DE
0962   EAC2 CD 09 E6    	CALL	CREATE		;and create it again.
0963   EAC5 CA FB EA    	JP	Z,SAVE3		;can't create?
0964   EAC8 AF          	XOR	A		;clear record number byte.
0965   EAC9 32 ED EC    	LD	(FCB+32),A
0966   EACC F1          	POP	AF		;convert pages to sectors.
0967   EACD 6F          	LD	L,A
0968   EACE 26 00       	LD	H,0
0969   EAD0 29          	ADD	HL,HL		;(HL)=number of sectors to write.
0970   EAD1 11 00 01    	LD	DE,TBASE	;and we start from here.
0971   EAD4 7C          SAVE1: 	LD	A,H		;done yet?
0972   EAD5 B5          	OR	L
0973   EAD6 CA F1 EA    	JP	Z,SAVE2
0974   EAD9 2B          	DEC	HL		;nope, count this and compute the start
0975   EADA E5          	PUSH	HL		;of the next 128 byte sector.
0976   EADB 21 80 00    	LD	HL,128
0977   EADE 19          	ADD	HL,DE
0978   EADF E5          	PUSH	HL		;save it and set the transfer address.
0979   EAE0 CD D8 E6    	CALL	DMASET
0980   EAE3 11 CD EC    	LD	DE,FCB		;write out this sector now.
0981   EAE6 CD 04 E6    	CALL	WRTREC
0982   EAE9 D1          	POP	DE		;reset (DE) to the start of the last sector.
0983   EAEA E1          	POP	HL		;restore sector count.
0984   EAEB C2 FB EA    	JP	NZ,SAVE3	;write error?
0985   EAEE C3 D4 EA    	JP	SAVE1
0986   EAF1             ;
0987   EAF1             ;   Get here after writing all of the file.
0988   EAF1             ;
0989   EAF1 11 CD EC    SAVE2: 	LD	DE,FCB		;now close the file.
0990   EAF4 CD DA E5    	CALL	CLOSE
0991   EAF7 3C          	INC	A		;did it close ok?
0992   EAF8 C2 01 EB    	JP	NZ,SAVE4
0993   EAFB             ;
0994   EAFB             ;   Print out error message (no space).
0995   EAFB             ;
0996   EAFB 01 07 EB    SAVE3: 	LD	BC,NOSPACE
0997   EAFE CD A7 E5    	CALL	PLINE
0998   EB01 CD D5 E6    SAVE4: 	CALL	STDDMA		;reset the standard dma address.
0999   EB04 C3 86 EC    	JP	GETBACK
1000   EB07             NOSPACE: .DB	"No space"
1000   EB07 4E6F207370616365
1001   EB0F 00          	.DB	0
1002   EB10             ;
1003   EB10             ;**************************************************************
1004   EB10             ;*
1005   EB10             ;*           R E N A M E   C O M M A N D
1006   EB10             ;*
1007   EB10             ;**************************************************************
1008   EB10             ;
1009   EB10 CD 5E E7    RENAME: 	CALL	CONVFST		;convert first file name.
1010   EB13 C2 09 E7    	JP	NZ,SYNERR	;wild cards not allowed.
1011   EB16 3A F0 EC    	LD	A,(CHGDRV)	;remember any change in drives specified.
1012   EB19 F5          	PUSH	AF
1013   EB1A CD 54 E9    	CALL	DSELECT		;and select this drive.
1014   EB1D CD E9 E5    	CALL	SRCHFCB		;is this file present?
1015   EB20 C2 79 EB    	JP	NZ,RENAME6	;yes, print error message.
1016   EB23 21 CD EC    	LD	HL,FCB		;yes, move this name into second slot.
1017   EB26 11 DD EC    	LD	DE,FCB+16
1018   EB29 06 10       	LD	B,16
1019   EB2B CD 42 E9    	CALL	HL2DE
1020   EB2E 2A 88 E5    	LD	HL,(INPOINT)	;get input pointer.
1021   EB31 EB          	EX	DE,HL
1022   EB32 CD 4F E7    	CALL	NONBLANK	;get next non blank character.
1023   EB35 FE 3D       	CP	'='		;only allow an '=' or '_' seperator.
1024   EB37 CA 3F EB    	JP	Z,RENAME1
1025   EB3A FE 5F       	CP	'_'
1026   EB3C C2 73 EB    	JP	NZ,RENAME5
1027   EB3F EB          RENAME1: EX	DE,HL
1028   EB40 23          	INC	HL		;ok, skip seperator.
1029   EB41 22 88 E5    	LD	(INPOINT),HL	;save input line pointer.
1030   EB44 CD 5E E7    	CALL	CONVFST		;convert this second file name now.
1031   EB47 C2 73 EB    	JP	NZ,RENAME5	;again, no wild cards.
1032   EB4A F1          	POP	AF		;if a drive was specified, then it
1033   EB4B 47          	LD	B,A		;must be the same as before.
1034   EB4C 21 F0 EC    	LD	HL,CHGDRV
1035   EB4F 7E          	LD	A,(HL)
1036   EB50 B7          	OR	A
1037   EB51 CA 59 EB    	JP	Z,RENAME2
1038   EB54 B8          	CP	B
1039   EB55 70          	LD	(HL),B
1040   EB56 C2 73 EB    	JP	NZ,RENAME5	;they were different, error.
1041   EB59 70          RENAME2: LD	(HL),B		;	reset as per the first file specification.
1042   EB5A AF          	XOR	A
1043   EB5B 32 CD EC    	LD	(FCB),A		;clear the drive byte of the fcb.
1044   EB5E CD E9 E5    RENAME3: CALL	SRCHFCB		;and go look for second file.
1045   EB61 CA 6D EB    	JP	Z,RENAME4	;doesn't exist?
1046   EB64 11 CD EC    	LD	DE,FCB
1047   EB67 CD 0E E6    	CALL	RENAM		;ok, rename the file.
1048   EB6A C3 86 EC    	JP	GETBACK
1049   EB6D             ;
1050   EB6D             ;   Process rename errors here.
1051   EB6D             ;
1052   EB6D CD EA E8    RENAME4: CALL	NONE		;file not there.
1053   EB70 C3 86 EC    	JP	GETBACK
1054   EB73 CD 66 E9    RENAME5: CALL	RESETDR		;bad command format.
1055   EB76 C3 09 E7    	JP	SYNERR
1056   EB79 01 82 EB    RENAME6: LD	BC,EXISTS	;destination file already exists.
1057   EB7C CD A7 E5    	CALL	PLINE
1058   EB7F C3 86 EC    	JP	GETBACK
1059   EB82             EXISTS: 	.DB	"File exists"
1059   EB82 46696C6520657869737473
1060   EB8D 00          	.DB	0
1061   EB8E             ;
1062   EB8E             ;**************************************************************
1063   EB8E             ;*
1064   EB8E             ;*             U S E R   C O M M A N D
1065   EB8E             ;*
1066   EB8E             ;**************************************************************
1067   EB8E             ;
1068   EB8E CD F8 E8    USER: 	CALL	DECODE		;get numeric value following command.
1069   EB91 FE 10       	CP	16		;legal user number?
1070   EB93 D2 09 E7    	JP	NC,SYNERR
1071   EB96 5F          	LD	E,A		;yes but is there anything else?
1072   EB97 3A CE EC    	LD	A,(FCB+1)
1073   EB9A FE 20       	CP	' '
1074   EB9C CA 09 E7    	JP	Z,SYNERR	;yes, that is not allowed.
1075   EB9F CD 15 E6    	CALL	GETSETUC	;ok, set user code.
1076   EBA2 C3 89 EC    	JP	GETBACK1
1077   EBA5             ;
1078   EBA5             ;**************************************************************
1079   EBA5             ;*
1080   EBA5             ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1081   EBA5             ;*
1082   EBA5             ;**************************************************************
1083   EBA5             ;
1084   EBA5 CD F5 E6    UNKNOWN: CALL	VERIFY		;check for valid system (why?).
1085   EBA8 3A CE EC    	LD	A,(FCB+1)	;anything to execute?
1086   EBAB FE 20       	CP	' '
1087   EBAD C2 C4 EB    	JP	NZ,UNKWN1
1088   EBB0 3A F0 EC    	LD	A,(CHGDRV)	;nope, only a drive change?
1089   EBB3 B7          	OR	A
1090   EBB4 CA 89 EC    	JP	Z,GETBACK1	;neither???
1091   EBB7 3D          	DEC	A
1092   EBB8 32 EF EC    	LD	(CDRIVE),A	;ok, store new drive.
1093   EBBB CD 29 E6    	CALL	MOVECD		;set (TDRIVE) also.
1094   EBBE CD BD E5    	CALL	DSKSEL		;and select this drive.
1095   EBC1 C3 89 EC    	JP	GETBACK1	;then return.
1096   EBC4             ;
1097   EBC4             ;   Here a file name was typed. Prepare to execute it.
1098   EBC4             ;
1099   EBC4 11 D6 EC    UNKWN1: 	LD	DE,FCB+9	;an extension specified?
1100   EBC7 1A          	LD	A,(DE)
1101   EBC8 FE 20       	CP	' '
1102   EBCA C2 09 E7    	JP	NZ,SYNERR	;yes, not allowed.
1103   EBCD D5          UNKWN2: 	PUSH	DE
1104   EBCE CD 54 E9    	CALL	DSELECT		;select specified drive.
1105   EBD1 D1          	POP	DE
1106   EBD2 21 83 EC    	LD	HL,COMFILE	;set the extension to 'COM'.
1107   EBD5 CD 40 E9    	CALL	MOVE3
1108   EBD8 CD D0 E5    	CALL	OPENFCB		;and open this file.
1109   EBDB CA 6B EC    	JP	Z,UNKWN9	;not present?
1110   EBDE             ;
1111   EBDE             ;   Load in the program.
1112   EBDE             ;
1113   EBDE 21 00 01    	LD	HL,TBASE	;store the program starting here.
1114   EBE1 E5          UNKWN3: 	PUSH	HL
1115   EBE2 EB          	EX	DE,HL
1116   EBE3 CD D8 E6    	CALL	DMASET		;set transfer address.
1117   EBE6 11 CD EC    	LD	DE,FCB		;and read the next record.
1118   EBE9 CD F9 E5    	CALL	RDREC
1119   EBEC C2 01 EC    	JP	NZ,UNKWN4	;end of file or read error?
1120   EBEF E1          	POP	HL		;nope, bump pointer for next sector.
1121   EBF0 11 80 00    	LD	DE,128
1122   EBF3 19          	ADD	HL,DE
1123   EBF4 11 00 E5    	LD	DE,CBASE	;enough room for the whole file?
1124   EBF7 7D          	LD	A,L
1125   EBF8 93          	SUB	E
1126   EBF9 7C          	LD	A,H
1127   EBFA 9A          	SBC	A,D
1128   EBFB D2 71 EC    	JP	NC,UNKWN0	;no, it can't fit.
1129   EBFE C3 E1 EB    	JP	UNKWN3
1130   EC01             ;
1131   EC01             ;   Get here after finished reading.
1132   EC01             ;
1133   EC01 E1          UNKWN4: 	POP	HL
1134   EC02 3D          	DEC	A		;normal end of file?
1135   EC03 C2 71 EC    	JP	NZ,UNKWN0
1136   EC06 CD 66 E9    	CALL	RESETDR		;yes, reset previous drive.
1137   EC09 CD 5E E7    	CALL	CONVFST		;convert the first file name that follows
1138   EC0C 21 F0 EC    	LD	HL,CHGDRV	;command name.
1139   EC0F E5          	PUSH	HL
1140   EC10 7E          	LD	A,(HL)		;set drive code in default fcb.
1141   EC11 32 CD EC    	LD	(FCB),A
1142   EC14 3E 10       	LD	A,16		;put second name 16 bytes later.
1143   EC16 CD 60 E7    	CALL	CONVERT		;convert second file name.
1144   EC19 E1          	POP	HL
1145   EC1A 7E          	LD	A,(HL)		;and set the drive for this second file.
1146   EC1B 32 DD EC    	LD	(FCB+16),A
1147   EC1E AF          	XOR	A		;clear record byte in fcb.
1148   EC1F 32 ED EC    	LD	(FCB+32),A
1149   EC22 11 5C 00    	LD	DE,TFCB		;move it into place at(005Ch).
1150   EC25 21 CD EC    	LD	HL,FCB
1151   EC28 06 21       	LD	B,33
1152   EC2A CD 42 E9    	CALL	HL2DE
1153   EC2D 21 08 E5    	LD	HL,INBUFF+2	;now move the remainder of the input
1154   EC30 7E          UNKWN5: 	LD	A,(HL)		;line down to (0080h). Look for a non blank.
1155   EC31 B7          	OR	A		;or a null.
1156   EC32 CA 3E EC    	JP	Z,UNKWN6
1157   EC35 FE 20       	CP	' '
1158   EC37 CA 3E EC    	JP	Z,UNKWN6
1159   EC3A 23          	INC	HL
1160   EC3B C3 30 EC    	JP	UNKWN5
1161   EC3E             ;
1162   EC3E             ;   Do the line move now. It ends in a null byte.
1163   EC3E             ;
1164   EC3E 06 00       UNKWN6: 	LD	B,0		;keep a character count.
1165   EC40 11 81 00    	LD	DE,TBUFF+1	;data gets put here.
1166   EC43 7E          UNKWN7: 	LD	A,(HL)		;move it now.
1167   EC44 12          	LD	(DE),A
1168   EC45 B7          	OR	A
1169   EC46 CA 4F EC    	JP	Z,UNKWN8
1170   EC49 04          	INC	B
1171   EC4A 23          	INC	HL
1172   EC4B 13          	INC	DE
1173   EC4C C3 43 EC    	JP	UNKWN7
1174   EC4F 78          UNKWN8: 	LD	A,B		;now store the character count.
1175   EC50 32 80 00    	LD	(TBUFF),A
1176   EC53 CD 98 E5    	CALL	CRLF		;clean up the screen.
1177   EC56 CD D5 E6    	CALL	STDDMA		;set standard transfer address.
1178   EC59 CD 1A E6    	CALL	SETCDRV		;reset current drive.
1179   EC5C CD 00 01    	CALL	TBASE		;and execute the program.
1180   EC5F             ;
1181   EC5F             ;   Transiant programs return here (or reboot).
1182   EC5F             ;
1183   EC5F 31 AB EC    	LD	SP,BATCH	;set stack first off.
1184   EC62 CD 29 E6    	CALL	MOVECD		;move current drive into place (TDRIVE).
1185   EC65 CD BD E5    	CALL	DSKSEL		;and reselect it.
1186   EC68 C3 82 E8    	JP	CMMND1		;back to comand mode.
1187   EC6B             ;
1188   EC6B             ;   Get here if some error occured.
1189   EC6B             ;
1190   EC6B CD 66 E9    UNKWN9: 	CALL	RESETDR		;inproper format.
1191   EC6E C3 09 E7    	JP	SYNERR
1192   EC71 01 7A EC    UNKWN0: 	LD	BC,BADLOAD	;read error or won't fit.
1193   EC74 CD A7 E5    	CALL	PLINE
1194   EC77 C3 86 EC    	JP	GETBACK
1195   EC7A             BADLOAD: .DB	"Bad load"
1195   EC7A 426164206C6F6164
1196   EC82 00          	.DB	0
1197   EC83 43 4F 4D    COMFILE: .DB	"COM"		;command file extension.
1198   EC86             ;
1199   EC86             ;   Get here to return to command level. We will reset the
1200   EC86             ; previous active drive and then either return to command
1201   EC86             ; level directly or print error message and then return.
1202   EC86             ;
1203   EC86 CD 66 E9    GETBACK: CALL	RESETDR		;reset previous drive.
1204   EC89 CD 5E E7    GETBACK1:  CALL	CONVFST		;convert first name in (FCB).
1205   EC8C 3A CE EC    	LD	A,(FCB+1)	;if this was just a drive change request,
1206   EC8F D6 20       	SUB	' '		;make sure it was valid.
1207   EC91 21 F0 EC    	LD	HL,CHGDRV
1208   EC94 B6          	OR	(HL)
1209   EC95 C2 09 E7    	JP	NZ,SYNERR
1210   EC98 C3 82 E8    	JP	CMMND1		;ok, return to command level.
1211   EC9B             ;
1212   EC9B             ;   ccp stack area.
1213   EC9B             ;
1214   EC9B             	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1214   EC9B 00000000000000000000000000000000
1215   ECAB             CCPSTACK .EQU	$	;end of ccp stack area.
1216   ECAB             ;
1217   ECAB             ;   Batch (or SUBMIT) processing information storage.
1218   ECAB             ;
1219   ECAB 00          BATCH: 	.DB	0		;batch mode flag (0=not active).
1220   ECAC 00          BATCHFCB:  .DB	0
1221   ECAD             	.DB "$$$     SUB"
1221   ECAD 2424242020202020535542
1222   ECB8             	.DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1222   ECB8 000000000000000000000000000000000000000000
1223   ECCD             ;
1224   ECCD             ;   File control block setup by the CCP.
1225   ECCD             ;
1226   ECCD 00          FCB: 	.DB	0
1227   ECCE             	.DB	"           "
1227   ECCE 2020202020202020202020
1228   ECD9 0000000000  	.DB	0,0,0,0,0
1229   ECDE             	.DB	"           "
1229   ECDE 2020202020202020202020
1230   ECE9 0000000000  	.DB	0,0,0,0,0
1231   ECEE 00          RTNCODE: .DB	0		;status returned from bdos call.
1232   ECEF 00          CDRIVE: 	.DB	0		;currently active drive.
1233   ECF0 00          CHGDRV: 	.DB	0		;change in drives flag (0=no change).
1234   ECF1 00 00       NBYTES: 	.DW	0		;byte counter used by TYPE.
1235   ECF3             ;
1236   ECF3             ;   Room for expansion?
1237   ECF3             ;
1238   ECF3             	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0
1238   ECF3 00000000000000000000000000
1239   ED00             ;
1240   ED00             ;   Note that the following six bytes must match those at
1241   ED00             ; (PATTRN1) or cp/m will HALT. Why?
1242   ED00             ;
1243   ED00             PATTRN2: .DB	0,22,0,0,0,0	;(* serial number bytes *).
1243   ED00 001600000000
1244   ED06             ;
1245   ED06             ;**************************************************************
1246   ED06             ;*
1247   ED06             ;*                    B D O S   E N T R Y
1248   ED06             ;*
1249   ED06             ;**************************************************************
1250   ED06             ;
1251   ED06 C3 11 ED    FBASE: 	JP	FBASE1
1252   ED09             ;
1253   ED09             ;   Bdos error table.
1254   ED09             ;
1255   ED09 99 ED       BADSCTR: .DW	ERROR1		;bad sector on read or write.
1256   ED0B A5 ED       BADSLCT: .DW	ERROR2		;bad disk select.
1257   ED0D AB ED       RODISK: 	.DW	ERROR3		;disk is read only.
1258   ED0F B1 ED       ROFILE: 	.DW	ERROR4		;file is read only.
1259   ED11             ;
1260   ED11             ;   Entry into bdos. (DE) or (E) are the parameters passed. The
1261   ED11             ; function number desired is in register (C).
1262   ED11             ;
1263   ED11 EB          FBASE1: 	EX	DE,HL		;save the (DE) parameters.
1264   ED12 22 43 F0    	LD	(PARAMS),HL
1265   ED15 EB          	EX	DE,HL
1266   ED16 7B          	LD	A,E		;and save register (E) in particular.
1267   ED17 32 D6 FA    	LD	(EPARAM),A
1268   ED1A 21 00 00    	LD	HL,0
1269   ED1D 22 45 F0    	LD	(STATUS),HL	;clear return status.
1270   ED20 39          	ADD	HL,SP
1271   ED21 22 0F F0    	LD	(USRSTACK),HL	;save users stack pointer.
1272   ED24 31 41 F0    	LD	SP,STKAREA	;and set our own.
1273   ED27 AF          	XOR	A		;clear auto select storage space.
1274   ED28 32 E0 FA    	LD	(AUTOFLAG),A
1275   ED2B 32 DE FA    	LD	(AUTO),A
1276   ED2E 21 74 FA    	LD	HL,GOBACK	;set return address.
1277   ED31 E5          	PUSH	HL
1278   ED32 79          	LD	A,C		;get function number.
1279   ED33 FE 29       	CP	NFUNCTS		;valid function number?
1280   ED35 D0          	RET	NC
1281   ED36 4B          	LD	C,E		;keep single register function here.
1282   ED37 21 47 ED    	LD	HL,FUNCTNS	;now look thru the function table.
1283   ED3A 5F          	LD	E,A
1284   ED3B 16 00       	LD	D,0		;(DE)=function number.
1285   ED3D 19          	ADD	HL,DE
1286   ED3E 19          	ADD	HL,DE		;(HL)=(start of table)+2*(function number).
1287   ED3F 5E          	LD	E,(HL)
1288   ED40 23          	INC	HL
1289   ED41 56          	LD	D,(HL)		;now (DE)=address for this function.
1290   ED42 2A 43 F0    	LD	HL,(PARAMS)	;retrieve parameters.
1291   ED45 EB          	EX	DE,HL		;now (DE) has the original parameters.
1292   ED46 E9          	JP	(HL)		;execute desired function.
1293   ED47             ;
1294   ED47             ;   BDOS function jump table.
1295   ED47             ;
1296   ED47             NFUNCTS .EQU	41		;number of functions in followin table.
1297   ED47             ;
1298   ED47             FUNCTNS: .DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
1298   ED47 03FBC8EF90EECEEF12FB0FFBD4EFEDEF
1299   ED57             	.DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
1299   ED57 F3EFF8EFE1EEFEEF7EF983F945F99CF9
1300   ED67             	.DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
1300   ED67 A5F9ABF9C8F9D7F9E0F9E6F9ECF9
1301   ED75             	.DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
1301   ED75 F5F9FEF904FA0AFA11FA2CF217FA1DFA
1302   ED85             	.DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
1302   ED85 26FA2DFA41FA47FA4DFA0EF953FA04F0
1303   ED95 04 F0 9B FA 	.DW	RTN,WTSPECL
1304   ED99             ;
1305   ED99             ;   Bdos error message section.
1306   ED99             ;
1307   ED99 21 CA ED    ERROR1: 	LD	HL,BADSEC	;bad sector message.
1308   ED9C CD E5 ED    	CALL	PRTERR		;print it and get a 1 char responce.
1309   ED9F FE 03       	CP	CNTRLC		;re-boot request (control-c)?
1310   EDA1 CA 00 00    	JP	Z,0		;yes.
1311   EDA4 C9          	RET			;no, return to retry i/o function.
1312   EDA5             ;
1313   EDA5 21 D5 ED    ERROR2: 	LD	HL,BADSEL	;bad drive selected.
1314   EDA8 C3 B4 ED    	JP	ERROR5
1315   EDAB             ;
1316   EDAB 21 E1 ED    ERROR3: 	LD	HL,DISKRO	;disk is read only.
1317   EDAE C3 B4 ED    	JP	ERROR5
1318   EDB1             ;
1319   EDB1 21 DC ED    ERROR4: 	LD	HL,FILERO	;file is read only.
1320   EDB4             ;
1321   EDB4 CD E5 ED    ERROR5: 	CALL	PRTERR
1322   EDB7 C3 00 00    	JP	0		;always reboot on these errors.
1323   EDBA             ;
1324   EDBA             BDOSERR: .DB	"Bdos Err On "
1324   EDBA 42646F7320457272204F6E20
1325   EDC6 20 3A 20 24 BDOSDRV: .DB	" : $"
1326   EDCA             BADSEC: 	.DB	"Bad Sector$"
1326   EDCA 42616420536563746F7224
1327   EDD5             BADSEL: 	.DB	"Select$"
1327   EDD5 53656C65637424
1328   EDDC 46696C6520  FILERO: 	.DB	"File "
1329   EDE1 52 2F 4F 24 DISKRO: 	.DB	"R/O$"
1330   EDE5             ;
1331   EDE5             ;   Print bdos error message.
1332   EDE5             ;
1333   EDE5 E5          PRTERR: 	PUSH	HL		;save second message pointer.
1334   EDE6 CD C9 EE    	CALL	OUTCRLF		;send (cr)(lf).
1335   EDE9 3A 42 F0    	LD	A,(ACTIVE)	;get active drive.
1336   EDEC C6 41       	ADD	A,'A'		;make ascii.
1337   EDEE 32 C6 ED    	LD	(BDOSDRV),A	;and put in message.
1338   EDF1 01 BA ED    	LD	BC,BDOSERR	;and print it.
1339   EDF4 CD D3 EE    	CALL	PRTMESG
1340   EDF7 C1          	POP	BC		;print second message line now.
1341   EDF8 CD D3 EE    	CALL	PRTMESG
1342   EDFB             ;
1343   EDFB             ;   Get an input character. We will check our 1 character
1344   EDFB             ; buffer first. This may be set by the console status routine.
1345   EDFB             ;
1346   EDFB 21 0E F0    GETCHAR: LD	HL,CHARBUF	;check character buffer.
1347   EDFE 7E          	LD	A,(HL)		;anything present already?
1348   EDFF 36 00       	LD	(HL),0		;...either case clear it.
1349   EE01 B7          	OR	A
1350   EE02 C0          	RET	NZ		;yes, use it.
1351   EE03 C3 09 FB    	JP	CONIN		;nope, go get a character responce.
1352   EE06             ;
1353   EE06             ;   Input and echo a character.
1354   EE06             ;
1355   EE06 CD FB ED    GETECHO: CALL	GETCHAR		;input a character.
1356   EE09 CD 14 EE    	CALL	CHKCHAR		;carriage control?
1357   EE0C D8          	RET	C		;no, a regular control char so don't echo.
1358   EE0D F5          	PUSH	AF		;ok, save character now.
1359   EE0E 4F          	LD	C,A
1360   EE0F CD 90 EE    	CALL	OUTCON		;and echo it.
1361   EE12 F1          	POP	AF		;get character and return.
1362   EE13 C9          	RET	
1363   EE14             ;
1364   EE14             ;   Check character in (A). Set the zero flag on a carriage
1365   EE14             ; control character and the carry flag on any other control
1366   EE14             ; character.
1367   EE14             ;
1368   EE14 FE 0D       CHKCHAR: CP	CR		;check for carriage return, line feed, backspace,
1369   EE16 C8          	RET	Z		;or a tab.
1370   EE17 FE 0A       	CP	LF
1371   EE19 C8          	RET	Z
1372   EE1A FE 09       	CP	TAB
1373   EE1C C8          	RET	Z
1374   EE1D FE 08       	CP	BS
1375   EE1F C8          	RET	Z
1376   EE20 FE 20       	CP	' '		;other control char? Set carry flag.
1377   EE22 C9          	RET	
1378   EE23             ;
1379   EE23             ;   Check the console during output. Halt on a control-s, then
1380   EE23             ; reboot on a control-c. If anything else is ready, clear the
1381   EE23             ; zero flag and return (the calling routine may want to do
1382   EE23             ; something).
1383   EE23             ;
1384   EE23 3A 0E F0    CKCONSOL:  LD	A,(CHARBUF)	;check buffer.
1385   EE26 B7          	OR	A		;if anything, just return without checking.
1386   EE27 C2 45 EE    	JP	NZ,CKCON2
1387   EE2A CD 06 FB    	CALL	CONST		;nothing in buffer. Check console.
1388   EE2D E6 01       	AND	01H		;look at bit 0.
1389   EE2F C8          	RET	Z		;return if nothing.
1390   EE30 CD 09 FB    	CALL	CONIN		;ok, get it.
1391   EE33 FE 13       	CP	CNTRLS		;if not control-s, return with zero cleared.
1392   EE35 C2 42 EE    	JP	NZ,CKCON1
1393   EE38 CD 09 FB    	CALL	CONIN		;halt processing until another char
1394   EE3B FE 03       	CP	CNTRLC		;is typed. Control-c?
1395   EE3D CA 00 00    	JP	Z,0		;yes, reboot now.
1396   EE40 AF          	XOR	A		;no, just pretend nothing was ever ready.
1397   EE41 C9          	RET	
1398   EE42 32 0E F0    CKCON1: 	LD	(CHARBUF),A	;save character in buffer for later processing.
1399   EE45 3E 01       CKCON2: 	LD	A,1		;set (A) to non zero to mean something is ready.
1400   EE47 C9          	RET	
1401   EE48             ;
1402   EE48             ;   Output (C) to the screen. If the printer flip-flop flag
1403   EE48             ; is set, we will send character to printer also. The console
1404   EE48             ; will be checked in the process.
1405   EE48             ;
1406   EE48 3A 0A F0    OUTCHAR: LD	A,(OUTFLAG)	;check output flag.
1407   EE4B B7          	OR	A		;anything and we won't generate output.
1408   EE4C C2 62 EE    	JP	NZ,OUTCHR1
1409   EE4F C5          	PUSH	BC
1410   EE50 CD 23 EE    	CALL	CKCONSOL	;check console (we don't care whats there).
1411   EE53 C1          	POP	BC
1412   EE54 C5          	PUSH	BC
1413   EE55 CD 0C FB    	CALL	CONOUT		;output (C) to the screen.
1414   EE58 C1          	POP	BC
1415   EE59 C5          	PUSH	BC
1416   EE5A 3A 0D F0    	LD	A,(PRTFLAG)	;check printer flip-flop flag.
1417   EE5D B7          	OR	A
1418   EE5E C4 0F FB    	CALL	NZ,LIST		;print it also if non-zero.
1419   EE61 C1          	POP	BC
1420   EE62 79          OUTCHR1: LD	A,C		;update cursors position.
1421   EE63 21 0C F0    	LD	HL,CURPOS
1422   EE66 FE 7F       	CP	DEL		;rubouts don't do anything here.
1423   EE68 C8          	RET	Z
1424   EE69 34          	INC	(HL)		;bump line pointer.
1425   EE6A FE 20       	CP	' '		;and return if a normal character.
1426   EE6C D0          	RET	NC
1427   EE6D 35          	DEC	(HL)		;restore and check for the start of the line.
1428   EE6E 7E          	LD	A,(HL)
1429   EE6F B7          	OR	A
1430   EE70 C8          	RET	Z		;ingnore control characters at the start of the line.
1431   EE71 79          	LD	A,C
1432   EE72 FE 08       	CP	BS		;is it a backspace?
1433   EE74 C2 79 EE    	JP	NZ,OUTCHR2
1434   EE77 35          	DEC	(HL)		;yes, backup pointer.
1435   EE78 C9          	RET	
1436   EE79 FE 0A       OUTCHR2: CP	LF		;is it a line feed?
1437   EE7B C0          	RET	NZ		;ignore anything else.
1438   EE7C 36 00       	LD	(HL),0		;reset pointer to start of line.
1439   EE7E C9          	RET	
1440   EE7F             ;
1441   EE7F             ;   Output (A) to the screen. If it is a control character
1442   EE7F             ; (other than carriage control), use ^x format.
1443   EE7F             ;
1444   EE7F 79          SHOWIT: 	LD	A,C
1445   EE80 CD 14 EE    	CALL	CHKCHAR		;check character.
1446   EE83 D2 90 EE    	JP	NC,OUTCON	;not a control, use normal output.
1447   EE86 F5          	PUSH	AF
1448   EE87 0E 5E       	LD	C,'^'		;for a control character, preceed it with '^'.
1449   EE89 CD 48 EE    	CALL	OUTCHAR
1450   EE8C F1          	POP	AF
1451   EE8D F6 40       	OR	'@'		;and then use the letter equivelant.
1452   EE8F 4F          	LD	C,A
1453   EE90             ;
1454   EE90             ;   Function to output (C) to the console device and expand tabs
1455   EE90             ; if necessary.
1456   EE90             ;
1457   EE90 79          OUTCON: 	LD	A,C
1458   EE91 FE 09       	CP	TAB		;is it a tab?
1459   EE93 C2 48 EE    	JP	NZ,OUTCHAR	;use regular output.
1460   EE96 0E 20       OUTCON1: LD	C,' '		;yes it is, use spaces instead.
1461   EE98 CD 48 EE    	CALL	OUTCHAR
1462   EE9B 3A 0C F0    	LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
1463   EE9E             
1464   EE9E E6 07       	AND	07H		;position.
1465   EEA0 C2 96 EE    	JP	NZ,OUTCON1
1466   EEA3 C9          	RET	
1467   EEA4             ;
1468   EEA4             ;   Echo a backspace character. Erase the prevoius character
1469   EEA4             ; on the screen.
1470   EEA4             ;
1471   EEA4 CD AC EE    BACKUP: 	CALL	BACKUP1		;backup the screen 1 place.
1472   EEA7 0E 20       	LD	C,' '		;then blank that character.
1473   EEA9 CD 0C FB    	CALL	CONOUT
1474   EEAC 0E 08       BACKUP1: LD	C,BS		;then back space once more.
1475   EEAE C3 0C FB    	JP	CONOUT
1476   EEB1             ;
1477   EEB1             ;   Signal a deleted line. Print a '#' at the end and start
1478   EEB1             ; over.
1479   EEB1             ;
1480   EEB1 0E 23       NEWLINE: LD	C,'#'
1481   EEB3 CD 48 EE    	CALL	OUTCHAR		;print this.
1482   EEB6 CD C9 EE    	CALL	OUTCRLF		;start new line.
1483   EEB9 3A 0C F0    NEWLN1: 	LD	A,(CURPOS)	;move the cursor to the starting position.
1484   EEBC 21 0B F0    	LD	HL,STARTING
1485   EEBF BE          	CP	(HL)
1486   EEC0 D0          	RET	NC		;there yet?
1487   EEC1 0E 20       	LD	C,' '
1488   EEC3 CD 48 EE    	CALL	OUTCHAR		;nope, keep going.
1489   EEC6 C3 B9 EE    	JP	NEWLN1
1490   EEC9             ;
1491   EEC9             ;   Output a (cr) (lf) to the console device (screen).
1492   EEC9             ;
1493   EEC9 0E 0D       OUTCRLF: LD	C,CR
1494   EECB CD 48 EE    	CALL	OUTCHAR
1495   EECE 0E 0A       	LD	C,LF
1496   EED0 C3 48 EE    	JP	OUTCHAR
1497   EED3             ;
1498   EED3             ;   Print message pointed to by (BC). It will end with a '$'.
1499   EED3             ;
1500   EED3 0A          PRTMESG: LD	A,(BC)		;check for terminating character.
1501   EED4 FE 24       	CP	'$'
1502   EED6 C8          	RET	Z
1503   EED7 03          	INC	BC
1504   EED8 C5          	PUSH	BC		;otherwise, bump pointer and print it.
1505   EED9 4F          	LD	C,A
1506   EEDA CD 90 EE    	CALL	OUTCON
1507   EEDD C1          	POP	BC
1508   EEDE C3 D3 EE    	JP	PRTMESG
1509   EEE1             ;
1510   EEE1             ;   Function to execute a buffered read.
1511   EEE1             ;
1512   EEE1 3A 0C F0    RDBUFF: 	LD	A,(CURPOS)	;use present location as starting one.
1513   EEE4 32 0B F0    	LD	(STARTING),A
1514   EEE7 2A 43 F0    	LD	HL,(PARAMS)	;get the maximum buffer space.
1515   EEEA 4E          	LD	C,(HL)
1516   EEEB 23          	INC	HL		;point to first available space.
1517   EEEC E5          	PUSH	HL		;and save.
1518   EEED 06 00       	LD	B,0		;keep a character count.
1519   EEEF C5          RDBUF1: 	PUSH	BC
1520   EEF0 E5          	PUSH	HL
1521   EEF1 CD FB ED    RDBUF2: 	CALL	GETCHAR		;get the next input character.
1522   EEF4 00          	NOP ; AND	7FH		;strip bit 7.
1523   EEF5 00          	NOP ;
1524   EEF6 E1          	POP	HL		;reset registers.
1525   EEF7 C1          	POP	BC
1526   EEF8 FE 0D       	CP	CR		;en of the line?
1527   EEFA CA C1 EF    	JP	Z,RDBUF17
1528   EEFD FE 0A       	CP	LF
1529   EEFF CA C1 EF    	JP	Z,RDBUF17
1530   EF02 FE 08       	CP	BS		;how about a backspace?
1531   EF04 C2 16 EF    	JP	NZ,RDBUF3
1532   EF07 78          	LD	A,B		;yes, but ignore at the beginning of the line.
1533   EF08 B7          	OR	A
1534   EF09 CA EF EE    	JP	Z,RDBUF1
1535   EF0C 05          	DEC	B		;ok, update counter.
1536   EF0D 3A 0C F0    	LD	A,(CURPOS)	;if we backspace to the start of the line,
1537   EF10 32 0A F0    	LD	(OUTFLAG),A	;treat as a cancel (control-x).
1538   EF13 C3 70 EF    	JP	RDBUF10
1539   EF16 FE 7F       RDBUF3: 	CP	DEL		;user typed a rubout?
1540   EF18 C2 26 EF    	JP	NZ,RDBUF4
1541   EF1B 78          	LD	A,B		;ignore at the start of the line.
1542   EF1C B7          	OR	A
1543   EF1D CA EF EE    	JP	Z,RDBUF1
1544   EF20 7E          	LD	A,(HL)		;ok, echo the prevoius character.
1545   EF21 05          	DEC	B		;and reset pointers (counters).
1546   EF22 2B          	DEC	HL
1547   EF23 C3 A9 EF    	JP	RDBUF15
1548   EF26 FE 05       RDBUF4: 	CP	CNTRLE		;physical end of line?
1549   EF28 C2 37 EF    	JP	NZ,RDBUF5
1550   EF2B C5          	PUSH	BC		;yes, do it.
1551   EF2C E5          	PUSH	HL
1552   EF2D CD C9 EE    	CALL	OUTCRLF
1553   EF30 AF          	XOR	A		;and update starting position.
1554   EF31 32 0B F0    	LD	(STARTING),A
1555   EF34 C3 F1 EE    	JP	RDBUF2
1556   EF37 FE 10       RDBUF5: 	CP	CNTRLP		;control-p?
1557   EF39 C2 48 EF    	JP	NZ,RDBUF6
1558   EF3C E5          	PUSH	HL		;yes, flip the print flag filp-flop byte.
1559   EF3D 21 0D F0    	LD	HL,PRTFLAG
1560   EF40 3E 01       	LD	A,1		;PRTFLAG=1-PRTFLAG
1561   EF42 96          	SUB	(HL)
1562   EF43 77          	LD	(HL),A
1563   EF44 E1          	POP	HL
1564   EF45 C3 EF EE    	JP	RDBUF1
1565   EF48 FE 18       RDBUF6: 	CP	CNTRLX		;control-x (cancel)?
1566   EF4A C2 5F EF    	JP	NZ,RDBUF8
1567   EF4D E1          	POP	HL
1568   EF4E 3A 0B F0    RDBUF7: 	LD	A,(STARTING)	;yes, backup the cursor to here.
1569   EF51 21 0C F0    	LD	HL,CURPOS
1570   EF54 BE          	CP	(HL)
1571   EF55 D2 E1 EE    	JP	NC,RDBUFF	;done yet?
1572   EF58 35          	DEC	(HL)		;no, decrement pointer and output back up one space.
1573   EF59 CD A4 EE    	CALL	BACKUP
1574   EF5C C3 4E EF    	JP	RDBUF7
1575   EF5F FE 15       RDBUF8: 	CP	CNTRLU		;cntrol-u (cancel line)?
1576   EF61 C2 6B EF    	JP	NZ,RDBUF9
1577   EF64 CD B1 EE    	CALL	NEWLINE		;start a new line.
1578   EF67 E1          	POP	HL
1579   EF68 C3 E1 EE    	JP	RDBUFF
1580   EF6B FE 12       RDBUF9: 	CP	CNTRLR		;control-r?
1581   EF6D C2 A6 EF    	JP	NZ,RDBUF14
1582   EF70 C5          RDBUF10: PUSH	BC		;yes, start a new line and retype the old one.
1583   EF71 CD B1 EE    	CALL	NEWLINE
1584   EF74 C1          	POP	BC
1585   EF75 E1          	POP	HL
1586   EF76 E5          	PUSH	HL
1587   EF77 C5          	PUSH	BC
1588   EF78 78          RDBUF11: LD	A,B		;done whole line yet?
1589   EF79 B7          	OR	A
1590   EF7A CA 8A EF    	JP	Z,RDBUF12
1591   EF7D 23          	INC	HL		;nope, get next character.
1592   EF7E 4E          	LD	C,(HL)
1593   EF7F 05          	DEC	B		;count it.
1594   EF80 C5          	PUSH	BC
1595   EF81 E5          	PUSH	HL
1596   EF82 CD 7F EE    	CALL	SHOWIT		;and display it.
1597   EF85 E1          	POP	HL
1598   EF86 C1          	POP	BC
1599   EF87 C3 78 EF    	JP	RDBUF11
1600   EF8A E5          RDBUF12: PUSH	HL		;done with line. If we were displaying
1601   EF8B 3A 0A F0    	LD	A,(OUTFLAG)	;then update cursor position.
1602   EF8E B7          	OR	A
1603   EF8F CA F1 EE    	JP	Z,RDBUF2
1604   EF92 21 0C F0    	LD	HL,CURPOS	;because this line is shorter, we must
1605   EF95 96          	SUB	(HL)		;back up the cursor (not the screen however)
1606   EF96 32 0A F0    	LD	(OUTFLAG),A	;some number of positions.
1607   EF99 CD A4 EE    RDBUF13: CALL	BACKUP		;note that as long as (OUTFLAG) is non
1608   EF9C 21 0A F0    	LD	HL,OUTFLAG	;zero, the screen will not be changed.
1609   EF9F 35          	DEC	(HL)
1610   EFA0 C2 99 EF    	JP	NZ,RDBUF13
1611   EFA3 C3 F1 EE    	JP	RDBUF2		;now just get the next character.
1612   EFA6             ;
1613   EFA6             ;   Just a normal character, put this in our buffer and echo.
1614   EFA6             ;
1615   EFA6 23          RDBUF14: INC	HL
1616   EFA7 77          	LD	(HL),A		;store character.
1617   EFA8 04          	INC	B		;and count it.
1618   EFA9 C5          RDBUF15: PUSH	BC
1619   EFAA E5          	PUSH	HL
1620   EFAB 4F          	LD	C,A		;echo it now.
1621   EFAC CD 7F EE    	CALL	SHOWIT
1622   EFAF E1          	POP	HL
1623   EFB0 C1          	POP	BC
1624   EFB1 7E          	LD	A,(HL)		;was it an abort request?
1625   EFB2 FE 03       	CP	CNTRLC		;control-c abort?
1626   EFB4 78          	LD	A,B
1627   EFB5 C2 BD EF    	JP	NZ,RDBUF16
1628   EFB8 FE 01       	CP	1		;only if at start of line.
1629   EFBA CA 00 00    	JP	Z,0
1630   EFBD B9          RDBUF16: CP	C		;nope, have we filled the buffer?
1631   EFBE DA EF EE    	JP	C,RDBUF1
1632   EFC1 E1          RDBUF17: POP	HL		;yes end the line and return.
1633   EFC2 70          	LD	(HL),B
1634   EFC3 0E 0D       	LD	C,CR
1635   EFC5 C3 48 EE    	JP	OUTCHAR		;output (cr) and return.
1636   EFC8             ;
1637   EFC8             ;   Function to get a character from the console device.
1638   EFC8             ;
1639   EFC8 CD 06 EE    GETCON: 	CALL	GETECHO		;get and echo.
1640   EFCB C3 01 F0    	JP	SETSTAT		;save status and return.
1641   EFCE             ;
1642   EFCE             ;   Function to get a character from the tape reader device.
1643   EFCE             ;
1644   EFCE CD 15 FB    GETRDR: 	CALL	READER		;get a character from reader, set status and return.
1645   EFD1 C3 01 F0    	JP	SETSTAT
1646   EFD4             ;
1647   EFD4             ;  Function to perform direct console i/o. If (C) contains (FF)
1648   EFD4             ; then this is an input request. If (C) contains (FE) then
1649   EFD4             ; this is a status request. Otherwise we are to output (C).
1650   EFD4             ;
1651   EFD4             
1652   EFD4 79          DIRCIO: 	LD	A,C		;test for (FF).
1653   EFD5 3C          	INC	A
1654   EFD6 CA E0 EF    	JP	Z,DIRC1
1655   EFD9 3C          	INC	A		;test for (FE).
1656   EFDA CA 06 FB    	JP	Z,CONST
1657   EFDD C3 0C FB    	JP	CONOUT		;just output (C).
1658   EFE0 CD 06 FB    DIRC1: 	CALL	CONST		;this is an input request.
1659   EFE3 B7          	OR	A
1660   EFE4 CA 91 FA    	JP	Z,GOBACK1	;not ready? Just return (directly).
1661   EFE7 CD 09 FB    	CALL	CONIN		;yes, get character.
1662   EFEA C3 01 F0    	JP	SETSTAT		;set status and return.
1663   EFED             ;
1664   EFED             ;   Function to return the i/o byte.
1665   EFED             ;
1666   EFED 3A 03 00    GETIOB: 	LD	A,(IOBYTE)
1667   EFF0 C3 01 F0    	JP	SETSTAT
1668   EFF3             ;
1669   EFF3             ;   Function to set the i/o byte.
1670   EFF3             ;
1671   EFF3 21 03 00    SETIOB: 	LD	HL,IOBYTE
1672   EFF6 71          	LD	(HL),C
1673   EFF7 C9          	RET	
1674   EFF8             ;
1675   EFF8             ;   Function to print the character string pointed to by (DE)
1676   EFF8             ; on the console device. The string ends with a '$'.
1677   EFF8             ;
1678   EFF8 EB          PRTSTR: 	EX	DE,HL
1679   EFF9 4D          	LD	C,L
1680   EFFA 44          	LD	B,H		;now (BC) points to it.
1681   EFFB C3 D3 EE    	JP	PRTMESG
1682   EFFE             ;
1683   EFFE             ;   Function to interigate the console device.
1684   EFFE             ;
1685   EFFE CD 23 EE    GETCSTS: CALL	CKCONSOL
1686   F001             ;
1687   F001             ;   Get here to set the status and return to the cleanup
1688   F001             ; section. Then back to the user.
1689   F001             ;
1690   F001 32 45 F0    SETSTAT: LD	(STATUS),A
1691   F004 C9          RTN: 	RET	
1692   F005             ;
1693   F005             ;   Set the status to 1 (read or write error code).
1694   F005             ;
1695   F005 3E 01       IOERR1: 	LD	A,1
1696   F007 C3 01 F0    	JP	SETSTAT
1697   F00A             ;
1698   F00A 00          OUTFLAG: .DB	0		;output flag (non zero means no output).
1699   F00B 02          STARTING:  .DB	2		;starting position for cursor.
1700   F00C 00          CURPOS: 	.DB	0		;cursor position (0=start of line).
1701   F00D 00          PRTFLAG: .DB	0		;printer flag (control-p toggle). List if non zero.
1702   F00E 00          CHARBUF: .DB	0		;single input character buffer.
1703   F00F             ;
1704   F00F             ;   Stack area for BDOS calls.
1705   F00F             ;
1706   F00F 00 00       USRSTACK:  .DW	0		;save users stack pointer here.
1707   F011             ;
1708   F011             	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1708   F011 000000000000000000000000000000000000000000000000
1709   F029             	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1709   F029 000000000000000000000000000000000000000000000000
1710   F041             STKAREA .EQU	$		;end of stack area.
1711   F041             ;
1712   F041 00          USERNO: 	.DB	0		;current user number.
1713   F042 00          ACTIVE: 	.DB	0		;currently active drive.
1714   F043 00 00       PARAMS: 	.DW	0		;save (DE) parameters here on entry.
1715   F045 00 00       STATUS: 	.DW	0		;status returned from bdos function.
1716   F047             ;
1717   F047             ;   Select error occured, jump to error routine.
1718   F047             ;
1719   F047 21 0B ED    SLCTERR: LD	HL,BADSLCT
1720   F04A             ;
1721   F04A             ;   Jump to (HL) indirectly.
1722   F04A             ;
1723   F04A 5E          JUMPHL: 	LD	E,(HL)
1724   F04B 23          	INC	HL
1725   F04C 56          	LD	D,(HL)		;now (DE) contain the desired address.
1726   F04D EB          	EX	DE,HL
1727   F04E E9          	JP	(HL)
1728   F04F             ;
1729   F04F             ;   Block move. (DE) to (HL), (C) bytes total.
1730   F04F             ;
1731   F04F 0C          DE2HL: 	INC	C		;is count down to zero?
1732   F050 0D          DE2HL1: 	DEC	C
1733   F051 C8          	RET	Z		;yes, we are done.
1734   F052 1A          	LD	A,(DE)		;no, move one more byte.
1735   F053 77          	LD	(HL),A
1736   F054 13          	INC	DE
1737   F055 23          	INC	HL
1738   F056 C3 50 F0    	JP	DE2HL1		;and repeat.
1739   F059             ;
1740   F059             ;   Select the desired drive.
1741   F059             ;
1742   F059 3A 42 F0    SELECT: 	LD	A,(ACTIVE)	;get active disk.
1743   F05C 4F          	LD	C,A
1744   F05D CD 1B FB    	CALL	SELDSK		;select it.
1745   F060 7C          	LD	A,H		;valid drive?
1746   F061 B5          	OR	L		;valid drive?
1747   F062 C8          	RET	Z		;return if not.
1748   F063             ;
1749   F063             ;   Here, the BIOS returned the address of the parameter block
1750   F063             ; in (HL). We will extract the necessary pointers and save them.
1751   F063             ;
1752   F063 5E          	LD	E,(HL)		;yes, get address of translation table into (DE).
1753   F064 23          	INC	HL
1754   F065 56          	LD	D,(HL)
1755   F066 23          	INC	HL
1756   F067 22 B3 FA    	LD	(SCRATCH1),HL	;save pointers to scratch areas.
1757   F06A 23          	INC	HL
1758   F06B 23          	INC	HL
1759   F06C 22 B5 FA    	LD	(SCRATCH2),HL	;ditto.
1760   F06F 23          	INC	HL
1761   F070 23          	INC	HL
1762   F071 22 B7 FA    	LD	(SCRATCH3),HL	;ditto.
1763   F074 23          	INC	HL
1764   F075 23          	INC	HL
1765   F076 EB          	EX	DE,HL		;now save the translation table address.
1766   F077 22 D0 FA    	LD	(XLATE),HL
1767   F07A 21 B9 FA    	LD	HL,DIRBUF	;put the next 8 bytes here.
1768   F07D 0E 08       	LD	C,8		;they consist of the directory buffer
1769   F07F CD 4F F0    	CALL	DE2HL		;pointer, parameter block pointer,
1770   F082 2A BB FA    	LD	HL,(DISKPB)	;check and allocation vectors.
1771   F085 EB          	EX	DE,HL
1772   F086 21 C1 FA    	LD	HL,SECTORS	;move parameter block into our ram.
1773   F089 0E 0F       	LD	C,15		;it is 15 bytes long.
1774   F08B CD 4F F0    	CALL	DE2HL
1775   F08E 2A C6 FA    	LD	HL,(DSKSIZE)	;check disk size.
1776   F091 7C          	LD	A,H		;more than 256 blocks on this?
1777   F092 21 DD FA    	LD	HL,BIGDISK
1778   F095 36 FF       	LD	(HL),0FFH	;set to samll.
1779   F097 B7          	OR	A
1780   F098 CA 9D F0    	JP	Z,SELECT1
1781   F09B 36 00       	LD	(HL),0		;wrong, set to large.
1782   F09D 3E FF       SELECT1: LD	A,0FFH		;clear the zero flag.
1783   F09F B7          	OR	A
1784   F0A0 C9          	RET	
1785   F0A1             ;
1786   F0A1             ;   Routine to home the disk track head and clear pointers.
1787   F0A1             ;
1788   F0A1 CD 18 FB    HOMEDRV: CALL	HOME		;home the head.
1789   F0A4 AF          	XOR	A
1790   F0A5 2A B5 FA    	LD	HL,(SCRATCH2)	;set our track pointer also.
1791   F0A8 77          	LD	(HL),A
1792   F0A9 23          	INC	HL
1793   F0AA 77          	LD	(HL),A
1794   F0AB 2A B7 FA    	LD	HL,(SCRATCH3)	;and our sector pointer.
1795   F0AE 77          	LD	(HL),A
1796   F0AF 23          	INC	HL
1797   F0B0 77          	LD	(HL),A
1798   F0B1 C9          	RET	
1799   F0B2             ;
1800   F0B2             ;   Do the actual disk read and check the error return status.
1801   F0B2             ;
1802   F0B2 CD 27 FB    DOREAD: 	CALL	READ
1803   F0B5 C3 BB F0    	JP	IORET
1804   F0B8             ;
1805   F0B8             ;   Do the actual disk write and handle any bios error.
1806   F0B8             ;
1807   F0B8 CD 2A FB    DOWRITE: CALL	WRITE
1808   F0BB B7          IORET: 	OR	A
1809   F0BC C8          	RET	Z		;return unless an error occured.
1810   F0BD 21 09 ED    	LD	HL,BADSCTR	;bad read/write on this sector.
1811   F0C0 C3 4A F0    	JP	JUMPHL
1812   F0C3             ;
1813   F0C3             ;   Routine to select the track and sector that the desired
1814   F0C3             ; block number falls in.
1815   F0C3             ;
1816   F0C3 2A EA FA    TRKSEC: 	LD	HL,(FILEPOS)	;get position of last accessed file
1817   F0C6 0E 02       	LD	C,2		;in directory and compute sector #.
1818   F0C8 CD EA F1    	CALL	SHIFTR		;sector #=file-position/4.
1819   F0CB 22 E5 FA    	LD	(BLKNMBR),HL	;save this as the block number of interest.
1820   F0CE 22 EC FA    	LD	(CKSUMTBL),HL	;what's it doing here too?
1821   F0D1             ;
1822   F0D1             ;   if the sector number has already been set (BLKNMBR), enter
1823   F0D1             ; at this point.
1824   F0D1             ;
1825   F0D1 21 E5 FA    TRKSEC1: LD	HL,BLKNMBR
1826   F0D4 4E          	LD	C,(HL)		;move sector number into (BC).
1827   F0D5 23          	INC	HL
1828   F0D6 46          	LD	B,(HL)
1829   F0D7 2A B7 FA    	LD	HL,(SCRATCH3)	;get current sector number and
1830   F0DA 5E          	LD	E,(HL)		;move this into (DE).
1831   F0DB 23          	INC	HL
1832   F0DC 56          	LD	D,(HL)
1833   F0DD 2A B5 FA    	LD	HL,(SCRATCH2)	;get current track number.
1834   F0E0 7E          	LD	A,(HL)		;and this into (HL).
1835   F0E1 23          	INC	HL
1836   F0E2 66          	LD	H,(HL)
1837   F0E3 6F          	LD	L,A
1838   F0E4 79          TRKSEC2: LD	A,C		;is desired sector before current one?
1839   F0E5 93          	SUB	E
1840   F0E6 78          	LD	A,B
1841   F0E7 9A          	SBC	A,D
1842   F0E8 D2 FA F0    	JP	NC,TRKSEC3
1843   F0EB E5          	PUSH	HL		;yes, decrement sectors by one track.
1844   F0EC 2A C1 FA    	LD	HL,(SECTORS)	;get sectors per track.
1845   F0EF 7B          	LD	A,E
1846   F0F0 95          	SUB	L
1847   F0F1 5F          	LD	E,A
1848   F0F2 7A          	LD	A,D
1849   F0F3 9C          	SBC	A,H
1850   F0F4 57          	LD	D,A		;now we have backed up one full track.
1851   F0F5 E1          	POP	HL
1852   F0F6 2B          	DEC	HL		;adjust track counter.
1853   F0F7 C3 E4 F0    	JP	TRKSEC2
1854   F0FA E5          TRKSEC3: PUSH	HL		;desired sector is after current one.
1855   F0FB 2A C1 FA    	LD	HL,(SECTORS)	;get sectors per track.
1856   F0FE 19          	ADD	HL,DE		;bump sector pointer to next track.
1857   F0FF DA 0F F1    	JP	C,TRKSEC4
1858   F102 79          	LD	A,C		;is desired sector now before current one?
1859   F103 95          	SUB	L
1860   F104 78          	LD	A,B
1861   F105 9C          	SBC	A,H
1862   F106 DA 0F F1    	JP	C,TRKSEC4
1863   F109 EB          	EX	DE,HL		;not yes, increment track counter
1864   F10A E1          	POP	HL		;and continue until it is.
1865   F10B 23          	INC	HL
1866   F10C C3 FA F0    	JP	TRKSEC3
1867   F10F             ;
1868   F10F             ;   here we have determined the track number that contains the
1869   F10F             ; desired sector.
1870   F10F             ;
1871   F10F E1          TRKSEC4: POP	HL		;get track number (HL).
1872   F110 C5          	PUSH	BC
1873   F111 D5          	PUSH	DE
1874   F112 E5          	PUSH	HL
1875   F113 EB          	EX	DE,HL
1876   F114 2A CE FA    	LD	HL,(OFFSET)	;adjust for first track offset.
1877   F117 19          	ADD	HL,DE
1878   F118 44          	LD	B,H
1879   F119 4D          	LD	C,L
1880   F11A CD 1E FB    	CALL	SETTRK		;select this track.
1881   F11D D1          	POP	DE		;reset current track pointer.
1882   F11E 2A B5 FA    	LD	HL,(SCRATCH2)
1883   F121 73          	LD	(HL),E
1884   F122 23          	INC	HL
1885   F123 72          	LD	(HL),D
1886   F124 D1          	POP	DE
1887   F125 2A B7 FA    	LD	HL,(SCRATCH3)	;reset the first sector on this track.
1888   F128 73          	LD	(HL),E
1889   F129 23          	INC	HL
1890   F12A 72          	LD	(HL),D
1891   F12B C1          	POP	BC
1892   F12C 79          	LD	A,C		;now subtract the desired one.
1893   F12D 93          	SUB	E		;to make it relative (1-# sectors/track).
1894   F12E 4F          	LD	C,A
1895   F12F 78          	LD	A,B
1896   F130 9A          	SBC	A,D
1897   F131 47          	LD	B,A
1898   F132 2A D0 FA    	LD	HL,(XLATE)	;translate this sector according to this table.
1899   F135 EB          	EX	DE,HL
1900   F136 CD 30 FB    	CALL	SECTRN		;let the bios translate it.
1901   F139 4D          	LD	C,L
1902   F13A 44          	LD	B,H
1903   F13B C3 21 FB    	JP	SETSEC		;and select it.
1904   F13E             ;
1905   F13E             ;   Compute block number from record number (SAVNREC) and
1906   F13E             ; extent number (SAVEXT).
1907   F13E             ;
1908   F13E 21 C3 FA    GETBLOCK:  LD	HL,BLKSHFT	;get logical to physical conversion.
1909   F141 4E          	LD	C,(HL)		;note that this is base 2 log of ratio.
1910   F142 3A E3 FA    	LD	A,(SAVNREC)	;get record number.
1911   F145 B7          GETBLK1: OR	A		;compute (A)=(A)/2^BLKSHFT.
1912   F146 1F          	RRA	
1913   F147 0D          	DEC	C
1914   F148 C2 45 F1    	JP	NZ,GETBLK1
1915   F14B 47          	LD	B,A		;save result in (B).
1916   F14C 3E 08       	LD	A,8
1917   F14E 96          	SUB	(HL)
1918   F14F 4F          	LD	C,A		;compute (C)=8-BLKSHFT.
1919   F150 3A E2 FA    	LD	A,(SAVEXT)
1920   F153 0D          GETBLK2: DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
1921   F154 CA 5C F1    	JP	Z,GETBLK3
1922   F157 B7          	OR	A
1923   F158 17          	RLA	
1924   F159 C3 53 F1    	JP	GETBLK2
1925   F15C 80          GETBLK3: ADD	A,B
1926   F15D C9          	RET	
1927   F15E             ;
1928   F15E             ;   Routine to extract the (BC) block byte from the fcb pointed
1929   F15E             ; to by (PARAMS). If this is a big-disk, then these are 16 bit
1930   F15E             ; block numbers, else they are 8 bit numbers.
1931   F15E             ; Number is returned in (HL).
1932   F15E             ;
1933   F15E 2A 43 F0    EXTBLK: 	LD	HL,(PARAMS)	;get fcb address.
1934   F161 11 10 00    	LD	DE,16		;block numbers start 16 bytes into fcb.
1935   F164 19          	ADD	HL,DE
1936   F165 09          	ADD	HL,BC
1937   F166 3A DD FA    	LD	A,(BIGDISK)	;are we using a big-disk?
1938   F169 B7          	OR	A
1939   F16A CA 71 F1    	JP	Z,EXTBLK1
1940   F16D 6E          	LD	L,(HL)		;no, extract an 8 bit number from the fcb.
1941   F16E 26 00       	LD	H,0
1942   F170 C9          	RET	
1943   F171 09          EXTBLK1: ADD	HL,BC		;yes, extract a 16 bit number.
1944   F172 5E          	LD	E,(HL)
1945   F173 23          	INC	HL
1946   F174 56          	LD	D,(HL)
1947   F175 EB          	EX	DE,HL		;return in (HL).
1948   F176 C9          	RET	
1949   F177             ;
1950   F177             ;   Compute block number.
1951   F177             ;
1952   F177 CD 3E F1    COMBLK: 	CALL	GETBLOCK
1953   F17A 4F          	LD	C,A
1954   F17B 06 00       	LD	B,0
1955   F17D CD 5E F1    	CALL	EXTBLK
1956   F180 22 E5 FA    	LD	(BLKNMBR),HL
1957   F183 C9          	RET	
1958   F184             ;
1959   F184             ;   Check for a zero block number (unused).
1960   F184             ;
1961   F184 2A E5 FA    CHKBLK: 	LD	HL,(BLKNMBR)
1962   F187 7D          	LD	A,L		;is it zero?
1963   F188 B4          	OR	H
1964   F189 C9          	RET	
1965   F18A             ;
1966   F18A             ;   Adjust physical block (BLKNMBR) and convert to logical
1967   F18A             ; sector (LOGSECT). This is the starting sector of this block.
1968   F18A             ; The actual sector of interest is then added to this and the
1969   F18A             ; resulting sector number is stored back in (BLKNMBR). This
1970   F18A             ; will still have to be adjusted for the track number.
1971   F18A             ;
1972   F18A 3A C3 FA    LOGICAL: LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
1973   F18D 2A E5 FA    	LD	HL,(BLKNMBR)	;get physical sector desired.
1974   F190 29          LOGICL1: ADD	HL,HL		;compute logical sector number.
1975   F191 3D          	DEC	A		;note logical sectors are 128 bytes long.
1976   F192 C2 90 F1    	JP	NZ,LOGICL1
1977   F195 22 E7 FA    	LD	(LOGSECT),HL	;save logical sector.
1978   F198 3A C4 FA    	LD	A,(BLKMASK)	;get block mask.
1979   F19B 4F          	LD	C,A
1980   F19C 3A E3 FA    	LD	A,(SAVNREC)	;get next sector to access.
1981   F19F A1          	AND	C		;extract the relative position within physical block.
1982   F1A0 B5          	OR	L		;and add it too logical sector.
1983   F1A1 6F          	LD	L,A
1984   F1A2 22 E5 FA    	LD	(BLKNMBR),HL	;and store.
1985   F1A5 C9          	RET	
1986   F1A6             ;
1987   F1A6             ;   Set (HL) to point to extent byte in fcb.
1988   F1A6             ;
1989   F1A6 2A 43 F0    SETEXT: 	LD	HL,(PARAMS)
1990   F1A9 11 0C 00    	LD	DE,12		;it is the twelth byte.
1991   F1AC 19          	ADD	HL,DE
1992   F1AD C9          	RET	
1993   F1AE             ;
1994   F1AE             ;   Set (HL) to point to record count byte in fcb and (DE) to
1995   F1AE             ; next record number byte.
1996   F1AE             ;
1997   F1AE 2A 43 F0    SETHLDE: LD	HL,(PARAMS)
1998   F1B1 11 0F 00    	LD	DE,15		;record count byte (#15).
1999   F1B4 19          	ADD	HL,DE
2000   F1B5 EB          	EX	DE,HL
2001   F1B6 21 11 00    	LD	HL,17		;next record number (#32).
2002   F1B9 19          	ADD	HL,DE
2003   F1BA C9          	RET	
2004   F1BB             ;
2005   F1BB             ;   Save current file data from fcb.
2006   F1BB             ;
2007   F1BB CD AE F1    STRDATA: CALL	SETHLDE
2008   F1BE 7E          	LD	A,(HL)		;get and store record count byte.
2009   F1BF 32 E3 FA    	LD	(SAVNREC),A
2010   F1C2 EB          	EX	DE,HL
2011   F1C3 7E          	LD	A,(HL)		;get and store next record number byte.
2012   F1C4 32 E1 FA    	LD	(SAVNXT),A
2013   F1C7 CD A6 F1    	CALL	SETEXT		;point to extent byte.
2014   F1CA 3A C5 FA    	LD	A,(EXTMASK)	;get extent mask.
2015   F1CD A6          	AND	(HL)
2016   F1CE 32 E2 FA    	LD	(SAVEXT),A	;and save extent here.
2017   F1D1 C9          	RET	
2018   F1D2             ;
2019   F1D2             ;   Set the next record to access. If (MODE) is set to 2, then
2020   F1D2             ; the last record byte (SAVNREC) has the correct number to access.
2021   F1D2             ; For sequential access, (MODE) will be equal to 1.
2022   F1D2             ;
2023   F1D2 CD AE F1    SETNREC: CALL	SETHLDE
2024   F1D5 3A D5 FA    	LD	A,(MODE)	;get sequential flag (=1).
2025   F1D8 FE 02       	CP	2		;a 2 indicates that no adder is needed.
2026   F1DA C2 DE F1    	JP	NZ,STNREC1
2027   F1DD AF          	XOR	A		;clear adder (random access?).
2028   F1DE 4F          STNREC1: LD	C,A
2029   F1DF 3A E3 FA    	LD	A,(SAVNREC)	;get last record number.
2030   F1E2 81          	ADD	A,C		;increment record count.
2031   F1E3 77          	LD	(HL),A		;and set fcb's next record byte.
2032   F1E4 EB          	EX	DE,HL
2033   F1E5 3A E1 FA    	LD	A,(SAVNXT)	;get next record byte from storage.
2034   F1E8 77          	LD	(HL),A		;and put this into fcb as number of records used.
2035   F1E9 C9          	RET	
2036   F1EA             ;
2037   F1EA             ;   Shift (HL) right (C) bits.
2038   F1EA             ;
2039   F1EA 0C          SHIFTR: 	INC	C
2040   F1EB 0D          SHIFTR1: DEC	C
2041   F1EC C8          	RET	Z
2042   F1ED 7C          	LD	A,H
2043   F1EE B7          	OR	A
2044   F1EF 1F          	RRA	
2045   F1F0 67          	LD	H,A
2046   F1F1 7D          	LD	A,L
2047   F1F2 1F          	RRA	
2048   F1F3 6F          	LD	L,A
2049   F1F4 C3 EB F1    	JP	SHIFTR1
2050   F1F7             ;
2051   F1F7             ;   Compute the check-sum for the directory buffer. Return
2052   F1F7             ; integer sum in (A).
2053   F1F7             ;
2054   F1F7 0E 80       CHECKSUM:  LD	C,128		;length of buffer.
2055   F1F9 2A B9 FA    	LD	HL,(DIRBUF)	;get its location.
2056   F1FC AF          	XOR	A		;clear summation byte.
2057   F1FD 86          CHKSUM1: ADD	A,(HL)		;and compute sum ignoring carries.
2058   F1FE 23          	INC	HL
2059   F1FF 0D          	DEC	C
2060   F200 C2 FD F1    	JP	NZ,CHKSUM1
2061   F203 C9          	RET	
2062   F204             ;
2063   F204             ;   Shift (HL) left (C) bits.
2064   F204             ;
2065   F204 0C          SHIFTL: 	INC	C
2066   F205 0D          SHIFTL1: DEC	C
2067   F206 C8          	RET	Z
2068   F207 29          	ADD	HL,HL		;shift left 1 bit.
2069   F208 C3 05 F2    	JP	SHIFTL1
2070   F20B             ;
2071   F20B             ;   Routine to set a bit in a 16 bit value contained in (BC).
2072   F20B             ; The bit set depends on the current drive selection.
2073   F20B             ;
2074   F20B C5          SETBIT: 	PUSH	BC		;save 16 bit word.
2075   F20C 3A 42 F0    	LD	A,(ACTIVE)	;get active drive.
2076   F20F 4F          	LD	C,A
2077   F210 21 01 00    	LD	HL,1
2078   F213 CD 04 F2    	CALL	SHIFTL		;shift bit 0 into place.
2079   F216 C1          	POP	BC		;now 'or' this with the original word.
2080   F217 79          	LD	A,C
2081   F218 B5          	OR	L
2082   F219 6F          	LD	L,A		;low byte done, do high byte.
2083   F21A 78          	LD	A,B
2084   F21B B4          	OR	H
2085   F21C 67          	LD	H,A
2086   F21D C9          	RET	
2087   F21E             ;
2088   F21E             ;   Extract the write protect status bit for the current drive.
2089   F21E             ; The result is returned in (A), bit 0.
2090   F21E             ;
2091   F21E 2A AD FA    GETWPRT: LD	HL,(WRTPRT)	;get status bytes.
2092   F221 3A 42 F0    	LD	A,(ACTIVE)	;which drive is current?
2093   F224 4F          	LD	C,A
2094   F225 CD EA F1    	CALL	SHIFTR		;shift status such that bit 0 is the
2095   F228 7D          	LD	A,L		;one of interest for this drive.
2096   F229 E6 01       	AND	01H		;and isolate it.
2097   F22B C9          	RET	
2098   F22C             ;
2099   F22C             ;   Function to write protect the current disk.
2100   F22C             ;
2101   F22C 21 AD FA    WRTPRTD: LD	HL,WRTPRT	;point to status word.
2102   F22F 4E          	LD	C,(HL)		;set (BC) equal to the status.
2103   F230 23          	INC	HL
2104   F231 46          	LD	B,(HL)
2105   F232 CD 0B F2    	CALL	SETBIT		;and set this bit according to current drive.
2106   F235 22 AD FA    	LD	(WRTPRT),HL	;then save.
2107   F238 2A C8 FA    	LD	HL,(DIRSIZE)	;now save directory size limit.
2108   F23B 23          	INC	HL		;remember the last one.
2109   F23C EB          	EX	DE,HL
2110   F23D 2A B3 FA    	LD	HL,(SCRATCH1)	;and store it here.
2111   F240 73          	LD	(HL),E		;put low byte.
2112   F241 23          	INC	HL
2113   F242 72          	LD	(HL),D		;then high byte.
2114   F243 C9          	RET	
2115   F244             ;
2116   F244             ;   Check for a read only file.
2117   F244             ;
2118   F244 CD 5E F2    CHKROFL: CALL	FCB2HL		;set (HL) to file entry in directory buffer.
2119   F247 11 09 00    CKROF1: 	LD	DE,9		;look at bit 7 of the ninth byte.
2120   F24A 19          	ADD	HL,DE
2121   F24B 7E          	LD	A,(HL)
2122   F24C 17          	RLA	
2123   F24D D0          	RET	NC		;return if ok.
2124   F24E 21 0F ED    	LD	HL,ROFILE	;else, print error message and terminate.
2125   F251 C3 4A F0    	JP	JUMPHL
2126   F254             ;
2127   F254             ;   Check the write protect status of the active disk.
2128   F254             ;
2129   F254 CD 1E F2    CHKWPRT: CALL	GETWPRT
2130   F257 C8          	RET	Z		;return if ok.
2131   F258 21 0D ED    	LD	HL,RODISK	;else print message and terminate.
2132   F25B C3 4A F0    	JP	JUMPHL
2133   F25E             ;
2134   F25E             ;   Routine to set (HL) pointing to the proper entry in the
2135   F25E             ; directory buffer.
2136   F25E             ;
2137   F25E 2A B9 FA    FCB2HL: 	LD	HL,(DIRBUF)	;get address of buffer.
2138   F261 3A E9 FA    	LD	A,(FCBPOS)	;relative position of file.
2139   F264             ;
2140   F264             ;   Routine to add (A) to (HL).
2141   F264             ;
2142   F264 85          ADDA2HL: ADD	A,L
2143   F265 6F          	LD	L,A
2144   F266 D0          	RET	NC
2145   F267 24          	INC	H		;take care of any carry.
2146   F268 C9          	RET	
2147   F269             ;
2148   F269             ;   Routine to get the 's2' byte from the fcb supplied in
2149   F269             ; the initial parameter specification.
2150   F269             ;
2151   F269 2A 43 F0    GETS2: 	LD	HL,(PARAMS)	;get address of fcb.
2152   F26C 11 0E 00    	LD	DE,14		;relative position of 's2'.
2153   F26F 19          	ADD	HL,DE
2154   F270 7E          	LD	A,(HL)		;extract this byte.
2155   F271 C9          	RET	
2156   F272             ;
2157   F272             ;   Clear the 's2' byte in the fcb.
2158   F272             ;
2159   F272 CD 69 F2    CLEARS2: CALL	GETS2		;this sets (HL) pointing to it.
2160   F275 36 00       	LD	(HL),0		;now clear it.
2161   F277 C9          	RET	
2162   F278             ;
2163   F278             ;   Set bit 7 in the 's2' byte of the fcb.
2164   F278             ;
2165   F278 CD 69 F2    SETS2B7: CALL	GETS2		;get the byte.
2166   F27B F6 80       	OR	80H		;and set bit 7.
2167   F27D 77          	LD	(HL),A		;then store.
2168   F27E C9          	RET	
2169   F27F             ;
2170   F27F             ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
2171   F27F             ; the difference. This checks to see if there are more file
2172   F27F             ; names in the directory. We are at (FILEPOS) and there are
2173   F27F             ; (SCRATCH1) of them to check.
2174   F27F             ;
2175   F27F 2A EA FA    MOREFLS: LD	HL,(FILEPOS)	;we are here.
2176   F282 EB          	EX	DE,HL
2177   F283 2A B3 FA    	LD	HL,(SCRATCH1)	;and don't go past here.
2178   F286 7B          	LD	A,E		;compute difference but don't keep.
2179   F287 96          	SUB	(HL)
2180   F288 23          	INC	HL
2181   F289 7A          	LD	A,D
2182   F28A 9E          	SBC	A,(HL)		;set carry if no more names.
2183   F28B C9          	RET	
2184   F28C             ;
2185   F28C             ;   Call this routine to prevent (SCRATCH1) from being greater
2186   F28C             ; than (FILEPOS).
2187   F28C             ;
2188   F28C CD 7F F2    CHKNMBR: CALL	MOREFLS		;SCRATCH1 too big?
2189   F28F D8          	RET	C
2190   F290 13          	INC	DE		;yes, reset it to (FILEPOS).
2191   F291 72          	LD	(HL),D
2192   F292 2B          	DEC	HL
2193   F293 73          	LD	(HL),E
2194   F294 C9          	RET	
2195   F295             ;
2196   F295             ;   Compute (HL)=(DE)-(HL)
2197   F295             ;
2198   F295 7B          SUBHL: 	LD	A,E		;compute difference.
2199   F296 95          	SUB	L
2200   F297 6F          	LD	L,A		;store low byte.
2201   F298 7A          	LD	A,D
2202   F299 9C          	SBC	A,H
2203   F29A 67          	LD	H,A		;and then high byte.
2204   F29B C9          	RET	
2205   F29C             ;
2206   F29C             ;   Set the directory checksum byte.
2207   F29C             ;
2208   F29C 0E FF       SETDIR: 	LD	C,0FFH
2209   F29E             ;
2210   F29E             ;   Routine to set or compare the directory checksum byte. If
2211   F29E             ; (C)=0ffh, then this will set the checksum byte. Else the byte
2212   F29E             ; will be checked. If the check fails (the disk has been changed),
2213   F29E             ; then this disk will be write protected.
2214   F29E             ;
2215   F29E 2A EC FA    CHECKDIR:  LD	HL,(CKSUMTBL)
2216   F2A1 EB          	EX	DE,HL
2217   F2A2 2A CC FA    	LD	HL,(ALLOC1)
2218   F2A5 CD 95 F2    	CALL	SUBHL
2219   F2A8 D0          	RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
2220   F2A9 C5          	PUSH	BC
2221   F2AA CD F7 F1    	CALL	CHECKSUM	;else compute checksum.
2222   F2AD 2A BD FA    	LD	HL,(CHKVECT)	;get address of checksum table.
2223   F2B0 EB          	EX	DE,HL
2224   F2B1 2A EC FA    	LD	HL,(CKSUMTBL)
2225   F2B4 19          	ADD	HL,DE		;set (HL) to point to byte for this drive.
2226   F2B5 C1          	POP	BC
2227   F2B6 0C          	INC	C		;set or check ?
2228   F2B7 CA C4 F2    	JP	Z,CHKDIR1
2229   F2BA BE          	CP	(HL)		;check them.
2230   F2BB C8          	RET	Z		;return if they are the same.
2231   F2BC CD 7F F2    	CALL	MOREFLS		;not the same, do we care?
2232   F2BF D0          	RET	NC
2233   F2C0 CD 2C F2    	CALL	WRTPRTD		;yes, mark this as write protected.
2234   F2C3 C9          	RET	
2235   F2C4 77          CHKDIR1: LD	(HL),A		;just set the byte.
2236   F2C5 C9          	RET	
2237   F2C6             ;
2238   F2C6             ;   Do a write to the directory of the current disk.
2239   F2C6             ;
2240   F2C6 CD 9C F2    DIRWRITE:  CALL	SETDIR		;set checksum byte.
2241   F2C9 CD E0 F2    	CALL	DIRDMA		;set directory dma address.
2242   F2CC 0E 01       	LD	C,1		;tell the bios to actually write.
2243   F2CE CD B8 F0    	CALL	DOWRITE		;then do the write.
2244   F2D1 C3 DA F2    	JP	DEFDMA
2245   F2D4             ;
2246   F2D4             ;   Read from the directory.
2247   F2D4             ;
2248   F2D4 CD E0 F2    DIRREAD: CALL	DIRDMA		;set the directory dma address.
2249   F2D7 CD B2 F0    	CALL	DOREAD		;and read it.
2250   F2DA             ;
2251   F2DA             ;   Routine to set the dma address to the users choice.
2252   F2DA             ;
2253   F2DA 21 B1 FA    DEFDMA: 	LD	HL,USERDMA	;reset the default dma address and return.
2254   F2DD C3 E3 F2    	JP	DIRDMA1
2255   F2E0             ;
2256   F2E0             ;   Routine to set the dma address for directory work.
2257   F2E0             ;
2258   F2E0 21 B9 FA    DIRDMA: 	LD	HL,DIRBUF
2259   F2E3             ;
2260   F2E3             ;   Set the dma address. On entry, (HL) points to
2261   F2E3             ; word containing the desired dma address.
2262   F2E3             ;
2263   F2E3 4E          DIRDMA1: LD	C,(HL)
2264   F2E4 23          	INC	HL
2265   F2E5 46          	LD	B,(HL)		;setup (BC) and go to the bios to set it.
2266   F2E6 C3 24 FB    	JP	SETDMA
2267   F2E9             ;
2268   F2E9             ;   Move the directory buffer into user's dma space.
2269   F2E9             ;
2270   F2E9 2A B9 FA    MOVEDIR: LD	HL,(DIRBUF)	;buffer is located here, and
2271   F2EC EB          	EX	DE,HL
2272   F2ED 2A B1 FA    	LD	HL,(USERDMA)	; put it here.
2273   F2F0 0E 80       	LD	C,128		;this is its length.
2274   F2F2 C3 4F F0    	JP	DE2HL		;move it now and return.
2275   F2F5             ;
2276   F2F5             ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
2277   F2F5             ;
2278   F2F5 21 EA FA    CKFILPOS:  LD	HL,FILEPOS
2279   F2F8 7E          	LD	A,(HL)
2280   F2F9 23          	INC	HL
2281   F2FA BE          	CP	(HL)		;are both bytes the same?
2282   F2FB C0          	RET	NZ
2283   F2FC 3C          	INC	A		;yes, but are they each 0ffh?
2284   F2FD C9          	RET	
2285   F2FE             ;
2286   F2FE             ;   Set location (FILEPOS) to 0ffffh.
2287   F2FE             ;
2288   F2FE 21 FF FF    STFILPOS:  LD	HL,0FFFFH
2289   F301 22 EA FA    	LD	(FILEPOS),HL
2290   F304 C9          	RET	
2291   F305             ;
2292   F305             ;   Move on to the next file position within the current
2293   F305             ; directory buffer. If no more exist, set pointer to 0ffffh
2294   F305             ; and the calling routine will check for this. Enter with (C)
2295   F305             ; equal to 0ffh to cause the checksum byte to be set, else we
2296   F305             ; will check this disk and set write protect if checksums are
2297   F305             ; not the same (applies only if another directory sector must
2298   F305             ; be read).
2299   F305             ;
2300   F305 2A C8 FA    NXENTRY: LD	HL,(DIRSIZE)	;get directory entry size limit.
2301   F308 EB          	EX	DE,HL
2302   F309 2A EA FA    	LD	HL,(FILEPOS)	;get current count.
2303   F30C 23          	INC	HL		;go on to the next one.
2304   F30D 22 EA FA    	LD	(FILEPOS),HL
2305   F310 CD 95 F2    	CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
2306   F313 D2 19 F3    	JP	NC,NXENT1	;is there more room left?
2307   F316 C3 FE F2    	JP	STFILPOS	;no. Set this flag and return.
2308   F319 3A EA FA    NXENT1: 	LD	A,(FILEPOS)	;get file position within directory.
2309   F31C E6 03       	AND	03H		;only look within this sector (only 4 entries fit).
2310   F31E 06 05       	LD	B,5		;convert to relative position (32 bytes each).
2311   F320 87          NXENT2: 	ADD	A,A		;note that this is not efficient code.
2312   F321 05          	DEC	B		;5 'ADD A's would be better.
2313   F322 C2 20 F3    	JP	NZ,NXENT2
2314   F325 32 E9 FA    	LD	(FCBPOS),A	;save it as position of fcb.
2315   F328 B7          	OR	A
2316   F329 C0          	RET	NZ		;return if we are within buffer.
2317   F32A C5          	PUSH	BC
2318   F32B CD C3 F0    	CALL	TRKSEC		;we need the next directory sector.
2319   F32E CD D4 F2    	CALL	DIRREAD
2320   F331 C1          	POP	BC
2321   F332 C3 9E F2    	JP	CHECKDIR
2322   F335             ;
2323   F335             ;   Routine to to get a bit from the disk space allocation
2324   F335             ; map. It is returned in (A), bit position 0. On entry to here,
2325   F335             ; set (BC) to the block number on the disk to check.
2326   F335             ; On return, (D) will contain the original bit position for
2327   F335             ; this block number and (HL) will point to the address for it.
2328   F335             ;
2329   F335 79          CKBITMAP:  LD	A,C		;determine bit number of interest.
2330   F336 E6 07       	AND	07H		;compute (D)=(E)=(C and 7)+1.
2331   F338 3C          	INC	A
2332   F339 5F          	LD	E,A		;save particular bit number.
2333   F33A 57          	LD	D,A
2334   F33B             ;
2335   F33B             ;   compute (BC)=(BC)/8.
2336   F33B             ;
2337   F33B 79          	LD	A,C
2338   F33C 0F          	RRCA			;now shift right 3 bits.
2339   F33D 0F          	RRCA	
2340   F33E 0F          	RRCA	
2341   F33F E6 1F       	AND	1FH		;and clear bits 7,6,5.
2342   F341 4F          	LD	C,A
2343   F342 78          	LD	A,B
2344   F343 87          	ADD	A,A		;now shift (B) into bits 7,6,5.
2345   F344 87          	ADD	A,A
2346   F345 87          	ADD	A,A
2347   F346 87          	ADD	A,A
2348   F347 87          	ADD	A,A
2349   F348 B1          	OR	C		;and add in (C).
2350   F349 4F          	LD	C,A		;ok, (C) ha been completed.
2351   F34A 78          	LD	A,B		;is there a better way of doing this?
2352   F34B 0F          	RRCA	
2353   F34C 0F          	RRCA	
2354   F34D 0F          	RRCA	
2355   F34E E6 1F       	AND	1FH
2356   F350 47          	LD	B,A		;and now (B) is completed.
2357   F351             ;
2358   F351             ;   use this as an offset into the disk space allocation
2359   F351             ; table.
2360   F351             ;
2361   F351 2A BF FA    	LD	HL,(ALOCVECT)
2362   F354 09          	ADD	HL,BC
2363   F355 7E          	LD	A,(HL)		;now get correct byte.
2364   F356 07          CKBMAP1: RLCA			;get correct bit into position 0.
2365   F357 1D          	DEC	E
2366   F358 C2 56 F3    	JP	NZ,CKBMAP1
2367   F35B C9          	RET	
2368   F35C             ;
2369   F35C             ;   Set or clear the bit map such that block number (BC) will be marked
2370   F35C             ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
2371   F35C             ; 1 then it will be set (don't use anyother values).
2372   F35C             ;
2373   F35C D5          STBITMAP:  PUSH	DE
2374   F35D CD 35 F3    	CALL	CKBITMAP	;get the byte of interest.
2375   F360 E6 FE       	AND	0FEH		;clear the affected bit.
2376   F362 C1          	POP	BC
2377   F363 B1          	OR	C		;and now set it acording to (C).
2378   F364             ;
2379   F364             ;  entry to restore the original bit position and then store
2380   F364             ; in table. (A) contains the value, (D) contains the bit
2381   F364             ; position (1-8), and (HL) points to the address within the
2382   F364             ; space allocation table for this byte.
2383   F364             ;
2384   F364 0F          STBMAP1: RRCA			;restore original bit position.
2385   F365 15          	DEC	D
2386   F366 C2 64 F3    	JP	NZ,STBMAP1
2387   F369 77          	LD	(HL),A		;and stor byte in table.
2388   F36A C9          	RET	
2389   F36B             ;
2390   F36B             ;   Set/clear space used bits in allocation map for this file.
2391   F36B             ; On entry, (C)=1 to set the map and (C)=0 to clear it.
2392   F36B             ;
2393   F36B CD 5E F2    SETFILE: CALL	FCB2HL		;get address of fcb
2394   F36E 11 10 00    	LD	DE,16
2395   F371 19          	ADD	HL,DE		;get to block number bytes.
2396   F372 C5          	PUSH	BC
2397   F373 0E 11       	LD	C,17		;check all 17 bytes (max) of table.
2398   F375 D1          SETFL1: 	POP	DE
2399   F376 0D          	DEC	C		;done all bytes yet?
2400   F377 C8          	RET	Z
2401   F378 D5          	PUSH	DE
2402   F379 3A DD FA    	LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
2403   F37C B7          	OR	A
2404   F37D CA 88 F3    	JP	Z,SETFL2
2405   F380 C5          	PUSH	BC		;only 8 bit numbers. set (BC) to this one.
2406   F381 E5          	PUSH	HL
2407   F382 4E          	LD	C,(HL)		;get low byte from table, always
2408   F383 06 00       	LD	B,0		;set high byte to zero.
2409   F385 C3 8E F3    	JP	SETFL3
2410   F388 0D          SETFL2: 	DEC	C		;for 16 bit block numbers, adjust counter.
2411   F389 C5          	PUSH	BC
2412   F38A 4E          	LD	C,(HL)		;now get both the low and high bytes.
2413   F38B 23          	INC	HL
2414   F38C 46          	LD	B,(HL)
2415   F38D E5          	PUSH	HL
2416   F38E 79          SETFL3: 	LD	A,C		;block used?
2417   F38F B0          	OR	B
2418   F390 CA 9D F3    	JP	Z,SETFL4
2419   F393 2A C6 FA    	LD	HL,(DSKSIZE)	;is this block number within the
2420   F396 7D          	LD	A,L		;space on the disk?
2421   F397 91          	SUB	C
2422   F398 7C          	LD	A,H
2423   F399 98          	SBC	A,B
2424   F39A D4 5C F3    	CALL	NC,STBITMAP	;yes, set the proper bit.
2425   F39D E1          SETFL4: 	POP	HL		;point to next block number in fcb.
2426   F39E 23          	INC	HL
2427   F39F C1          	POP	BC
2428   F3A0 C3 75 F3    	JP	SETFL1
2429   F3A3             ;
2430   F3A3             ;   Construct the space used allocation bit map for the active
2431   F3A3             ; drive. If a file name starts with '$' and it is under the
2432   F3A3             ; current user number, then (STATUS) is set to minus 1. Otherwise
2433   F3A3             ; it is not set at all.
2434   F3A3             ;
2435   F3A3 2A C6 FA    BITMAP: 	LD	HL,(DSKSIZE)	;compute size of allocation table.
2436   F3A6 0E 03       	LD	C,3
2437   F3A8 CD EA F1    	CALL	SHIFTR		;(HL)=(HL)/8.
2438   F3AB 23          	INC	HL		;at lease 1 byte.
2439   F3AC 44          	LD	B,H
2440   F3AD 4D          	LD	C,L		;set (BC) to the allocation table length.
2441   F3AE             ;
2442   F3AE             ;   Initialize the bitmap for this drive. Right now, the first
2443   F3AE             ; two bytes are specified by the disk parameter block. However
2444   F3AE             ; a patch could be entered here if it were necessary to setup
2445   F3AE             ; this table in a special mannor. For example, the bios could
2446   F3AE             ; determine locations of 'bad blocks' and set them as already
2447   F3AE             ; 'used' in the map.
2448   F3AE             ;
2449   F3AE 2A BF FA    	LD	HL,(ALOCVECT)	;now zero out the table now.
2450   F3B1 36 00       BITMAP1: LD	(HL),0
2451   F3B3 23          	INC	HL
2452   F3B4 0B          	DEC	BC
2453   F3B5 78          	LD	A,B
2454   F3B6 B1          	OR	C
2455   F3B7 C2 B1 F3    	JP	NZ,BITMAP1
2456   F3BA 2A CA FA    	LD	HL,(ALLOC0)	;get initial space used by directory.
2457   F3BD EB          	EX	DE,HL
2458   F3BE 2A BF FA    	LD	HL,(ALOCVECT)	;and put this into map.
2459   F3C1 73          	LD	(HL),E
2460   F3C2 23          	INC	HL
2461   F3C3 72          	LD	(HL),D
2462   F3C4             ;
2463   F3C4             ;   End of initialization portion.
2464   F3C4             ;
2465   F3C4 CD A1 F0    	CALL	HOMEDRV		;now home the drive.
2466   F3C7 2A B3 FA    	LD	HL,(SCRATCH1)
2467   F3CA 36 03       	LD	(HL),3		;force next directory request to read
2468   F3CC 23          	INC	HL		;in a sector.
2469   F3CD 36 00       	LD	(HL),0
2470   F3CF CD FE F2    	CALL	STFILPOS	;clear initial file position also.
2471   F3D2 0E FF       BITMAP2: LD	C,0FFH		;read next file name in directory
2472   F3D4 CD 05 F3    	CALL	NXENTRY		;and set checksum byte.
2473   F3D7 CD F5 F2    	CALL	CKFILPOS	;is there another file?
2474   F3DA C8          	RET	Z
2475   F3DB CD 5E F2    	CALL	FCB2HL		;yes, get its address.
2476   F3DE 3E E5       	LD	A,0E5H
2477   F3E0 BE          	CP	(HL)		;empty file entry?
2478   F3E1 CA D2 F3    	JP	Z,BITMAP2
2479   F3E4 3A 41 F0    	LD	A,(USERNO)	;no, correct user number?
2480   F3E7 BE          	CP	(HL)
2481   F3E8 C2 F6 F3    	JP	NZ,BITMAP3
2482   F3EB 23          	INC	HL
2483   F3EC 7E          	LD	A,(HL)		;yes, does name start with a '$'?
2484   F3ED D6 24       	SUB	'$'
2485   F3EF C2 F6 F3    	JP	NZ,BITMAP3
2486   F3F2 3D          	DEC	A		;yes, set atatus to minus one.
2487   F3F3 32 45 F0    	LD	(STATUS),A
2488   F3F6 0E 01       BITMAP3: LD	C,1		;now set this file's space as used in bit map.
2489   F3F8 CD 6B F3    	CALL	SETFILE
2490   F3FB CD 8C F2    	CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
2491   F3FE C3 D2 F3    	JP	BITMAP2
2492   F401             ;
2493   F401             ;   Set the status (STATUS) and return.
2494   F401             ;
2495   F401 3A D4 FA    STSTATUS:  LD	A,(FNDSTAT)
2496   F404 C3 01 F0    	JP	SETSTAT
2497   F407             ;
2498   F407             ;   Check extents in (A) and (C). Set the zero flag if they
2499   F407             ; are the same. The number of 16k chunks of disk space that
2500   F407             ; the directory extent covers is expressad is (EXTMASK+1).
2501   F407             ; No registers are modified.
2502   F407             ;
2503   F407 C5          SAMEXT: 	PUSH	BC
2504   F408 F5          	PUSH	AF
2505   F409 3A C5 FA    	LD	A,(EXTMASK)	;get extent mask and use it to
2506   F40C 2F          	CPL			;to compare both extent numbers.
2507   F40D 47          	LD	B,A		;save resulting mask here.
2508   F40E 79          	LD	A,C		;mask first extent and save in (C).
2509   F40F A0          	AND	B
2510   F410 4F          	LD	C,A
2511   F411 F1          	POP	AF		;now mask second extent and compare
2512   F412 A0          	AND	B		;with the first one.
2513   F413 91          	SUB	C
2514   F414 E6 1F       	AND	1FH		;(* only check buts 0-4 *)
2515   F416 C1          	POP	BC		;the zero flag is set if they are the same.
2516   F417 C9          	RET			;restore (BC) and return.
2517   F418             ;
2518   F418             ;   Search for the first occurence of a file name. On entry,
2519   F418             ; register (C) should contain the number of bytes of the fcb
2520   F418             ; that must match.
2521   F418             ;
2522   F418 3E FF       FINDFST: LD	A,0FFH
2523   F41A 32 D4 FA    	LD	(FNDSTAT),A
2524   F41D 21 D8 FA    	LD	HL,COUNTER	;save character count.
2525   F420 71          	LD	(HL),C
2526   F421 2A 43 F0    	LD	HL,(PARAMS)	;get filename to match.
2527   F424 22 D9 FA    	LD	(SAVEFCB),HL	;and save.
2528   F427 CD FE F2    	CALL	STFILPOS	;clear initial file position (set to 0ffffh).
2529   F42A CD A1 F0    	CALL	HOMEDRV		;home the drive.
2530   F42D             ;
2531   F42D             ;   Entry to locate the next occurence of a filename within the
2532   F42D             ; directory. The disk is not expected to have been changed. If
2533   F42D             ; it was, then it will be write protected.
2534   F42D             ;
2535   F42D 0E 00       FINDNXT: LD	C,0		;write protect the disk if changed.
2536   F42F CD 05 F3    	CALL	NXENTRY		;get next filename entry in directory.
2537   F432 CD F5 F2    	CALL	CKFILPOS	;is file position = 0ffffh?
2538   F435 CA 94 F4    	JP	Z,FNDNXT6	;yes, exit now then.
2539   F438 2A D9 FA    	LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
2540   F43B EB          	EX	DE,HL
2541   F43C 1A          	LD	A,(DE)
2542   F43D FE E5       	CP	0E5H		;empty directory entry?
2543   F43F CA 4A F4    	JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
2544   F442 D5          	PUSH	DE
2545   F443 CD 7F F2    	CALL	MOREFLS		;more files in directory?
2546   F446 D1          	POP	DE
2547   F447 D2 94 F4    	JP	NC,FNDNXT6	;no more. Exit now.
2548   F44A CD 5E F2    FNDNXT1: CALL	FCB2HL		;get address of this fcb in directory.
2549   F44D 3A D8 FA    	LD	A,(COUNTER)	;get number of bytes (characters) to check.
2550   F450 4F          	LD	C,A
2551   F451 06 00       	LD	B,0		;initialize byte position counter.
2552   F453 79          FNDNXT2: LD	A,C		;are we done with the compare?
2553   F454 B7          	OR	A
2554   F455 CA 83 F4    	JP	Z,FNDNXT5
2555   F458 1A          	LD	A,(DE)		;no, check next byte.
2556   F459 FE 3F       	CP	'?'		;don't care about this character?
2557   F45B CA 7C F4    	JP	Z,FNDNXT4
2558   F45E 78          	LD	A,B		;get bytes position in fcb.
2559   F45F FE 0D       	CP	13		;don't care about the thirteenth byte either.
2560   F461 CA 7C F4    	JP	Z,FNDNXT4
2561   F464 FE 0C       	CP	12		;extent byte?
2562   F466 1A          	LD	A,(DE)
2563   F467 CA 73 F4    	JP	Z,FNDNXT3
2564   F46A 96          	SUB	(HL)		;otherwise compare characters.
2565   F46B E6 7F       	AND	7FH
2566   F46D C2 2D F4    	JP	NZ,FINDNXT	;not the same, check next entry.
2567   F470 C3 7C F4    	JP	FNDNXT4		;so far so good, keep checking.
2568   F473 C5          FNDNXT3: PUSH	BC		;check the extent byte here.
2569   F474 4E          	LD	C,(HL)
2570   F475 CD 07 F4    	CALL	SAMEXT
2571   F478 C1          	POP	BC
2572   F479 C2 2D F4    	JP	NZ,FINDNXT	;not the same, look some more.
2573   F47C             ;
2574   F47C             ;   So far the names compare. Bump pointers to the next byte
2575   F47C             ; and continue until all (C) characters have been checked.
2576   F47C             ;
2577   F47C 13          FNDNXT4: INC	DE		;bump pointers.
2578   F47D 23          	INC	HL
2579   F47E 04          	INC	B
2580   F47F 0D          	DEC	C		;adjust character counter.
2581   F480 C3 53 F4    	JP	FNDNXT2
2582   F483 3A EA FA    FNDNXT5: LD	A,(FILEPOS)	;return the position of this entry.
2583   F486 E6 03       	AND	03H
2584   F488 32 45 F0    	LD	(STATUS),A
2585   F48B 21 D4 FA    	LD	HL,FNDSTAT
2586   F48E 7E          	LD	A,(HL)
2587   F48F 17          	RLA	
2588   F490 D0          	RET	NC
2589   F491 AF          	XOR	A
2590   F492 77          	LD	(HL),A
2591   F493 C9          	RET	
2592   F494             ;
2593   F494             ;   Filename was not found. Set appropriate status.
2594   F494             ;
2595   F494 CD FE F2    FNDNXT6: CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
2596   F497 3E FF       	LD	A,0FFH		;say not located.
2597   F499 C3 01 F0    	JP	SETSTAT
2598   F49C             ;
2599   F49C             ;   Erase files from the directory. Only the first byte of the
2600   F49C             ; fcb will be affected. It is set to (E5).
2601   F49C             ;
2602   F49C CD 54 F2    ERAFILE: CALL	CHKWPRT		;is disk write protected?
2603   F49F 0E 0C       	LD	C,12		;only compare file names.
2604   F4A1 CD 18 F4    	CALL	FINDFST		;get first file name.
2605   F4A4 CD F5 F2    ERAFIL1: CALL	CKFILPOS	;any found?
2606   F4A7 C8          	RET	Z		;nope, we must be done.
2607   F4A8 CD 44 F2    	CALL	CHKROFL		;is file read only?
2608   F4AB CD 5E F2    	CALL	FCB2HL		;nope, get address of fcb and
2609   F4AE 36 E5       	LD	(HL),0E5H	;set first byte to 'empty'.
2610   F4B0 0E 00       	LD	C,0		;clear the space from the bit map.
2611   F4B2 CD 6B F3    	CALL	SETFILE
2612   F4B5 CD C6 F2    	CALL	DIRWRITE	;now write the directory sector back out.
2613   F4B8 CD 2D F4    	CALL	FINDNXT		;find the next file name.
2614   F4BB C3 A4 F4    	JP	ERAFIL1		;and repeat process.
2615   F4BE             ;
2616   F4BE             ;   Look through the space allocation map (bit map) for the
2617   F4BE             ; next available block. Start searching at block number (BC-1).
2618   F4BE             ; The search procedure is to look for an empty block that is
2619   F4BE             ; before the starting block. If not empty, look at a later
2620   F4BE             ; block number. In this way, we return the closest empty block
2621   F4BE             ; on either side of the 'target' block number. This will speed
2622   F4BE             ; access on random devices. For serial devices, this should be
2623   F4BE             ; changed to look in the forward direction first and then start
2624   F4BE             ; at the front and search some more.
2625   F4BE             ;
2626   F4BE             ;   On return, (DE)= block number that is empty and (HL) =0
2627   F4BE             ; if no empry block was found.
2628   F4BE             ;
2629   F4BE 50          FNDSPACE:  LD	D,B		;set (DE) as the block that is checked.
2630   F4BF 59          	LD	E,C
2631   F4C0             ;
2632   F4C0             ;   Look before target block. Registers (BC) are used as the lower
2633   F4C0             ; pointer and (DE) as the upper pointer.
2634   F4C0             ;
2635   F4C0 79          FNDSPA1: LD	A,C		;is block 0 specified?
2636   F4C1 B0          	OR	B
2637   F4C2 CA D1 F4    	JP	Z,FNDSPA2
2638   F4C5 0B          	DEC	BC		;nope, check previous block.
2639   F4C6 D5          	PUSH	DE
2640   F4C7 C5          	PUSH	BC
2641   F4C8 CD 35 F3    	CALL	CKBITMAP
2642   F4CB 1F          	RRA			;is this block empty?
2643   F4CC D2 EC F4    	JP	NC,FNDSPA3	;yes. use this.
2644   F4CF             ;
2645   F4CF             ;   Note that the above logic gets the first block that it finds
2646   F4CF             ; that is empty. Thus a file could be written 'backward' making
2647   F4CF             ; it very slow to access. This could be changed to look for the
2648   F4CF             ; first empty block and then continue until the start of this
2649   F4CF             ; empty space is located and then used that starting block.
2650   F4CF             ; This should help speed up access to some files especially on
2651   F4CF             ; a well used disk with lots of fairly small 'holes'.
2652   F4CF             ;
2653   F4CF C1          	POP	BC		;nope, check some more.
2654   F4D0 D1          	POP	DE
2655   F4D1             ;
2656   F4D1             ;   Now look after target block.
2657   F4D1             ;
2658   F4D1 2A C6 FA    FNDSPA2: LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
2659   F4D4 7B          	LD	A,E
2660   F4D5 95          	SUB	L
2661   F4D6 7A          	LD	A,D
2662   F4D7 9C          	SBC	A,H
2663   F4D8 D2 F4 F4    	JP	NC,FNDSPA4
2664   F4DB 13          	INC	DE		;yes, move on to next one.
2665   F4DC C5          	PUSH	BC
2666   F4DD D5          	PUSH	DE
2667   F4DE 42          	LD	B,D
2668   F4DF 4B          	LD	C,E
2669   F4E0 CD 35 F3    	CALL	CKBITMAP	;check it.
2670   F4E3 1F          	RRA			;empty?
2671   F4E4 D2 EC F4    	JP	NC,FNDSPA3
2672   F4E7 D1          	POP	DE		;nope, continue searching.
2673   F4E8 C1          	POP	BC
2674   F4E9 C3 C0 F4    	JP	FNDSPA1
2675   F4EC             ;
2676   F4EC             ;   Empty block found. Set it as used and return with (HL)
2677   F4EC             ; pointing to it (true?).
2678   F4EC             ;
2679   F4EC 17          FNDSPA3: RLA			;reset byte.
2680   F4ED 3C          	INC	A		;and set bit 0.
2681   F4EE CD 64 F3    	CALL	STBMAP1		;update bit map.
2682   F4F1 E1          	POP	HL		;set return registers.
2683   F4F2 D1          	POP	DE
2684   F4F3 C9          	RET	
2685   F4F4             ;
2686   F4F4             ;   Free block was not found. If (BC) is not zero, then we have
2687   F4F4             ; not checked all of the disk space.
2688   F4F4             ;
2689   F4F4 79          FNDSPA4: LD	A,C
2690   F4F5 B0          	OR	B
2691   F4F6 C2 C0 F4    	JP	NZ,FNDSPA1
2692   F4F9 21 00 00    	LD	HL,0		;set 'not found' status.
2693   F4FC C9          	RET	
2694   F4FD             ;
2695   F4FD             ;   Move a complete fcb entry into the directory and write it.
2696   F4FD             ;
2697   F4FD 0E 00       FCBSET: 	LD	C,0
2698   F4FF 1E 20       	LD	E,32		;length of each entry.
2699   F501             ;
2700   F501             ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
2701   F501             ; fcb in directory starting at relative byte (C). This updated
2702   F501             ; directory buffer is then written to the disk.
2703   F501             ;
2704   F501 D5          UPDATE: 	PUSH	DE
2705   F502 06 00       	LD	B,0		;set (BC) to relative byte position.
2706   F504 2A 43 F0    	LD	HL,(PARAMS)	;get address of fcb.
2707   F507 09          	ADD	HL,BC		;compute starting byte.
2708   F508 EB          	EX	DE,HL
2709   F509 CD 5E F2    	CALL	FCB2HL		;get address of fcb to update in directory.
2710   F50C C1          	POP	BC		;set (C) to number of bytes to change.
2711   F50D CD 4F F0    	CALL	DE2HL
2712   F510 CD C3 F0    UPDATE1: CALL	TRKSEC		;determine the track and sector affected.
2713   F513 C3 C6 F2    	JP	DIRWRITE	;then write this sector out.
2714   F516             ;
2715   F516             ;   Routine to change the name of all files on the disk with a
2716   F516             ; specified name. The fcb contains the current name as the
2717   F516             ; first 12 characters and the new name 16 bytes into the fcb.
2718   F516             ;
2719   F516 CD 54 F2    CHGNAMES:  CALL	CHKWPRT		;check for a write protected disk.
2720   F519 0E 0C       	LD	C,12		;match first 12 bytes of fcb only.
2721   F51B CD 18 F4    	CALL	FINDFST		;get first name.
2722   F51E 2A 43 F0    	LD	HL,(PARAMS)	;get address of fcb.
2723   F521 7E          	LD	A,(HL)		;get user number.
2724   F522 11 10 00    	LD	DE,16		;move over to desired name.
2725   F525 19          	ADD	HL,DE
2726   F526 77          	LD	(HL),A		;keep same user number.
2727   F527 CD F5 F2    CHGNAM1: CALL	CKFILPOS	;any matching file found?
2728   F52A C8          	RET	Z		;no, we must be done.
2729   F52B CD 44 F2    	CALL	CHKROFL		;check for read only file.
2730   F52E 0E 10       	LD	C,16		;start 16 bytes into fcb.
2731   F530 1E 0C       	LD	E,12		;and update the first 12 bytes of directory.
2732   F532 CD 01 F5    	CALL	UPDATE
2733   F535 CD 2D F4    	CALL	FINDNXT		;get te next file name.
2734   F538 C3 27 F5    	JP	CHGNAM1		;and continue.
2735   F53B             ;
2736   F53B             ;   Update a files attributes. The procedure is to search for
2737   F53B             ; every file with the same name as shown in fcb (ignoring bit 7)
2738   F53B             ; and then to update it (which includes bit 7). No other changes
2739   F53B             ; are made.
2740   F53B             ;
2741   F53B 0E 0C       SAVEATTR:  LD	C,12		;match first 12 bytes.
2742   F53D CD 18 F4    	CALL	FINDFST		;look for first filename.
2743   F540 CD F5 F2    SAVATR1: CALL	CKFILPOS	;was one found?
2744   F543 C8          	RET	Z		;nope, we must be done.
2745   F544 0E 00       	LD	C,0		;yes, update the first 12 bytes now.
2746   F546 1E 0C       	LD	E,12
2747   F548 CD 01 F5    	CALL	UPDATE		;update filename and write directory.
2748   F54B CD 2D F4    	CALL	FINDNXT		;and get the next file.
2749   F54E C3 40 F5    	JP	SAVATR1		;then continue until done.
2750   F551             ;
2751   F551             ;  Open a file (name specified in fcb).
2752   F551             ;
2753   F551 0E 0F       OPENIT: 	LD	C,15		;compare the first 15 bytes.
2754   F553 CD 18 F4    	CALL	FINDFST		;get the first one in directory.
2755   F556 CD F5 F2    	CALL	CKFILPOS	;any at all?
2756   F559 C8          	RET	Z
2757   F55A CD A6 F1    OPENIT1: CALL	SETEXT		;point to extent byte within users fcb.
2758   F55D 7E          	LD	A,(HL)		;and get it.
2759   F55E F5          	PUSH	AF		;save it and address.
2760   F55F E5          	PUSH	HL
2761   F560 CD 5E F2    	CALL	FCB2HL		;point to fcb in directory.
2762   F563 EB          	EX	DE,HL
2763   F564 2A 43 F0    	LD	HL,(PARAMS)	;this is the users copy.
2764   F567 0E 20       	LD	C,32		;move it into users space.
2765   F569 D5          	PUSH	DE
2766   F56A CD 4F F0    	CALL	DE2HL
2767   F56D CD 78 F2    	CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
2768   F570 D1          	POP	DE		;now get the extent byte from this fcb.
2769   F571 21 0C 00    	LD	HL,12
2770   F574 19          	ADD	HL,DE
2771   F575 4E          	LD	C,(HL)		;into (C).
2772   F576 21 0F 00    	LD	HL,15		;now get the record count byte into (B).
2773   F579 19          	ADD	HL,DE
2774   F57A 46          	LD	B,(HL)
2775   F57B E1          	POP	HL		;keep the same extent as the user had originally.
2776   F57C F1          	POP	AF
2777   F57D 77          	LD	(HL),A
2778   F57E 79          	LD	A,C		;is it the same as in the directory fcb?
2779   F57F BE          	CP	(HL)
2780   F580 78          	LD	A,B		;if yes, then use the same record count.
2781   F581 CA 8B F5    	JP	Z,OPENIT2
2782   F584 3E 00       	LD	A,0		;if the user specified an extent greater than
2783   F586 DA 8B F5    	JP	C,OPENIT2	;the one in the directory, then set record count to 0.
2784   F589 3E 80       	LD	A,128		;otherwise set to maximum.
2785   F58B 2A 43 F0    OPENIT2: LD	HL,(PARAMS)	;set record count in users fcb to (A).
2786   F58E 11 0F 00    	LD	DE,15
2787   F591 19          	ADD	HL,DE		;compute relative position.
2788   F592 77          	LD	(HL),A		;and set the record count.
2789   F593 C9          	RET	
2790   F594             ;
2791   F594             ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
2792   F594             ; point to a zero value (16 bit).
2793   F594             ;   Return with zero flag set it (DE) was moved. Registers (DE)
2794   F594             ; and (HL) are not changed. However (A) is.
2795   F594             ;
2796   F594 7E          MOVEWORD:  LD	A,(HL)		;check for a zero word.
2797   F595 23          	INC	HL
2798   F596 B6          	OR	(HL)		;both bytes zero?
2799   F597 2B          	DEC	HL
2800   F598 C0          	RET	NZ		;nope, just return.
2801   F599 1A          	LD	A,(DE)		;yes, move two bytes from (DE) into
2802   F59A 77          	LD	(HL),A		;this zero space.
2803   F59B 13          	INC	DE
2804   F59C 23          	INC	HL
2805   F59D 1A          	LD	A,(DE)
2806   F59E 77          	LD	(HL),A
2807   F59F 1B          	DEC	DE		;don't disturb these registers.
2808   F5A0 2B          	DEC	HL
2809   F5A1 C9          	RET	
2810   F5A2             ;
2811   F5A2             ;   Get here to close a file specified by (fcb).
2812   F5A2             ;
2813   F5A2 AF          CLOSEIT: XOR	A		;clear status and file position bytes.
2814   F5A3 32 45 F0    	LD	(STATUS),A
2815   F5A6 32 EA FA    	LD	(FILEPOS),A
2816   F5A9 32 EB FA    	LD	(FILEPOS+1),A
2817   F5AC CD 1E F2    	CALL	GETWPRT		;get write protect bit for this drive.
2818   F5AF C0          	RET	NZ		;just return if it is set.
2819   F5B0 CD 69 F2    	CALL	GETS2		;else get the 's2' byte.
2820   F5B3 E6 80       	AND	80H		;and look at bit 7 (file unmodified?).
2821   F5B5 C0          	RET	NZ		;just return if set.
2822   F5B6 0E 0F       	LD	C,15		;else look up this file in directory.
2823   F5B8 CD 18 F4    	CALL	FINDFST
2824   F5BB CD F5 F2    	CALL	CKFILPOS	;was it found?
2825   F5BE C8          	RET	Z		;just return if not.
2826   F5BF 01 10 00    	LD	BC,16		;set (HL) pointing to records used section.
2827   F5C2 CD 5E F2    	CALL	FCB2HL
2828   F5C5 09          	ADD	HL,BC
2829   F5C6 EB          	EX	DE,HL
2830   F5C7 2A 43 F0    	LD	HL,(PARAMS)	;do the same for users specified fcb.
2831   F5CA 09          	ADD	HL,BC
2832   F5CB 0E 10       	LD	C,16		;this many bytes are present in this extent.
2833   F5CD 3A DD FA    CLOSEIT1:  LD	A,(BIGDISK)	;8 or 16 bit record numbers?
2834   F5D0 B7          	OR	A
2835   F5D1 CA E8 F5    	JP	Z,CLOSEIT4
2836   F5D4 7E          	LD	A,(HL)		;just 8 bit. Get one from users fcb.
2837   F5D5 B7          	OR	A
2838   F5D6 1A          	LD	A,(DE)		;now get one from directory fcb.
2839   F5D7 C2 DB F5    	JP	NZ,CLOSEIT2
2840   F5DA 77          	LD	(HL),A		;users byte was zero. Update from directory.
2841   F5DB B7          CLOSEIT2:  OR	A
2842   F5DC C2 E1 F5    	JP	NZ,CLOSEIT3
2843   F5DF 7E          	LD	A,(HL)		;directories byte was zero, update from users fcb.
2844   F5E0 12          	LD	(DE),A
2845   F5E1 BE          CLOSEIT3:  CP	(HL)		;if neither one of these bytes were zero,
2846   F5E2 C2 1F F6    	JP	NZ,CLOSEIT7	;then close error if they are not the same.
2847   F5E5 C3 FD F5    	JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
2848   F5E8 CD 94 F5    CLOSEIT4:  CALL	MOVEWORD	;update users fcb if it is zero.
2849   F5EB EB          	EX	DE,HL
2850   F5EC CD 94 F5    	CALL	MOVEWORD	;update directories fcb if it is zero.
2851   F5EF EB          	EX	DE,HL
2852   F5F0 1A          	LD	A,(DE)		;if these two values are no different,
2853   F5F1 BE          	CP	(HL)		;then a close error occured.
2854   F5F2 C2 1F F6    	JP	NZ,CLOSEIT7
2855   F5F5 13          	INC	DE		;check second byte.
2856   F5F6 23          	INC	HL
2857   F5F7 1A          	LD	A,(DE)
2858   F5F8 BE          	CP	(HL)
2859   F5F9 C2 1F F6    	JP	NZ,CLOSEIT7
2860   F5FC 0D          	DEC	C		;remember 16 bit values.
2861   F5FD 13          CLOSEIT5:  INC	DE		;bump to next item in table.
2862   F5FE 23          	INC	HL
2863   F5FF 0D          	DEC	C		;there are 16 entries only.
2864   F600 C2 CD F5    	JP	NZ,CLOSEIT1	;continue if more to do.
2865   F603 01 EC FF    	LD	BC,0FFECH	;backup 20 places (extent byte).
2866   F606 09          	ADD	HL,BC
2867   F607 EB          	EX	DE,HL
2868   F608 09          	ADD	HL,BC
2869   F609 1A          	LD	A,(DE)
2870   F60A BE          	CP	(HL)		;directory's extent already greater than the
2871   F60B DA 17 F6    	JP	C,CLOSEIT6	;users extent?
2872   F60E 77          	LD	(HL),A		;no, update directory extent.
2873   F60F 01 03 00    	LD	BC,3		;and update the record count byte in
2874   F612 09          	ADD	HL,BC		;directories fcb.
2875   F613 EB          	EX	DE,HL
2876   F614 09          	ADD	HL,BC
2877   F615 7E          	LD	A,(HL)		;get from user.
2878   F616 12          	LD	(DE),A		;and put in directory.
2879   F617 3E FF       CLOSEIT6:  LD	A,0FFH		;set 'was open and is now closed' byte.
2880   F619 32 D2 FA    	LD	(CLOSEFLG),A
2881   F61C C3 10 F5    	JP	UPDATE1		;update the directory now.
2882   F61F 21 45 F0    CLOSEIT7:  LD	HL,STATUS	;set return status and then return.
2883   F622 35          	DEC	(HL)
2884   F623 C9          	RET	
2885   F624             ;
2886   F624             ;   Routine to get the next empty space in the directory. It
2887   F624             ; will then be cleared for use.
2888   F624             ;
2889   F624 CD 54 F2    GETEMPTY:  CALL	CHKWPRT		;make sure disk is not write protected.
2890   F627 2A 43 F0    	LD	HL,(PARAMS)	;save current parameters (fcb).
2891   F62A E5          	PUSH	HL
2892   F62B 21 AC FA    	LD	HL,EMPTYFCB	;use special one for empty space.
2893   F62E 22 43 F0    	LD	(PARAMS),HL
2894   F631 0E 01       	LD	C,1		;search for first empty spot in directory.
2895   F633 CD 18 F4    	CALL	FINDFST		;(* only check first byte *)
2896   F636 CD F5 F2    	CALL	CKFILPOS	;none?
2897   F639 E1          	POP	HL
2898   F63A 22 43 F0    	LD	(PARAMS),HL	;restore original fcb address.
2899   F63D C8          	RET	Z		;return if no more space.
2900   F63E EB          	EX	DE,HL
2901   F63F 21 0F 00    	LD	HL,15		;point to number of records for this file.
2902   F642 19          	ADD	HL,DE
2903   F643 0E 11       	LD	C,17		;and clear all of this space.
2904   F645 AF          	XOR	A
2905   F646 77          GETMT1: 	LD	(HL),A
2906   F647 23          	INC	HL
2907   F648 0D          	DEC	C
2908   F649 C2 46 F6    	JP	NZ,GETMT1
2909   F64C 21 0D 00    	LD	HL,13		;clear the 's1' byte also.
2910   F64F 19          	ADD	HL,DE
2911   F650 77          	LD	(HL),A
2912   F651 CD 8C F2    	CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
2913   F654 CD FD F4    	CALL	FCBSET		;write out this fcb entry to directory.
2914   F657 C3 78 F2    	JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
2915   F65A             ;
2916   F65A             ;   Routine to close the current extent and open the next one
2917   F65A             ; for reading.
2918   F65A             ;
2919   F65A AF          GETNEXT: XOR	A
2920   F65B 32 D2 FA    	LD	(CLOSEFLG),A	;clear close flag.
2921   F65E CD A2 F5    	CALL	CLOSEIT		;close this extent.
2922   F661 CD F5 F2    	CALL	CKFILPOS
2923   F664 C8          	RET	Z		;not there???
2924   F665 2A 43 F0    	LD	HL,(PARAMS)	;get extent byte.
2925   F668 01 0C 00    	LD	BC,12
2926   F66B 09          	ADD	HL,BC
2927   F66C 7E          	LD	A,(HL)		;and increment it.
2928   F66D 3C          	INC	A
2929   F66E E6 1F       	AND	1FH		;keep within range 0-31.
2930   F670 77          	LD	(HL),A
2931   F671 CA 83 F6    	JP	Z,GTNEXT1	;overflow?
2932   F674 47          	LD	B,A		;mask extent byte.
2933   F675 3A C5 FA    	LD	A,(EXTMASK)
2934   F678 A0          	AND	B
2935   F679 21 D2 FA    	LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
2936   F67C A6          	AND	(HL)
2937   F67D CA 8E F6    	JP	Z,GTNEXT2	;if zero, we must read in next extent.
2938   F680 C3 AC F6    	JP	GTNEXT3		;else, it is already in memory.
2939   F683 01 02 00    GTNEXT1: LD	BC,2		;Point to the 's2' byte.
2940   F686 09          	ADD	HL,BC
2941   F687 34          	INC	(HL)		;and bump it.
2942   F688 7E          	LD	A,(HL)		;too many extents?
2943   F689 E6 0F       	AND	0FH
2944   F68B CA B6 F6    	JP	Z,GTNEXT5	;yes, set error code.
2945   F68E             ;
2946   F68E             ;   Get here to open the next extent.
2947   F68E             ;
2948   F68E 0E 0F       GTNEXT2: LD	C,15		;set to check first 15 bytes of fcb.
2949   F690 CD 18 F4    	CALL	FINDFST		;find the first one.
2950   F693 CD F5 F2    	CALL	CKFILPOS	;none available?
2951   F696 C2 AC F6    	JP	NZ,GTNEXT3
2952   F699 3A D3 FA    	LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
2953   F69C 3C          	INC	A		;0ffh means reading (so not possible).
2954   F69D CA B6 F6    	JP	Z,GTNEXT5	;or an error.
2955   F6A0 CD 24 F6    	CALL	GETEMPTY	;we are writing, get an empty entry.
2956   F6A3 CD F5 F2    	CALL	CKFILPOS	;none?
2957   F6A6 CA B6 F6    	JP	Z,GTNEXT5	;error if true.
2958   F6A9 C3 AF F6    	JP	GTNEXT4		;else we are almost done.
2959   F6AC CD 5A F5    GTNEXT3: CALL	OPENIT1		;open this extent.
2960   F6AF CD BB F1    GTNEXT4: CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
2961   F6B2 AF          	XOR	A		;clear status and return.
2962   F6B3 C3 01 F0    	JP	SETSTAT
2963   F6B6             ;
2964   F6B6             ;   Error in extending the file. Too many extents were needed
2965   F6B6             ; or not enough space on the disk.
2966   F6B6             ;
2967   F6B6 CD 05 F0    GTNEXT5: CALL	IOERR1		;set error code, clear bit 7 of 's2'
2968   F6B9 C3 78 F2    	JP	SETS2B7		;so this is not written on a close.
2969   F6BC             ;
2970   F6BC             ;   Read a sequential file.
2971   F6BC             ;
2972   F6BC 3E 01       RDSEQ: 	LD	A,1		;set sequential access mode.
2973   F6BE 32 D5 FA    	LD	(MODE),A
2974   F6C1 3E FF       RDSEQ1: 	LD	A,0FFH		;don't allow reading unwritten space.
2975   F6C3 32 D3 FA    	LD	(RDWRTFLG),A
2976   F6C6 CD BB F1    	CALL	STRDATA		;put rec# and ext# into fcb.
2977   F6C9 3A E3 FA    	LD	A,(SAVNREC)	;get next record to read.
2978   F6CC 21 E1 FA    	LD	HL,SAVNXT	;get number of records in extent.
2979   F6CF BE          	CP	(HL)		;within this extent?
2980   F6D0 DA E6 F6    	JP	C,RDSEQ2
2981   F6D3 FE 80       	CP	128		;no. Is this extent fully used?
2982   F6D5 C2 FB F6    	JP	NZ,RDSEQ3	;no. End-of-file.
2983   F6D8 CD 5A F6    	CALL	GETNEXT		;yes, open the next one.
2984   F6DB AF          	XOR	A		;reset next record to read.
2985   F6DC 32 E3 FA    	LD	(SAVNREC),A
2986   F6DF 3A 45 F0    	LD	A,(STATUS)	;check on open, successful?
2987   F6E2 B7          	OR	A
2988   F6E3 C2 FB F6    	JP	NZ,RDSEQ3	;no, error.
2989   F6E6 CD 77 F1    RDSEQ2: 	CALL	COMBLK		;ok. compute block number to read.
2990   F6E9 CD 84 F1    	CALL	CHKBLK		;check it. Within bounds?
2991   F6EC CA FB F6    	JP	Z,RDSEQ3	;no, error.
2992   F6EF CD 8A F1    	CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
2993   F6F2 CD D1 F0    	CALL	TRKSEC1		;set the track and sector for this block #.
2994   F6F5 CD B2 F0    	CALL	DOREAD		;and read it.
2995   F6F8 C3 D2 F1    	JP	SETNREC		;and set the next record to be accessed.
2996   F6FB             ;
2997   F6FB             ;   Read error occured. Set status and return.
2998   F6FB             ;
2999   F6FB C3 05 F0    RDSEQ3: 	JP	IOERR1
3000   F6FE             ;
3001   F6FE             ;   Write the next sequential record.
3002   F6FE             ;
3003   F6FE 3E 01       WTSEQ: 	LD	A,1		;set sequential access mode.
3004   F700 32 D5 FA    	LD	(MODE),A
3005   F703 3E 00       WTSEQ1: 	LD	A,0		;allow an addition empty extent to be opened.
3006   F705 32 D3 FA    	LD	(RDWRTFLG),A
3007   F708 CD 54 F2    	CALL	CHKWPRT		;check write protect status.
3008   F70B 2A 43 F0    	LD	HL,(PARAMS)
3009   F70E CD 47 F2    	CALL	CKROF1		;check for read only file, (HL) already set to fcb.
3010   F711 CD BB F1    	CALL	STRDATA		;put updated data into fcb.
3011   F714 3A E3 FA    	LD	A,(SAVNREC)	;get record number to write.
3012   F717 FE 80       	CP	128		;within range?
3013   F719 D2 05 F0    	JP	NC,IOERR1	;no, error(?).
3014   F71C CD 77 F1    	CALL	COMBLK		;compute block number.
3015   F71F CD 84 F1    	CALL	CHKBLK		;check number.
3016   F722 0E 00       	LD	C,0		;is there one to write to?
3017   F724 C2 6E F7    	JP	NZ,WTSEQ6	;yes, go do it.
3018   F727 CD 3E F1    	CALL	GETBLOCK	;get next block number within fcb to use.
3019   F72A 32 D7 FA    	LD	(RELBLOCK),A	;and save.
3020   F72D 01 00 00    	LD	BC,0		;start looking for space from the start
3021   F730 B7          	OR	A		;if none allocated as yet.
3022   F731 CA 3B F7    	JP	Z,WTSEQ2
3023   F734 4F          	LD	C,A		;extract previous block number from fcb
3024   F735 0B          	DEC	BC		;so we can be closest to it.
3025   F736 CD 5E F1    	CALL	EXTBLK
3026   F739 44          	LD	B,H
3027   F73A 4D          	LD	C,L
3028   F73B CD BE F4    WTSEQ2: 	CALL	FNDSPACE	;find the next empty block nearest number (BC).
3029   F73E 7D          	LD	A,L		;check for a zero number.
3030   F73F B4          	OR	H
3031   F740 C2 48 F7    	JP	NZ,WTSEQ3
3032   F743 3E 02       	LD	A,2		;no more space?
3033   F745 C3 01 F0    	JP	SETSTAT
3034   F748 22 E5 FA    WTSEQ3: 	LD	(BLKNMBR),HL	;save block number to access.
3035   F74B EB          	EX	DE,HL		;put block number into (DE).
3036   F74C 2A 43 F0    	LD	HL,(PARAMS)	;now we must update the fcb for this
3037   F74F 01 10 00    	LD	BC,16		;newly allocated block.
3038   F752 09          	ADD	HL,BC
3039   F753 3A DD FA    	LD	A,(BIGDISK)	;8 or 16 bit block numbers?
3040   F756 B7          	OR	A
3041   F757 3A D7 FA    	LD	A,(RELBLOCK)	;(* update this entry *)
3042   F75A CA 64 F7    	JP	Z,WTSEQ4	;zero means 16 bit ones.
3043   F75D CD 64 F2    	CALL	ADDA2HL		;(HL)=(HL)+(A)
3044   F760 73          	LD	(HL),E		;store new block number.
3045   F761 C3 6C F7    	JP	WTSEQ5
3046   F764 4F          WTSEQ4: 	LD	C,A		;compute spot in this 16 bit table.
3047   F765 06 00       	LD	B,0
3048   F767 09          	ADD	HL,BC
3049   F768 09          	ADD	HL,BC
3050   F769 73          	LD	(HL),E		;stuff block number (DE) there.
3051   F76A 23          	INC	HL
3052   F76B 72          	LD	(HL),D
3053   F76C 0E 02       WTSEQ5: 	LD	C,2		;set (C) to indicate writing to un-used disk space.
3054   F76E 3A 45 F0    WTSEQ6: 	LD	A,(STATUS)	;are we ok so far?
3055   F771 B7          	OR	A
3056   F772 C0          	RET	NZ
3057   F773 C5          	PUSH	BC		;yes, save write flag for bios (register C).
3058   F774 CD 8A F1    	CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
3059   F777 3A D5 FA    	LD	A,(MODE)	;get access mode flag (1=sequential,
3060   F77A 3D          	DEC	A		;0=random, 2=special?).
3061   F77B 3D          	DEC	A
3062   F77C C2 BB F7    	JP	NZ,WTSEQ9
3063   F77F             ;
3064   F77F             ;   Special random i/o from function #40. Maybe for M/PM, but the
3065   F77F             ; current block, if it has not been written to, will be zeroed
3066   F77F             ; out and then written (reason?).
3067   F77F             ;
3068   F77F C1          	POP	BC
3069   F780 C5          	PUSH	BC
3070   F781 79          	LD	A,C		;get write status flag (2=writing unused space).
3071   F782 3D          	DEC	A
3072   F783 3D          	DEC	A
3073   F784 C2 BB F7    	JP	NZ,WTSEQ9
3074   F787 E5          	PUSH	HL
3075   F788 2A B9 FA    	LD	HL,(DIRBUF)	;zero out the directory buffer.
3076   F78B 57          	LD	D,A		;note that (A) is zero here.
3077   F78C 77          WTSEQ7: 	LD	(HL),A
3078   F78D 23          	INC	HL
3079   F78E 14          	INC	D		;do 128 bytes.
3080   F78F F2 8C F7    	JP	P,WTSEQ7
3081   F792 CD E0 F2    	CALL	DIRDMA		;tell the bios the dma address for directory access.
3082   F795 2A E7 FA    	LD	HL,(LOGSECT)	;get sector that starts current block.
3083   F798 0E 02       	LD	C,2		;set 'writing to unused space' flag.
3084   F79A 22 E5 FA    WTSEQ8: 	LD	(BLKNMBR),HL	;save sector to write.
3085   F79D C5          	PUSH	BC
3086   F79E CD D1 F0    	CALL	TRKSEC1		;determine its track and sector numbers.
3087   F7A1 C1          	POP	BC
3088   F7A2 CD B8 F0    	CALL	DOWRITE		;now write out 128 bytes of zeros.
3089   F7A5 2A E5 FA    	LD	HL,(BLKNMBR)	;get sector number.
3090   F7A8 0E 00       	LD	C,0		;set normal write flag.
3091   F7AA 3A C4 FA    	LD	A,(BLKMASK)	;determine if we have written the entire
3092   F7AD 47          	LD	B,A		;physical block.
3093   F7AE A5          	AND	L
3094   F7AF B8          	CP	B
3095   F7B0 23          	INC	HL		;prepare for the next one.
3096   F7B1 C2 9A F7    	JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
3097   F7B4 E1          	POP	HL		;reset next sector number.
3098   F7B5 22 E5 FA    	LD	(BLKNMBR),HL
3099   F7B8 CD DA F2    	CALL	DEFDMA		;and reset dma address.
3100   F7BB             ;
3101   F7BB             ;   Normal disk write. Set the desired track and sector then
3102   F7BB             ; do the actual write.
3103   F7BB             ;
3104   F7BB CD D1 F0    WTSEQ9: 	CALL	TRKSEC1		;determine track and sector for this write.
3105   F7BE C1          	POP	BC		;get write status flag.
3106   F7BF C5          	PUSH	BC
3107   F7C0 CD B8 F0    	CALL	DOWRITE		;and write this out.
3108   F7C3 C1          	POP	BC
3109   F7C4 3A E3 FA    	LD	A,(SAVNREC)	;get number of records in file.
3110   F7C7 21 E1 FA    	LD	HL,SAVNXT	;get last record written.
3111   F7CA BE          	CP	(HL)
3112   F7CB DA D2 F7    	JP	C,WTSEQ10
3113   F7CE 77          	LD	(HL),A		;we have to update record count.
3114   F7CF 34          	INC	(HL)
3115   F7D0 0E 02       	LD	C,2
3116   F7D2             ;
3117   F7D2             ;*   This area has been patched to correct disk update problem
3118   F7D2             ;* when using blocking and de-blocking in the BIOS.
3119   F7D2             ;
3120   F7D2 00          WTSEQ10: NOP			;was 'dcr c'
3121   F7D3 00          	NOP			;was 'dcr c'
3122   F7D4 21 00 00    	LD	HL,0		;was 'jnz wtseq99'
3123   F7D7             ;
3124   F7D7             ; *   End of patch.
3125   F7D7             ;
3126   F7D7 F5          	PUSH	AF
3127   F7D8 CD 69 F2    	CALL	GETS2		;set 'extent written to' flag.
3128   F7DB E6 7F       	AND	7FH		;(* clear bit 7 *)
3129   F7DD 77          	LD	(HL),A
3130   F7DE F1          	POP	AF		;get record count for this extent.
3131   F7DF FE 7F       WTSEQ99: CP	127		;is it full?
3132   F7E1 C2 00 F8    	JP	NZ,WTSEQ12
3133   F7E4 3A D5 FA    	LD	A,(MODE)	;yes, are we in sequential mode?
3134   F7E7 FE 01       	CP	1
3135   F7E9 C2 00 F8    	JP	NZ,WTSEQ12
3136   F7EC CD D2 F1    	CALL	SETNREC		;yes, set next record number.
3137   F7EF CD 5A F6    	CALL	GETNEXT		;and get next empty space in directory.
3138   F7F2 21 45 F0    	LD	HL,STATUS	;ok?
3139   F7F5 7E          	LD	A,(HL)
3140   F7F6 B7          	OR	A
3141   F7F7 C2 FE F7    	JP	NZ,WTSEQ11
3142   F7FA 3D          	DEC	A		;yes, set record count to -1.
3143   F7FB 32 E3 FA    	LD	(SAVNREC),A
3144   F7FE 36 00       WTSEQ11: LD	(HL),0		;clear status.
3145   F800 C3 D2 F1    WTSEQ12: JP	SETNREC		;set next record to access.
3146   F803             ;
3147   F803             ;   For random i/o, set the fcb for the desired record number
3148   F803             ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
3149   F803             ; used as follows:
3150   F803             ;
3151   F803             ;       fcb+35            fcb+34            fcb+33
3152   F803             ;  |     'r-2'      |      'r-1'      |      'r-0'     |
3153   F803             ;  |7             0 | 7             0 | 7             0|
3154   F803             ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3155   F803             ;  |    overflow   | | extra |  extent   |   record #  |
3156   F803             ;  | ______________| |_extent|__number___|_____________|
3157   F803             ;                     also 's2'
3158   F803             ;
3159   F803             ;   On entry, register (C) contains 0ffh if this is a read
3160   F803             ; and thus we can not access unwritten disk space. Otherwise,
3161   F803             ; another extent will be opened (for writing) if required.
3162   F803             ;
3163   F803 AF          POSITION:  XOR	A		;set random i/o flag.
3164   F804 32 D5 FA    	LD	(MODE),A
3165   F807             ;
3166   F807             ;   Special entry (function #40). M/PM ?
3167   F807             ;
3168   F807 C5          POSITN1: PUSH	BC		;save read/write flag.
3169   F808 2A 43 F0    	LD	HL,(PARAMS)	;get address of fcb.
3170   F80B EB          	EX	DE,HL
3171   F80C 21 21 00    	LD	HL,33		;now get byte 'r0'.
3172   F80F 19          	ADD	HL,DE
3173   F810 7E          	LD	A,(HL)
3174   F811 E6 7F       	AND	7FH		;keep bits 0-6 for the record number to access.
3175   F813 F5          	PUSH	AF
3176   F814 7E          	LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
3177   F815 17          	RLA	
3178   F816 23          	INC	HL
3179   F817 7E          	LD	A,(HL)
3180   F818 17          	RLA	
3181   F819 E6 1F       	AND	1FH		;and save this in bits 0-4 of (C).
3182   F81B 4F          	LD	C,A		;this is the extent byte.
3183   F81C 7E          	LD	A,(HL)		;now get the extra extent byte.
3184   F81D 1F          	RRA	
3185   F81E 1F          	RRA	
3186   F81F 1F          	RRA	
3187   F820 1F          	RRA	
3188   F821 E6 0F       	AND	0FH
3189   F823 47          	LD	B,A		;and save it in (B).
3190   F824 F1          	POP	AF		;get record number back to (A).
3191   F825 23          	INC	HL		;check overflow byte 'r2'.
3192   F826 6E          	LD	L,(HL)
3193   F827 2C          	INC	L
3194   F828 2D          	DEC	L
3195   F829 2E 06       	LD	L,6		;prepare for error.
3196   F82B C2 8B F8    	JP	NZ,POSITN5	;out of disk space error.
3197   F82E 21 20 00    	LD	HL,32		;store record number into fcb.
3198   F831 19          	ADD	HL,DE
3199   F832 77          	LD	(HL),A
3200   F833 21 0C 00    	LD	HL,12		;and now check the extent byte.
3201   F836 19          	ADD	HL,DE
3202   F837 79          	LD	A,C
3203   F838 96          	SUB	(HL)		;same extent as before?
3204   F839 C2 47 F8    	JP	NZ,POSITN2
3205   F83C 21 0E 00    	LD	HL,14		;yes, check extra extent byte 's2' also.
3206   F83F 19          	ADD	HL,DE
3207   F840 78          	LD	A,B
3208   F841 96          	SUB	(HL)
3209   F842 E6 7F       	AND	7FH
3210   F844 CA 7F F8    	JP	Z,POSITN3	;same, we are almost done then.
3211   F847             ;
3212   F847             ;  Get here when another extent is required.
3213   F847             ;
3214   F847 C5          POSITN2: PUSH	BC
3215   F848 D5          	PUSH	DE
3216   F849 CD A2 F5    	CALL	CLOSEIT		;close current extent.
3217   F84C D1          	POP	DE
3218   F84D C1          	POP	BC
3219   F84E 2E 03       	LD	L,3		;prepare for error.
3220   F850 3A 45 F0    	LD	A,(STATUS)
3221   F853 3C          	INC	A
3222   F854 CA 84 F8    	JP	Z,POSITN4	;close error.
3223   F857 21 0C 00    	LD	HL,12		;put desired extent into fcb now.
3224   F85A 19          	ADD	HL,DE
3225   F85B 71          	LD	(HL),C
3226   F85C 21 0E 00    	LD	HL,14		;and store extra extent byte 's2'.
3227   F85F 19          	ADD	HL,DE
3228   F860 70          	LD	(HL),B
3229   F861 CD 51 F5    	CALL	OPENIT		;try and get this extent.
3230   F864 3A 45 F0    	LD	A,(STATUS)	;was it there?
3231   F867 3C          	INC	A   
3232   F868 C2 7F F8    	JP	NZ,POSITN3
3233   F86B C1          	POP	BC		;no. can we create a new one (writing?).
3234   F86C C5          	PUSH	BC
3235   F86D 2E 04       	LD	L,4		;prepare for error.
3236   F86F 0C          	INC	C
3237   F870 CA 84 F8    	JP	Z,POSITN4	;nope, reading unwritten space error.
3238   F873 CD 24 F6    	CALL	GETEMPTY	;yes we can, try to find space.
3239   F876 2E 05       	LD	L,5		;prepare for error.
3240   F878 3A 45 F0    	LD	A,(STATUS)
3241   F87B 3C          	INC	A
3242   F87C CA 84 F8    	JP	Z,POSITN4	;out of space?
3243   F87F             ;
3244   F87F             ;   Normal return location. Clear error code and return.
3245   F87F             ;
3246   F87F C1          POSITN3: POP	BC		;restore stack.
3247   F880 AF          	XOR	A		;and clear error code byte.
3248   F881 C3 01 F0    	JP	SETSTAT
3249   F884             ;
3250   F884             ;   Error. Set the 's2' byte to indicate this (why?).
3251   F884             ;
3252   F884 E5          POSITN4: PUSH	HL
3253   F885 CD 69 F2    	CALL	GETS2
3254   F888 36 C0       	LD	(HL),0C0H
3255   F88A E1          	POP	HL
3256   F88B             ;
3257   F88B             ;   Return with error code (presently in L).
3258   F88B             ;
3259   F88B C1          POSITN5: POP	BC
3260   F88C 7D          	LD	A,L		;get error code.
3261   F88D 32 45 F0    	LD	(STATUS),A
3262   F890 C3 78 F2    	JP	SETS2B7
3263   F893             ;
3264   F893             ;   Read a random record.
3265   F893             ;
3266   F893 0E FF       READRAN: LD	C,0FFH		;set 'read' status.
3267   F895 CD 03 F8    	CALL	POSITION	;position the file to proper record.
3268   F898 CC C1 F6    	CALL	Z,RDSEQ1	;and read it as usual (if no errors).
3269   F89B C9          	RET	
3270   F89C             ;
3271   F89C             ;   Write to a random record.
3272   F89C             ;
3273   F89C 0E 00       WRITERAN:  LD	C,0		;set 'writing' flag.
3274   F89E CD 03 F8    	CALL	POSITION	;position the file to proper record.
3275   F8A1 CC 03 F7    	CALL	Z,WTSEQ1	;and write as usual (if no errors).
3276   F8A4 C9          	RET	
3277   F8A5             ;
3278   F8A5             ;   Compute the random record number. Enter with (HL) pointing
3279   F8A5             ; to a fcb an (DE) contains a relative location of a record
3280   F8A5             ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
3281   F8A5             ; byte, and (A) the 'r2' byte.
3282   F8A5             ;
3283   F8A5             ;   On return, the zero flag is set if the record is within
3284   F8A5             ; bounds. Otherwise, an overflow occured.
3285   F8A5             ;
3286   F8A5             
3287   F8A5 EB          COMPRAND:  EX	DE,HL		;save fcb pointer in (DE).
3288   F8A6 19          	ADD	HL,DE		;compute relative position of record #.
3289   F8A7 4E          	LD	C,(HL)		;get record number into (BC).
3290   F8A8 06 00       	LD	B,0
3291   F8AA 21 0C 00    	LD	HL,12		;now get extent.
3292   F8AD 19          	ADD	HL,DE
3293   F8AE 7E          	LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
3294   F8AF 0F          	RRCA			;move lower bit into bit 7.
3295   F8B0 E6 80       	AND	80H		;and ignore all other bits.
3296   F8B2 81          	ADD	A,C		;add to our record number.
3297   F8B3 4F          	LD	C,A
3298   F8B4 3E 00       	LD	A,0		;take care of any carry.
3299   F8B6 88          	ADC	A,B
3300   F8B7 47          	LD	B,A
3301   F8B8 7E          	LD	A,(HL)		;now get the upper bits of extent into
3302   F8B9 0F          	RRCA			;bit positions 0-3.
3303   F8BA E6 0F       	AND	0FH		;and ignore all others.
3304   F8BC 80          	ADD	A,B		;add this in to 'r1' byte.
3305   F8BD 47          	LD	B,A
3306   F8BE 21 0E 00    	LD	HL,14		;get the 's2' byte (extra extent).
3307   F8C1 19          	ADD	HL,DE
3308   F8C2 7E          	LD	A,(HL)
3309   F8C3 87          	ADD	A,A		;and shift it left 4 bits (bits 4-7).
3310   F8C4 87          	ADD	A,A
3311   F8C5 87          	ADD	A,A
3312   F8C6 87          	ADD	A,A
3313   F8C7 F5          	PUSH	AF		;save carry flag (bit 0 of flag byte).
3314   F8C8 80          	ADD	A,B		;now add extra extent into 'r1'.
3315   F8C9 47          	LD	B,A
3316   F8CA F5          	PUSH	AF		;and save carry (overflow byte 'r2').
3317   F8CB E1          	POP	HL		;bit 0 of (L) is the overflow indicator.
3318   F8CC 7D          	LD	A,L
3319   F8CD E1          	POP	HL		;and same for first carry flag.
3320   F8CE B5          	OR	L		;either one of these set?
3321   F8CF E6 01       	AND	01H		;only check the carry flags.
3322   F8D1 C9          	RET	
3323   F8D2             ;
3324   F8D2             ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
3325   F8D2             ; reflect the last record used for a random (or other) file.
3326   F8D2             ; This reads the directory and looks at all extents computing
3327   F8D2             ; the largerst record number for each and keeping the maximum
3328   F8D2             ; value only. Then 'r0', 'r1', and 'r2' will reflect this
3329   F8D2             ; maximum record number. This is used to compute the space used
3330   F8D2             ; by a random file.
3331   F8D2             ;
3332   F8D2 0E 0C       RANSIZE: LD	C,12		;look thru directory for first entry with
3333   F8D4 CD 18 F4    	CALL	FINDFST		;this name.
3334   F8D7 2A 43 F0    	LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
3335   F8DA 11 21 00    	LD	DE,33
3336   F8DD 19          	ADD	HL,DE
3337   F8DE E5          	PUSH	HL
3338   F8DF 72          	LD	(HL),D		;note that (D)=0.
3339   F8E0 23          	INC	HL
3340   F8E1 72          	LD	(HL),D
3341   F8E2 23          	INC	HL
3342   F8E3 72          	LD	(HL),D
3343   F8E4 CD F5 F2    RANSIZ1: CALL	CKFILPOS	;is there an extent to process?
3344   F8E7 CA 0C F9    	JP	Z,RANSIZ3	;no, we are done.
3345   F8EA CD 5E F2    	CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
3346   F8ED 11 0F 00    	LD	DE,15		;point to last record in extent.
3347   F8F0 CD A5 F8    	CALL	COMPRAND	;and compute random parameters.
3348   F8F3 E1          	POP	HL
3349   F8F4 E5          	PUSH	HL		;now check these values against those
3350   F8F5 5F          	LD	E,A		;already in fcb.
3351   F8F6 79          	LD	A,C		;the carry flag will be set if those
3352   F8F7 96          	SUB	(HL)		;in the fcb represent a larger size than
3353   F8F8 23          	INC	HL		;this extent does.
3354   F8F9 78          	LD	A,B
3355   F8FA 9E          	SBC	A,(HL)
3356   F8FB 23          	INC	HL
3357   F8FC 7B          	LD	A,E
3358   F8FD 9E          	SBC	A,(HL)
3359   F8FE DA 06 F9    	JP	C,RANSIZ2
3360   F901 73          	LD	(HL),E		;we found a larger (in size) extent.
3361   F902 2B          	DEC	HL		;stuff these values into fcb.
3362   F903 70          	LD	(HL),B
3363   F904 2B          	DEC	HL
3364   F905 71          	LD	(HL),C
3365   F906 CD 2D F4    RANSIZ2: CALL	FINDNXT		;now get the next extent.
3366   F909 C3 E4 F8    	JP	RANSIZ1		;continue til all done.
3367   F90C E1          RANSIZ3: POP	HL		;we are done, restore the stack and
3368   F90D C9          	RET			;return.
3369   F90E             ;
3370   F90E             ;   Function to return the random record position of a given
3371   F90E             ; file which has been read in sequential mode up to now.
3372   F90E             ;
3373   F90E 2A 43 F0    SETRAN: 	LD	HL,(PARAMS)	;point to fcb.
3374   F911 11 20 00    	LD	DE,32		;and to last used record.
3375   F914 CD A5 F8    	CALL	COMPRAND	;compute random position.
3376   F917 21 21 00    	LD	HL,33		;now stuff these values into fcb.
3377   F91A 19          	ADD	HL,DE
3378   F91B 71          	LD	(HL),C		;move 'r0'.
3379   F91C 23          	INC	HL
3380   F91D 70          	LD	(HL),B		;and 'r1'.
3381   F91E 23          	INC	HL
3382   F91F 77          	LD	(HL),A		;and lastly 'r2'.
3383   F920 C9          	RET	
3384   F921             ;
3385   F921             ;   This routine select the drive specified in (ACTIVE) and
3386   F921             ; update the login vector and bitmap table if this drive was
3387   F921             ; not already active.
3388   F921             ;
3389   F921 2A AF FA    LOGINDRV:  LD	HL,(LOGIN)	;get the login vector.
3390   F924 3A 42 F0    	LD	A,(ACTIVE)	;get the default drive.
3391   F927 4F          	LD	C,A
3392   F928 CD EA F1    	CALL	SHIFTR		;position active bit for this drive
3393   F92B E5          	PUSH	HL		;into bit 0.
3394   F92C EB          	EX	DE,HL
3395   F92D CD 59 F0    	CALL	SELECT		;select this drive.
3396   F930 E1          	POP	HL
3397   F931 CC 47 F0    	CALL	Z,SLCTERR	;valid drive?
3398   F934 7D          	LD	A,L		;is this a newly activated drive?
3399   F935 1F          	RRA	
3400   F936 D8          	RET	C
3401   F937 2A AF FA    	LD	HL,(LOGIN)	;yes, update the login vector.
3402   F93A 4D          	LD	C,L
3403   F93B 44          	LD	B,H
3404   F93C CD 0B F2    	CALL	SETBIT
3405   F93F 22 AF FA    	LD	(LOGIN),HL	;and save.
3406   F942 C3 A3 F3    	JP	BITMAP		;now update the bitmap.
3407   F945             ;
3408   F945             ;   Function to set the active disk number.
3409   F945             ;
3410   F945 3A D6 FA    SETDSK: 	LD	A,(EPARAM)	;get parameter passed and see if this
3411   F948 21 42 F0    	LD	HL,ACTIVE	;represents a change in drives.
3412   F94B BE          	CP	(HL)
3413   F94C C8          	RET	Z
3414   F94D 77          	LD	(HL),A		;yes it does, log it in.
3415   F94E C3 21 F9    	JP	LOGINDRV
3416   F951             ;
3417   F951             ;   This is the 'auto disk select' routine. The firsst byte
3418   F951             ; of the fcb is examined for a drive specification. If non
3419   F951             ; zero then the drive will be selected and loged in.
3420   F951             ;
3421   F951 3E FF       AUTOSEL: LD	A,0FFH		;say 'auto-select activated'.
3422   F953 32 DE FA    	LD	(AUTO),A
3423   F956 2A 43 F0    	LD	HL,(PARAMS)	;get drive specified.
3424   F959 7E          	LD	A,(HL)
3425   F95A E6 1F       	AND	1FH		;look at lower 5 bits.
3426   F95C 3D          	DEC	A		;adjust for (1=A, 2=B) etc.
3427   F95D 32 D6 FA    	LD	(EPARAM),A	;and save for the select routine.
3428   F960 FE 1E       	CP	1EH		;check for 'no change' condition.
3429   F962 D2 75 F9    	JP	NC,AUTOSL1	;yes, don't change.
3430   F965 3A 42 F0    	LD	A,(ACTIVE)	;we must change, save currently active
3431   F968 32 DF FA    	LD	(OLDDRV),A	;drive.
3432   F96B 7E          	LD	A,(HL)		;and save first byte of fcb also.
3433   F96C 32 E0 FA    	LD	(AUTOFLAG),A	;this must be non-zero.
3434   F96F E6 E0       	AND	0E0H		;whats this for (bits 6,7 are used for
3435   F971 77          	LD	(HL),A		;something)?
3436   F972 CD 45 F9    	CALL	SETDSK		;select and log in this drive.
3437   F975 3A 41 F0    AUTOSL1: LD	A,(USERNO)	;move user number into fcb.
3438   F978 2A 43 F0    	LD	HL,(PARAMS)	;(* upper half of first byte *)
3439   F97B B6          	OR	(HL)
3440   F97C 77          	LD	(HL),A
3441   F97D C9          	RET			;and return (all done).
3442   F97E             ;
3443   F97E             ;   Function to return the current cp/m version number.
3444   F97E             ;
3445   F97E 3E 22       GETVER: 	LD	A,022H		;version 2.2
3446   F980 C3 01 F0    	JP	SETSTAT
3447   F983             ;
3448   F983             ;   Function to reset the disk system.
3449   F983             ;
3450   F983 21 00 00    RSTDSK: 	LD	HL,0		;clear write protect status and log
3451   F986 22 AD FA    	LD	(WRTPRT),HL	;in vector.
3452   F989 22 AF FA    	LD	(LOGIN),HL
3453   F98C AF          	XOR	A		;select drive 'A'.
3454   F98D 32 42 F0    	LD	(ACTIVE),A
3455   F990 21 80 00    	LD	HL,TBUFF	;setup default dma address.
3456   F993 22 B1 FA    	LD	(USERDMA),HL
3457   F996 CD DA F2    	CALL	DEFDMA
3458   F999 C3 21 F9    	JP	LOGINDRV	;now log in drive 'A'.
3459   F99C             ;
3460   F99C             ;   Function to open a specified file.
3461   F99C             ;
3462   F99C CD 72 F2    OPENFIL: CALL	CLEARS2		;clear 's2' byte.
3463   F99F CD 51 F9    	CALL	AUTOSEL		;select proper disk.
3464   F9A2 C3 51 F5    	JP	OPENIT		;and open the file.
3465   F9A5             ;
3466   F9A5             ;   Function to close a specified file.
3467   F9A5             ;
3468   F9A5 CD 51 F9    CLOSEFIL:  CALL	AUTOSEL		;select proper disk.
3469   F9A8 C3 A2 F5    	JP	CLOSEIT		;and close the file.
3470   F9AB             ;
3471   F9AB             ;   Function to return the first occurence of a specified file
3472   F9AB             ; name. If the first byte of the fcb is '?' then the name will
3473   F9AB             ; not be checked (get the first entry no matter what).
3474   F9AB             ;
3475   F9AB 0E 00       GETFST: 	LD	C,0		;prepare for special search.
3476   F9AD EB          	EX	DE,HL
3477   F9AE 7E          	LD	A,(HL)		;is first byte a '?'?
3478   F9AF FE 3F       	CP	'?'
3479   F9B1 CA C2 F9    	JP	Z,GETFST1	;yes, just get very first entry (zero length match).
3480   F9B4 CD A6 F1    	CALL	SETEXT		;get the extension byte from fcb.
3481   F9B7 7E          	LD	A,(HL)		;is it '?'? if yes, then we want
3482   F9B8 FE 3F       	CP	'?'		;an entry with a specific 's2' byte.
3483   F9BA C4 72 F2    	CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
3484   F9BD CD 51 F9    	CALL	AUTOSEL		;select proper drive.
3485   F9C0 0E 0F       	LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
3486   F9C2 CD 18 F4    GETFST1: CALL	FINDFST		;find an entry and then move it into
3487   F9C5 C3 E9 F2    	JP	MOVEDIR		;the users dma space.
3488   F9C8             ;
3489   F9C8             ;   Function to return the next occurence of a file name.
3490   F9C8             ;
3491   F9C8 2A D9 FA    GETNXT: 	LD	HL,(SAVEFCB)	;restore pointers. note that no
3492   F9CB 22 43 F0    	LD	(PARAMS),HL	;other dbos calls are allowed.
3493   F9CE CD 51 F9    	CALL	AUTOSEL		;no error will be returned, but the
3494   F9D1 CD 2D F4    	CALL	FINDNXT		;results will be wrong.
3495   F9D4 C3 E9 F2    	JP	MOVEDIR
3496   F9D7             ;
3497   F9D7             ;   Function to delete a file by name.
3498   F9D7             ;
3499   F9D7 CD 51 F9    DELFILE: CALL	AUTOSEL		;select proper drive.
3500   F9DA CD 9C F4    	CALL	ERAFILE		;erase the file.
3501   F9DD C3 01 F4    	JP	STSTATUS	;set status and return.
3502   F9E0             ;
3503   F9E0             ;   Function to execute a sequential read of the specified
3504   F9E0             ; record number.
3505   F9E0             ;
3506   F9E0 CD 51 F9    READSEQ: CALL	AUTOSEL		;select proper drive then read.
3507   F9E3 C3 BC F6    	JP	RDSEQ
3508   F9E6             ;
3509   F9E6             ;   Function to write the net sequential record.
3510   F9E6             ;
3511   F9E6 CD 51 F9    WRTSEQ: 	CALL	AUTOSEL		;select proper drive then write.
3512   F9E9 C3 FE F6    	JP	WTSEQ
3513   F9EC             ;
3514   F9EC             ;   Create a file function.
3515   F9EC             ;
3516   F9EC CD 72 F2    FCREATE: CALL	CLEARS2		;clear the 's2' byte on all creates.
3517   F9EF CD 51 F9    	CALL	AUTOSEL		;select proper drive and get the next
3518   F9F2 C3 24 F6    	JP	GETEMPTY	;empty directory space.
3519   F9F5             ;
3520   F9F5             ;   Function to rename a file.
3521   F9F5             ;
3522   F9F5 CD 51 F9    RENFILE: CALL	AUTOSEL		;select proper drive and then switch
3523   F9F8 CD 16 F5    	CALL	CHGNAMES	;file names.
3524   F9FB C3 01 F4    	JP	STSTATUS
3525   F9FE             ;
3526   F9FE             ;   Function to return the login vector.
3527   F9FE             ;
3528   F9FE 2A AF FA    GETLOG: 	LD	HL,(LOGIN)
3529   FA01 C3 29 FA    	JP	GETPRM1
3530   FA04             ;
3531   FA04             ;   Function to return the current disk assignment.
3532   FA04             ;
3533   FA04 3A 42 F0    GETCRNT: LD	A,(ACTIVE)
3534   FA07 C3 01 F0    	JP	SETSTAT
3535   FA0A             ;
3536   FA0A             ;   Function to set the dma address.
3537   FA0A             ;
3538   FA0A EB          PUTDMA: 	EX	DE,HL
3539   FA0B 22 B1 FA    	LD	(USERDMA),HL	;save in our space and then get to
3540   FA0E C3 DA F2    	JP	DEFDMA		;the bios with this also.
3541   FA11             ;
3542   FA11             ;   Function to return the allocation vector.
3543   FA11             ;
3544   FA11 2A BF FA    GETALOC: LD	HL,(ALOCVECT)
3545   FA14 C3 29 FA    	JP	GETPRM1
3546   FA17             ;
3547   FA17             ;   Function to return the read-only status vector.
3548   FA17             ;
3549   FA17 2A AD FA    GETROV: 	LD	HL,(WRTPRT)
3550   FA1A C3 29 FA    	JP	GETPRM1
3551   FA1D             ;
3552   FA1D             ;   Function to set the file attributes (read-only, system).
3553   FA1D             ;
3554   FA1D CD 51 F9    SETATTR: CALL	AUTOSEL		;select proper drive then save attributes.
3555   FA20 CD 3B F5    	CALL	SAVEATTR
3556   FA23 C3 01 F4    	JP	STSTATUS
3557   FA26             ;
3558   FA26             ;   Function to return the address of the disk parameter block
3559   FA26             ; for the current drive.
3560   FA26             ;
3561   FA26 2A BB FA    GETPARM: LD	HL,(DISKPB)
3562   FA29 22 45 F0    GETPRM1: LD	(STATUS),HL
3563   FA2C C9          	RET	
3564   FA2D             ;
3565   FA2D             ;   Function to get or set the user number. If (E) was (FF)
3566   FA2D             ; then this is a request to return the current user number.
3567   FA2D             ; Else set the user number from (E).
3568   FA2D             ;
3569   FA2D 3A D6 FA    GETUSER: LD	A,(EPARAM)	;get parameter.
3570   FA30 FE FF       	CP	0FFH		;get user number?
3571   FA32 C2 3B FA    	JP	NZ,SETUSER
3572   FA35 3A 41 F0    	LD	A,(USERNO)	;yes, just do it.
3573   FA38 C3 01 F0    	JP	SETSTAT
3574   FA3B E6 1F       SETUSER: AND	1FH		;no, we should set it instead. keep low
3575   FA3D 32 41 F0    	LD	(USERNO),A	;bits (0-4) only.
3576   FA40 C9          	RET	
3577   FA41             ;
3578   FA41             ;   Function to read a random record from a file.
3579   FA41             ;
3580   FA41 CD 51 F9    RDRANDOM:  CALL	AUTOSEL		;select proper drive and read.
3581   FA44 C3 93 F8    	JP	READRAN
3582   FA47             ;
3583   FA47             ;   Function to compute the file size for random files.
3584   FA47             ;
3585   FA47 CD 51 F9    WTRANDOM:  CALL	AUTOSEL		;select proper drive and write.
3586   FA4A C3 9C F8    	JP	WRITERAN
3587   FA4D             ;
3588   FA4D             ;   Function to compute the size of a random file.
3589   FA4D             ;
3590   FA4D CD 51 F9    FILESIZE:  CALL	AUTOSEL		;select proper drive and check file length
3591   FA50 C3 D2 F8    	JP	RANSIZE
3592   FA53             ;
3593   FA53             ;   Function #37. This allows a program to log off any drives.
3594   FA53             ; On entry, set (DE) to contain a word with bits set for those
3595   FA53             ; drives that are to be logged off. The log-in vector and the
3596   FA53             ; write protect vector will be updated. This must be a M/PM
3597   FA53             ; special function.
3598   FA53             ;
3599   FA53 2A 43 F0    LOGOFF: 	LD	HL,(PARAMS)	;get drives to log off.
3600   FA56 7D          	LD	A,L		;for each bit that is set, we want
3601   FA57 2F          	CPL			;to clear that bit in (LOGIN)
3602   FA58 5F          	LD	E,A		;and (WRTPRT).
3603   FA59 7C          	LD	A,H
3604   FA5A 2F          	CPL	
3605   FA5B 2A AF FA    	LD	HL,(LOGIN)	;reset the login vector.
3606   FA5E A4          	AND	H
3607   FA5F 57          	LD	D,A
3608   FA60 7D          	LD	A,L
3609   FA61 A3          	AND	E
3610   FA62 5F          	LD	E,A
3611   FA63 2A AD FA    	LD	HL,(WRTPRT)
3612   FA66 EB          	EX	DE,HL
3613   FA67 22 AF FA    	LD	(LOGIN),HL	;and save.
3614   FA6A 7D          	LD	A,L		;now do the write protect vector.
3615   FA6B A3          	AND	E
3616   FA6C 6F          	LD	L,A
3617   FA6D 7C          	LD	A,H
3618   FA6E A2          	AND	D
3619   FA6F 67          	LD	H,A
3620   FA70 22 AD FA    	LD	(WRTPRT),HL	;and save. all done.
3621   FA73 C9          	RET	
3622   FA74             ;
3623   FA74             ;   Get here to return to the user.
3624   FA74             ;
3625   FA74 3A DE FA    GOBACK: 	LD	A,(AUTO)	;was auto select activated?
3626   FA77 B7          	OR	A
3627   FA78 CA 91 FA    	JP	Z,GOBACK1
3628   FA7B 2A 43 F0    	LD	HL,(PARAMS)	;yes, but was a change made?
3629   FA7E 36 00       	LD	(HL),0		;(* reset first byte of fcb *)
3630   FA80 3A E0 FA    	LD	A,(AUTOFLAG)
3631   FA83 B7          	OR	A
3632   FA84 CA 91 FA    	JP	Z,GOBACK1
3633   FA87 77          	LD	(HL),A		;yes, reset first byte properly.
3634   FA88 3A DF FA    	LD	A,(OLDDRV)	;and get the old drive and select it.
3635   FA8B 32 D6 FA    	LD	(EPARAM),A
3636   FA8E CD 45 F9    	CALL	SETDSK
3637   FA91 2A 0F F0    GOBACK1: LD	HL,(USRSTACK)	;reset the users stack pointer.
3638   FA94 F9          	LD	SP,HL
3639   FA95 2A 45 F0    	LD	HL,(STATUS)	;get return status.
3640   FA98 7D          	LD	A,L		;force version 1.4 compatability.
3641   FA99 44          	LD	B,H
3642   FA9A C9          	RET			;and go back to user.
3643   FA9B             ;
3644   FA9B             ;   Function #40. This is a special entry to do random i/o.
3645   FA9B             ; For the case where we are writing to unused disk space, this
3646   FA9B             ; space will be zeroed out first. This must be a M/PM special
3647   FA9B             ; purpose function, because why would any normal program even
3648   FA9B             ; care about the previous contents of a sector about to be
3649   FA9B             ; written over.
3650   FA9B             ;
3651   FA9B CD 51 F9    WTSPECL: CALL	AUTOSEL		;select proper drive.
3652   FA9E 3E 02       	LD	A,2		;use special write mode.
3653   FAA0 32 D5 FA    	LD	(MODE),A
3654   FAA3 0E 00       	LD	C,0		;set write indicator.
3655   FAA5 CD 07 F8    	CALL	POSITN1		;position the file.
3656   FAA8 CC 03 F7    	CALL	Z,WTSEQ1	;and write (if no errors).
3657   FAAB C9          	RET	
3658   FAAC             ;
3659   FAAC             ;**************************************************************
3660   FAAC             ;*
3661   FAAC             ;*     BDOS data storage pool.
3662   FAAC             ;*
3663   FAAC             ;**************************************************************
3664   FAAC             ;
3665   FAAC E5          EMPTYFCB:  .DB	0E5H		;empty directory segment indicator.
3666   FAAD 00 00       WRTPRT: 	.DW	0		;write protect status for all 16 drives.
3667   FAAF 00 00       LOGIN: 	.DW	0		;drive active word (1 bit per drive).
3668   FAB1 80 00       USERDMA: .DW	080H		;user's dma address (defaults to 80h).
3669   FAB3             ;
3670   FAB3             ;   Scratch areas from parameter block.
3671   FAB3             ;
3672   FAB3 00 00       SCRATCH1:  .DW	0		;relative position within dir segment for file (0-3).
3673   FAB5 00 00       SCRATCH2:  .DW	0		;last selected track number.
3674   FAB7 00 00       SCRATCH3:  .DW	0		;last selected sector number.
3675   FAB9             ;
3676   FAB9             ;   Disk storage areas from parameter block.
3677   FAB9             ;
3678   FAB9 00 00       DIRBUF: 	.DW	0		;address of directory buffer to use.
3679   FABB 00 00       DISKPB: 	.DW	0		;contains address of disk parameter block.
3680   FABD 00 00       CHKVECT: .DW	0		;address of check vector.
3681   FABF 00 00       ALOCVECT:  .DW	0		;address of allocation vector (bit map).
3682   FAC1             ;
3683   FAC1             ;   Parameter block returned from the bios.
3684   FAC1             ;
3685   FAC1 00 00       SECTORS: .DW	0		;sectors per track from bios.
3686   FAC3 00          BLKSHFT: .DB	0		;block shift.
3687   FAC4 00          BLKMASK: .DB	0		;block mask.
3688   FAC5 00          EXTMASK: .DB	0		;extent mask.
3689   FAC6 00 00       DSKSIZE: .DW	0		;disk size from bios (number of blocks-1).
3690   FAC8 00 00       DIRSIZE: .DW	0		;directory size.
3691   FACA 00 00       ALLOC0: 	.DW	0		;storage for first bytes of bit map (dir space used).
3692   FACC 00 00       ALLOC1: 	.DW	0
3693   FACE 00 00       OFFSET: 	.DW	0		;first usable track number.
3694   FAD0 00 00       XLATE: 	.DW	0		;sector translation table address.
3695   FAD2             ;
3696   FAD2             ;
3697   FAD2 00          CLOSEFLG:  .DB	0		;close flag (=0ffh is extent written ok).
3698   FAD3 00          RDWRTFLG:  .DB	0		;read/write flag (0ffh=read, 0=write).
3699   FAD4 00          FNDSTAT: .DB	0		;filename found status (0=found first entry).
3700   FAD5 00          MODE: 	.DB	0		;I/o mode select (0=random, 1=sequential, 2=special random).
3701   FAD6 00          EPARAM: 	.DB	0		;storage for register (E) on entry to bdos.
3702   FAD7 00          RELBLOCK:  .DB	0		;relative position within fcb of block number written.
3703   FAD8 00          COUNTER: .DB	0		;byte counter for directory name searches.
3704   FAD9 00 00 00 00 SAVEFCB: .DW	0,0		;save space for address of fcb (for directory searches).
3705   FADD 00          BIGDISK: .DB	0		;if =0 then disk is > 256 blocks long.
3706   FADE 00          AUTO: 	.DB	0		;if non-zero, then auto select activated.
3707   FADF 00          OLDDRV: 	.DB	0		;on auto select, storage for previous drive.
3708   FAE0 00          AUTOFLAG:  .DB	0		;if non-zero, then auto select changed drives.
3709   FAE1 00          SAVNXT: 	.DB	0		;storage for next record number to access.
3710   FAE2 00          SAVEXT: 	.DB	0		;storage for extent number of file.
3711   FAE3 00 00       SAVNREC: .DW	0		;storage for number of records in file.
3712   FAE5 00 00       BLKNMBR: .DW	0		;block number (physical sector) used within a file or logical sect
3713   FAE7 00 00       LOGSECT: .DW	0		;starting logical (128 byte) sector of block (physical sector).
3714   FAE9 00          FCBPOS: 	.DB	0		;relative position within buffer for fcb of file of interest.
3715   FAEA 00 00       FILEPOS: .DW	0		;files position within directory (0 to max entries -1).
3716   FAEC             ;
3717   FAEC             ;   Disk directory buffer checksum bytes. One for each of the
3718   FAEC             ; 16 possible drives.
3719   FAEC             ;
3720   FAEC             CKSUMTBL:  .DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3720   FAEC 00000000000000000000000000000000
3721   FAFC             ;
3722   FAFC             ;   Extra space ?
3723   FAFC             ;
3724   FAFC 00 00 00 00 	.DB	0,0,0,0
3725   FB00             ;
3726   FB00             ;**************************************************************
3727   FB00             ;*
3728   FB00             ;*        B I O S   J U M P   T A B L E
3729   FB00             ;*
3730   FB00             ;**************************************************************
3731   FB00             ;
3732   FB00                 include "ipc.inc"
0001+  FB00 C3 96 FB    BOOT:    JP BIOS_BOOT
0002+  FB03 C3 9E FB    WBOOT:   JP BIOS_WBOOT
0003+  FB06 C3 A4 FB    CONST:   JP BIOS_CONST
0004+  FB09 C3 AB FB    CONIN:   JP BIOS_CONIN
0005+  FB0C C3 B2 FB    CONOUT:  JP BIOS_CONOUT
0006+  FB0F C3 B9 FB    LIST:    JP BIOS_LIST
0007+  FB12 C3 C0 FB    PUNCH:   JP BIOS_PUNCH
0008+  FB15 C3 C7 FB    READER:  JP BIOS_READER
0009+  FB18 C3 F5 FB    HOME:    JP BIOS_HOME
0010+  FB1B C3 D5 FB    SELDSK:  JP BIOS_SELDSK
0011+  FB1E C3 EE FB    SETTRK:  JP BIOS_SETTRK
0012+  FB21 C3 FE FB    SETSEC:  JP BIOS_SETSEC
0013+  FB24 C3 0C FC    SETDMA:  JP BIOS_SETDMA
0014+  FB27 C3 17 FC    READ:    JP BIOS_READ
0015+  FB2A C3 2F FC    WRITE:   JP BIOS_WRITE
0016+  FB2D C3 45 FC    PRSTAT:  JP BIOS_PRSTAT
0017+  FB30 C3 14 FC    SECTRN:  JP BIOS_SECTRN
0018+  FB33             
0019+  FB33             ;----------------------------------------------------------------------------
0020+  FB33             
0021+  FB33             MAX_FILES_COUNT = 128
0022+  FB33             MAX_BLOCKS_COUNT = 2048
0023+  FB33             MAX_DEVICES = 2
0024+  FB33             
0025+  FB33             OPCODE_JP = 0xC3
0026+  FB33             
0027+  FB33             PORT_WINDOW_0 = 0
0028+  FB33             PORT_WINDOW_1 = 1
0029+  FB33             PORT_WINDOW_2 = 2
0030+  FB33             
0031+  FB33             PAGE_RAM_0 = 4 * 2
0032+  FB33             PAGE_RAM_1 = 5 * 2
0033+  FB33             PAGE_RAM_2 = 6 * 2
0034+  FB33             
0035+  FB33             ;----------------------------------------------------------------------------
0036+  FB33             
0037+  FB33             SYSCALL_STACK = 100h
0038+  FB33             
0039+  FB33             SYSCALL_INTERRUPT = 0  * 3 + 5
0040+  FB33             SYSCALL_WBOOT     = 1  * 3 + 5
0041+  FB33             SYSCALL_CONST     = 2  * 3 + 5
0042+  FB33             SYSCALL_CONIN     = 3  * 3 + 5
0043+  FB33             SYSCALL_CONOUT    = 4  * 3 + 5
0044+  FB33             SYSCALL_LIST      = 5  * 3 + 5
0045+  FB33             SYSCALL_PUNCH     = 6  * 3 + 5
0046+  FB33             SYSCALL_READER    = 7  * 3 + 5
0047+  FB33             SYSCALL_SELDSK    = 8  * 3 + 5
0048+  FB33             SYSCALL_SETTRK    = 9  * 3 + 5
0049+  FB33             SYSCALL_SETSEC    = 10 * 3 + 5
0050+  FB33             SYSCALL_READ      = 11 * 3 + 5
0051+  FB33             SYSCALL_WRITE     = 12 * 3 + 5
0052+  FB33             SYSCALL_PRSTAT    = 13 * 3 + 5
0053+  FB33             
0054+  FB33             ;----------------------------------------------------------------------------
0055+  FB33             
0056+  FB33             RUN: 
0057+  FB33                     ; Выбрать сраницы ОЗУ для CP/M
0058+  FB33 F3                  DI
0059+  FB34 3E 08               LD A, PAGE_RAM_0
0060+  FB36 D3 00       	OUT (PORT_WINDOW_0), a
0061+  FB38 3E 0A       	LD A, PAGE_RAM_1
0062+  FB3A D3 01       	OUT (PORT_WINDOW_1), a
0063+  FB3C 3E 0C       	LD A, PAGE_RAM_2
0064+  FB3E D3 02       	OUT (PORT_WINDOW_2), a
0065+  FB40                     ; Окно 3 уже выбрано
0066+  FB40             
0067+  FB40                     ; Установка обработчика прерываний
0068+  FB40 3E C3       	LD A, OPCODE_JP
0069+  FB42 32 38 00    	LD (38h), A
0070+  FB45 21 75 FB    	LD HL, INTERRUPT
0071+  FB48 22 39 00    	LD (39h), HL
0072+  FB4B 31 AB EC            LD SP, CCPSTACK
0073+  FB4E FB                  EI
0074+  FB4F             	
0075+  FB4F                     ; Настройка переменных CP/M
0076+  FB4F 32 00 00    	LD (0), A
0077+  FB52 21 03 FB            LD HL, WBOOT
0078+  FB55 22 01 00    	LD (1), HL
0079+  FB58 32 05 00    	LD (5), A
0080+  FB5B 21 06 ED    	LD HL, FBASE
0081+  FB5E 22 06 00    	LD (6), HL
0082+  FB61 79                  LD A, C
0083+  FB62 32 04 00            LD (TDRIVE), A
0084+  FB65 21 80 00            LD HL, TBUFF
0085+  FB68 22 73 FB            LD (BIOS_DMA), HL
0086+  FB6B 3E 81               LD A, 81h
0087+  FB6D 32 03 00            LD (IOBYTE), A
0088+  FB70             
0089+  FB70                     ; Запуск CP/M
0090+  FB70 C3 00 E5    	JP CBASE
0091+  FB73             
0092+  FB73             ;----------------------------------------------------------------------------
0093+  FB73             
0094+  FB73 00 00       BIOS_DMA DW 0
0095+  FB75             
0096+  FB75             ;----------------------------------------------------------------------------
0097+  FB75             
0098+  FB75             INTERRUPT: 
0099+  FB75                 ; Save CPU state, switch stack and memory page
0100+  FB75 F5              PUSH AF
0101+  FB76 E5              PUSH HL
0102+  FB77 21 00 00        LD HL, 0
0103+  FB7A 39              ADD HL, SP
0104+  FB7B 22 90 FB        LD (INTERRUPT_SAVED_SP), HL
0105+  FB7E 31 00 01        LD SP, SYSCALL_STACK
0106+  FB81 AF              XOR A
0107+  FB82 D3 00           OUT (PORT_WINDOW_0), A
0108+  FB84 C5              PUSH BC
0109+  FB85 D5              PUSH DE
0110+  FB86             
0111+  FB86                 ; System call
0112+  FB86 CD 05 00        CALL SYSCALL_INTERRUPT
0113+  FB89             
0114+  FB89                 ; Restore CPU state
0115+  FB89 D1              POP DE
0116+  FB8A C1              POP BC
0117+  FB8B 3E 08           LD A, PAGE_RAM_0
0118+  FB8D D3 00           OUT (PORT_WINDOW_0), A
0119+  FB8F             INTERRUPT_SAVED_SP = $ + 1
0120+  FB8F 31 00 00        LD SP, 0
0121+  FB92 E1              POP HL
0122+  FB93 F1              POP AF
0123+  FB94             
0124+  FB94                 ; End of interrupt handler
0125+  FB94 FB              EI
0126+  FB95 C9              RET
0127+  FB96             
0128+  FB96             ;----------------------------------------------------------------------------
0129+  FB96                     
0130+  FB96             BIOS_BOOT: 
0131+  FB96 F3          	DI
0132+  FB97 3E FF       	LD A, 0FFh
0133+  FB99 D3 00       	OUT (PORT_WINDOW_0), A
0134+  FB9B C3 00 00    	JP 0
0135+  FB9E             
0136+  FB9E             ;----------------------------------------------------------------------------
0137+  FB9E             
0138+  FB9E             BIOS_WBOOT: 
0139+  FB9E 11 08 00    	LD DE, SYSCALL_WBOOT
0140+  FBA1 C3 49 FC    	JP SYSCALL
0141+  FBA4             
0142+  FBA4             ;----------------------------------------------------------------------------
0143+  FBA4             
0144+  FBA4             BIOS_CONST: 
0145+  FBA4 D5              PUSH DE
0146+  FBA5 11 0B 00    	LD DE, SYSCALL_CONST
0147+  FBA8 C3 49 FC    	JP SYSCALL
0148+  FBAB             
0149+  FBAB             ;----------------------------------------------------------------------------
0150+  FBAB             
0151+  FBAB             BIOS_CONIN: 
0152+  FBAB D5              PUSH DE
0153+  FBAC 11 0E 00    	LD DE, SYSCALL_CONIN
0154+  FBAF C3 49 FC    	JP SYSCALL
0155+  FBB2             
0156+  FBB2             ;----------------------------------------------------------------------------
0157+  FBB2             	
0158+  FBB2             BIOS_CONOUT: 
0159+  FBB2 D5                  PUSH DE
0160+  FBB3 11 11 00            LD DE, SYSCALL_CONOUT
0161+  FBB6 C3 49 FC            JP SYSCALL
0162+  FBB9             
0163+  FBB9             ;----------------------------------------------------------------------------
0164+  FBB9             
0165+  FBB9             BIOS_LIST: 
0166+  FBB9 D5              PUSH DE
0167+  FBBA 11 14 00    	LD DE, SYSCALL_LIST
0168+  FBBD C3 49 FC    	JP SYSCALL
0169+  FBC0             	
0170+  FBC0             ;----------------------------------------------------------------------------
0171+  FBC0             
0172+  FBC0             BIOS_PUNCH: 
0173+  FBC0 D5              PUSH DE
0174+  FBC1 11 17 00    	LD DE, SYSCALL_PUNCH
0175+  FBC4 C3 49 FC    	JP SYSCALL
0176+  FBC7             	
0177+  FBC7             ;----------------------------------------------------------------------------
0178+  FBC7             
0179+  FBC7             BIOS_READER: 
0180+  FBC7 D5              PUSH DE
0181+  FBC8 11 1A 00    	LD DE, SYSCALL_READER
0182+  FBCB C3 49 FC    	JP SYSCALL
0183+  FBCE             
0184+  FBCE             ;----------------------------------------------------------------------------
0185+  FBCE             
0186+  FBCE             BIOS_SELDSK2: 
0187+  FBCE D5              PUSH DE
0188+  FBCF 11 1D 00    	LD DE, SYSCALL_SELDSK
0189+  FBD2 C3 49 FC    	JP SYSCALL
0190+  FBD5             
0191+  FBD5             ;----------------------------------------------------------------------------
0192+  FBD5             
0193+  FBD5             BIOS_SELDSK: 
0194+  FBD5                 ; Check device number
0195+  FBD5 79              LD A, C
0196+  FBD6 FE 02           CP MAX_DEVICES
0197+  FBD8 21 00 00        LD HL, 0
0198+  FBDB D0              RET NC
0199+  FBDC                 
0200+  FBDC                 ; System call
0201+  FBDC CD CE FB        CALL BIOS_SELDSK2
0202+  FBDF                 
0203+  FBDF                 ; Check error
0204+  FBDF B7              OR A
0205+  FBE0 C0              RET NZ
0206+  FBE1             	
0207+  FBE1                 ; Save current device number
0208+  FBE1 79              LD A, C
0209+  FBE2 32 04 00        LD (TDRIVE), A
0210+  FBE5             	
0211+  FBE5                 ; Return DPH address
0212+  FBE5 B7              OR A
0213+  FBE6 21 60 FF        LD HL, BIOS_DPH_A
0214+  FBE9 C8              RET Z
0215+  FBEA 21 70 FF        LD HL, BIOS_DPH_B    
0216+  FBED C9              RET
0217+  FBEE             
0218+  FBEE             ;----------------------------------------------------------------------------
0219+  FBEE             
0220+  FBEE             BIOS_SETTRK: 
0221+  FBEE D5              PUSH DE
0222+  FBEF 11 20 00    	LD DE, SYSCALL_SETTRK
0223+  FBF2 C3 49 FC    	JP SYSCALL
0224+  FBF5             	
0225+  FBF5             ;----------------------------------------------------------------------------
0226+  FBF5             
0227+  FBF5             BIOS_HOME: 
0228+  FBF5 C5              PUSH BC
0229+  FBF6 01 00 00    	LD BC, 0
0230+  FBF9 CD EE FB    	CALL BIOS_SETTRK
0231+  FBFC C1          	POP BC
0232+  FBFD C9          	RET
0233+  FBFE             	
0234+  FBFE             ;----------------------------------------------------------------------------
0235+  FBFE             
0236+  FBFE             BIOS_SETSEC: 
0237+  FBFE D5              PUSH DE
0238+  FBFF 11 23 00    	LD DE, SYSCALL_SETSEC
0239+  FC02 C3 49 FC    	JP SYSCALL
0240+  FC05             
0241+  FC05             ;----------------------------------------------------------------------------
0242+  FC05             
0243+  FC05             BIOS_READ2:         
0244+  FC05 D5              PUSH DE
0245+  FC06 11 26 00        LD DE, SYSCALL_READ
0246+  FC09 C3 49 FC        JP SYSCALL
0247+  FC0C             	
0248+  FC0C             ;----------------------------------------------------------------------------
0249+  FC0C             
0250+  FC0C             BIOS_SETDMA: 
0251+  FC0C E5              PUSH HL
0252+  FC0D 60 69           LD HL, BC
0253+  FC0F 22 73 FB    	LD (BIOS_DMA), HL
0254+  FC12 E1          	POP HL
0255+  FC13 C9          	RET
0256+  FC14             	
0257+  FC14             ;----------------------------------------------------------------------------
0258+  FC14             
0259+  FC14             BIOS_SECTRN: 
0260+  FC14 60 69       	LD HL, BC
0261+  FC16 C9          	RET
0262+  FC17             
0263+  FC17             ;----------------------------------------------------------------------------
0264+  FC17             
0265+  FC17             BIOS_READ: 
0266+  FC17 CD 05 FC        CALL BIOS_READ2
0267+  FC1A                 
0268+  FC1A             	; Check error
0269+  FC1A B7          	OR A
0270+  FC1B C0          	RET NZ
0271+  FC1C             	
0272+  FC1C                 ; Copy data from the system call buffer	
0273+  FC1C D5              PUSH DE
0274+  FC1D E5              PUSH HL
0275+  FC1E 11 80 FF    	LD DE, BIOS_DMA_BUFFER
0276+  FC21 2A 73 FB    	LD HL, (BIOS_DMA)
0277+  FC24             BIOS_READ_1: 	
0278+  FC24 1A          	LD A, (DE)
0279+  FC25 77          	LD (HL), A
0280+  FC26 23          	INC HL
0281+  FC27 1C          	INC E
0282+  FC28 C2 24 FC    	JP NZ, BIOS_READ_1
0283+  FC2B E1          	POP HL
0284+  FC2C D1          	POP DE
0285+  FC2D             	
0286+  FC2D             	; No error
0287+  FC2D AF          	XOR A
0288+  FC2E C9          	RET
0289+  FC2F             
0290+  FC2F             ;----------------------------------------------------------------------------
0291+  FC2F             
0292+  FC2F             BIOS_WRITE: 
0293+  FC2F D5              PUSH DE
0294+  FC30             
0295+  FC30                 ; Copy data to the system call buffer
0296+  FC30 E5              PUSH HL
0297+  FC31 11 80 FF        LD DE, BIOS_DMA_BUFFER
0298+  FC34 2A 73 FB        LD HL, (BIOS_DMA)
0299+  FC37             BIOS_WRITE_1: 	
0300+  FC37 7E              LD A, (HL)
0301+  FC38 12              LD (DE), A
0302+  FC39 23              INC HL
0303+  FC3A 1C              INC E
0304+  FC3B C2 37 FC        JP NZ, BIOS_WRITE_1
0305+  FC3E E1              POP HL
0306+  FC3F             	
0307+  FC3F                 ; System call
0308+  FC3F 11 29 00        LD DE, SYSCALL_WRITE
0309+  FC42 C3 49 FC        JP SYSCALL
0310+  FC45             
0311+  FC45             ;----------------------------------------------------------------------------
0312+  FC45             
0313+  FC45             BIOS_PRSTAT: 
0314+  FC45 D5                  PUSH DE
0315+  FC46 11 2C 00            LD DE, SYSCALL_PRSTAT
0316+  FC49             
0317+  FC49             SYSCALL: 
0318+  FC49 E5                  PUSH HL
0319+  FC4A             
0320+  FC4A                     ; Save stack pointer
0321+  FC4A 21 00 00            LD HL, 0
0322+  FC4D 39                  ADD HL, SP
0323+  FC4E 22 65 FC            LD (BIOS_SAVED_SP), HL
0324+  FC51             
0325+  FC51                     ; Switch RAM and stack pointer
0326+  FC51 AF                  XOR A
0327+  FC52 F3                  DI
0328+  FC53 31 00 01            LD SP, SYSCALL_STACK
0329+  FC56 D3 00               OUT (PORT_WINDOW_0), A
0330+  FC58 FB                  EI
0331+  FC59             
0332+  FC59                     ; System call
0333+  FC59 EB                  EX HL, DE
0334+  FC5A C5                  PUSH BC
0335+  FC5B CD 6C FC            CALL CALL_HL
0336+  FC5E C1                  POP BC
0337+  FC5F             
0338+  FC5F                     ; Switch RAM and stack pointer
0339+  FC5F 3E 08               LD A, PAGE_RAM_0
0340+  FC61 F3                  DI
0341+  FC62 D3 00               OUT (PORT_WINDOW_0), A
0342+  FC64             BIOS_SAVED_SP = $ + 1	
0343+  FC64 31 00 00            LD SP, 0
0344+  FC67 FB                  EI
0345+  FC68             
0346+  FC68                     ; Return
0347+  FC68 7A                  LD A, D
0348+  FC69 E1                  POP HL
0349+  FC6A D1                  POP DE
0350+  FC6B C9                  RET
0351+  FC6C             
0352+  FC6C             ;----------------------------------------------------------------------------
0353+  FC6C                     
0354+  FC6C             CALL_HL: 
0355+  FC6C E9          	JP HL
0356+  FC6D             
0357+  FC6D             ;----------------------------------------------------------------------------
0358+  FC6D             
0359+  FC6D             BIOS_DPB_A DB 28h, 0, 4, 0Fh, 0, 8Ah, 1, 3Fh, 0, 080h, 0, 10h, 0, 2, 0
0359+  FC6D 2800040F008A013F00800010000200
0360+  FC7C             BIOS_DPB_B DB 28h, 0, 4, 0Fh, 0, 8Ah, 1, 3Fh, 0, 080h, 0, 10h, 0, 2, 0
0360+  FC7C 2800040F008A013F00800010000200
0361+  FC8B 00          BIOS_DIRBUF DS 128
0362+  FD0B 00          BIOS_CSV_A DS MAX_FILES_COUNT / 4
0363+  FD2B 00          BIOS_CSV_B DS MAX_FILES_COUNT / 4
0364+  FD4B 00          BIOS_ALV_A DS MAX_BLOCKS_COUNT / 8
0365+  FE4B 00          BIOS_ALV_B DS MAX_BLOCKS_COUNT / 8
0366+  FF4B             
0367+  FF4B             ; CP/M BIOS buffers
0368+  FF4B             
0369+  FF4B 00          		DS 0x10000 - 128 - 16 * MAX_DEVICES - $
0370+  FF60             	
0371+  FF60 00          BIOS_DPH_A DS 8
0372+  FF68 8B FC                  DW BIOS_DIRBUF
0373+  FF6A 6D FC                  DW BIOS_DPB_A
0374+  FF6C 0B FD                  DW BIOS_CSV_A
0375+  FF6E 4B FD                  DW BIOS_ALV_A
0376+  FF70                        
0377+  FF70 00          BIOS_DPH_B DS 8
0378+  FF78 8B FC                  DW BIOS_DIRBUF
0379+  FF7A 7C FC                  DW BIOS_DPB_B
0380+  FF7C 2B FD                  DW BIOS_CSV_B
0381+  FF7E 4B FE                  DW BIOS_ALV_B
0382+  FF80             
0383+  FF80 00          BIOS_DMA_BUFFER DS 128
0384+  0000             
3733   0000             ;*
3734   0000             ;******************   E N D   O F   C P / M   *****************
3735   0000             ;*
3736   0000             
3737   0000             	.END
3738   0000             
